/**
 * @param {string} s
 * @param {string[]} dictionary
 * @return {number}
 * 
 * minExtraChar принимает на вход строку s
 * и массив слов dictionary.
 * 
 * Цель функции — найти минимальное число
 * «лишних» символов в s, которые не
 * покрываются словами из словаря.
 * 
 * Пример: 
 * minExtraChar("leetscode", ["leet", "code"])
 * вернёт 1, потому что «leet» и «code»
 * покрывают 8 символов, остаётся только «s».
 */
function minExtraChar(s, dictionary) {
  // Вычисляем длину строки s.
  //
  // Для примера "leetscode" n = 9
  const n = s.length;

  // Создаем массив dp длиной n+1,
  // изначально заполненный нулями.
  // dp[i] будет хранить минимальное число
  // лишних символов в s[i..end].
  //
  // Начальное состояние: [0,0,0,0,0,0,0,0,0,0],
  // где dp[9] = 0 (пустая строка не несет
  // лишних символов).
  const dp = new Int32Array(n + 1);


  // Запускаем цикл от конца строки
  // (индекс n-1) к началу (0), заполняя dp
  for (let i = n - 1; i >= 0; i--) {

    // Подробный пример шагов
    // для s="leetscode",
    // dictionary=["leet","code"]:
    //
    // i = 8: позиция 8 — "leetscod[e]"
    //   суффикс = "e"
    //   dp[8] = 1 + dp[9] = 1 + 0 = 1
    //   dp = [_,_,_,_,_,_,_,_,1,0]
    //   ни "leet", ни "code" здесь не
    //   стартуют → dp[8] остаётся 1
    //
    // i = 7: позиция 7 — "leetsco[d]e"
    //   суффикс = "de"
    //   dp[7] = 1 + dp[8] = 1 + 1 = 2
    //   dp = [_,_,_,_,_,_,_,2,1,0]
    //   ни одно слово не подходит → dp[7]=2
    //
    // i = 6: позиция 6 — "leetsc[o]de"
    //   суффикс = "ode"
    //   dp[6] = 1 + dp[7] = 1 + 2 = 3
    //   dp = [_,_,_,_,_,_,3,2,1,0]
    //   ни одно слово не подходит → dp[6]=3
    //
    // i = 5: позиция 5 — "leets[c]ode"
    //   суффикс = "code"
    //   сначала dp[5] = 1 + dp[6] = 4
    //   (временно считаем "c" лишним)
    //   слово "leet" не подходит
    //   слово "code" подходит 
    //   → dp[5] = min(4, dp[9]=0) = 0
    //   dp = [_,_,_,_,_,0,3,2,1,0]
    //
    // i = 4: позиция 4 — "leet[s]code"
    //   суффикс = "scode"
    //   dp[4] = 1 + dp[5] = 1 + 0 = 1
    //   dp = [_,_,_,_,1,0,3,2,1,0]
    //   ни одно слово не подходит → dp[4]=1
    //
    // i = 3: позиция 3 — "lee[t]scode"
    //   суффикс = "tscode"
    //   dp[3] = 1 + dp[4] = 1 + 1 = 2
    //   dp = [_,_,_,2,1,0,3,2,1,0]
    //   ни одно слово не подходит → dp[3]=2
    //
    // i = 2: позиция 2 — "le[e]tscode"
    //   суффикс = "etscode"
    //   dp[2] = 1 + dp[3] = 1 + 2 = 3
    //   dp = [_,_,3,2,1,0,3,2,1,0]
    //   ни одно слово не подходит → dp[2]=3
    //
    // i = 1: позиция 1 — "l[e]etscode"
    //   суффикс = "eetscode"
    //   dp[1] = 1 + dp[2] = 1 + 3 = 4
    //   dp = [_,4,3,2,1,0,3,2,1,0]
    //   ни одно слово не подходит → dp[1]=4
    //
    // i = 0: позиция 0 — "[l]eetscode"
    //   суффикс = "leetscode"
    //   dp[0] = 1 + dp[1] = 1 + 4 = 5
    //   (временно считаем "l" лишним)
    //   слово "leet" подходит →
    //   dp[0] = min(5, dp[4]=1) = 1
    //   dp = [1,4,3,2,1,0,3,2,1,0]
    //

    // Сначала считаем символ s[i] лишним:
    // добавляем 1 к значению dp[i+1]
    dp[i] = 1 + dp[i + 1];

    // Перебираем слова из словаря и проверяем,
    // соответствует ли подстрока s
    // с позиции i s[i..] кокому-либо слову
    for (const word of dictionary) {

      // Если подстрока s[i..]
      // не совпадает с текущим словом
      // - пропускаем
      if (!s.startsWith(word, i)) continue;

      // Если совпадение есть, то вместо
      // удаления одного символа можем
      // «поглотить» слово целиком:
      //
      // обновляем dp[i], сравнивая текущее
      // значение с dp[i + длина совпавшего слова]
      //
      // В наших ключевых примерах:
      //  - при i=5 слово "code"
      //    сбрасывает dp[5] до dp[9]=0
      //  - при i=0 слово "leet"
      //    даёт dp[0]=dp[4]=1
      //
      // dp[i] (1 + dp[i + 1]) может оказаться
      // меньше если слово
      // есть в словаре, но оно «отнимает»
      // слишком выгодное место для более
      // длинного совпадения чуть позже.
      // 
      // Также dp[i] (1 + dp[i + 1]) может
      // оказаться меньше, когда после
      // подстроки-слова остаётся
      // слишком длинный хвост неподходящих
      // символов.
      // В таком случае значение dp[i + word.length]
      // будет большим, и алгоритм выберет
      // вариант с пропуском текущего символа,
      // если 1 + dp[i + 1] < dp[i + word.length].
      dp[i] = Math.min(dp[i], dp[i + word.length]);
    }
  }

  // Итог: 
  // dp[0] хранит минимальное число лишних символов
  // для всей строки s
  return dp[0];
}
