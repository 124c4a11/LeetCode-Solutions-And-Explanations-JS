// Класс TrieNode представляет
// один узел префиксного дерева (Trie)
//
// Каждый узел хранит ссылки на детей
// по символам и флаг конца слова
class TrieNode {
  constructor() {

    // Объект children хранит пары
    // «символ → TrieNode»,
    // позволяющие расширять дерево
    this.children = {};

    // Флаг isEndOfWord сигнализирует,
    // что путь от корня до этого узла
    // составляет полное слово
    this.isEndOfWord = false;
  }
}

// Класс Trie реализует саму структуру
// префиксного дерева для набора слов,
// позволяющего добавлять слова
// и осуществлять поиск префиксов
class Trie {
  constructor() {
    // Корень, от которого начинаются
    // все возможные пути по символам
    //
    // Корень Trie всегда существует,
    // но не соответствует ни одному
    // символу
    this.root = new TrieNode();
  }

  /**
   * @param {string} word
   * @return {void}
   * 
   * Метод addWord добавляет слово в
   * префиксное дерево: идет по символам,
   * создавая новые узлы по мере
   * необходимости и ставя флаг в конце
   * слова.
   */
  addWord(word) {

    // curr указывает на текущий узел
    // (начнём с корня)
    let curr = this.root;

    // Проходим по каждому символу
    // вставляемого слова
    for (const char of word) {

      // Если для текущего символа
      // ещё нет ветви – создаём
      // новый узел
      if (!curr.children[char]) {
        curr.children[char] = new TrieNode();
      }

      // Переходим к новому или
      // уже существующему узлу
      curr = curr.children[char];
    }

    // Если текущий символ является
    // окончанием слова,
    // помечаем узел как «конец слова»
    curr.isEndOfWord = true;
  }
}

/**
 * @param {string} s
 * @param {string[]} dictionary
 * @return {number}
 * 
 * minExtraChar принимает на вход строку s
 * и массив слов dictionary.
 * 
 * Цель функции — найти минимальное число
 * «лишних» символов в s, которые не
 * покрываются словами из словаря.
 * 
 * Пример: 
 * minExtraChar("leetscode", ["leet", "code"])
 * вернёт 1, потому что «leet» и «code»
 * покрывают 8 символов, остаётся только «s».
 * 
 * Когда решение с Trie будет более
 * производительным
 * 
 * Решение на основе Trie начинает выигрывать
 * по производительности, когда прямой проход
 * по всем словам в словаре становится слишком
 * дорогим по времени. Вот ключевые сценарии:
 * 
 * 1. Большой и «тяжёлый» словарь  
 * - если размер словаря m велик
 *   (тысячи и более слов), то на каждую
 *   позицию i простой проход
 *   for (word of dictionary)  делает m проверок
 *   startsWith.  
 * - в худшем случае за одну позицию мы тратим
 *   O(m·L), где L — средняя длина слова.
 *   Trie же обрабатывает только реальные пути,
 *   сокращая поиск до O(L) на i.  
 * 
 * 2. Сильное пересечение префиксов  
 * - когда многие слова в dictionary имеют общие
 *   префиксы, Trie экономит повторные сравнения
 *   первых символов: они проверяются один раз на
 *   уровне узла.  
 * - на большом количестве похожих слов с общими
 *   началами объём работы метод startsWith
 *   многократно дублирует сравнения, а Trie — нет.  
 * 
 * 3. Многократные вызовы с одним и тем же словарём  
 * - если вы вызываете minExtraChar многократно на
 *   разных s, но словарь остаётся прежним,
 *   стоимость построения Trie (O(m)) амортизируется,
 *   а затем каждый вызов выполняется за O(n·L).  
 * - в наивном решении каждый раз заново перебираются
 *   все слова, что добавляет O(m·n) к общему времени.  
 */
function minExtraChar(s, dictionary) {
  // Вычисляем длину строки s.
  //
  // Для примера "leetscode" n = 9
  const n = s.length;

  // Строим префиксное дерево: вставляем
  // в него все слова словаря.
  //
  // В примере добавляем "leet" и "code"
  //
  // Trie структура после добавления
  // "leet" и "code":
  //
  // root
  // ├─ 'l'
  // │   └─ 'e'
  // │       └─ 'e'
  // │           └─ 't' (isEndOfWord = true)
  // └─ 'c'
  //     └─ 'o'
  //         └─ 'd'
  //             └─ 'e' (isEndOfWord = true)
  //
  const trie = new Trie();
  for (const word of dictionary) {
    trie.addWord(word);
  }

  // Создаем массив dp длиной n+1,
  // изначально заполненный нулями.
  // dp[i] будет хранить минимальное число
  // лишних символов в s[i..end].
  //
  // Начальное состояние: [0,0,0,0,0,0,0,0,0,0],
  // где dp[9] = 0 (пустая строка не несет
  // лишних символов).
  //
  // Благодаря dp[9] = 0 граница рекурсии
  // сворачивается, и мы можем последовательно
  // строить dp от конца к началу, получая
  // финальный ответ в dp[0].
  const dp = new Int32Array(n + 1);

  // Запускаем цикл от конца строки
  // (индекс n-1) к началу (0), заполняя dp
  for (let i = n - 1; i >= 0; i--) {

    // Подробный пример шагов
    // для s="leetscode",
    // dictionary=["leet","code"]:
    //
    // i = 8: позиция 8 — "leetscod[e]"
    //   суффикс = "e"
    //   dp[8] = 1 + dp[9] = 1 + 0 = 1
    //   dp = [_,_,_,_,_,_,_,_,1,0]
    //   В Trie нет слова, начинающегося
    //   на "e", поэтому dp[8] остаётся 1
    //
    // i = 7: позиция 7 — "leetsco[d]e"
    //   суффикс = "de"
    //   dp[7] = 1 + dp[8] = 1 + 1 = 2
    //   dp = [_,_,_,_,_,_,_,2,1,0]
    //   В Trie нет слова, начинающегося
    //   на "d" → dp[7]=2
    //
    // i = 6: позиция 6 — "leetsc[o]de"
    //   суффикс = "ode"
    //   dp[6] = 1 + dp[7] = 1 + 2 = 3
    //   dp = [_,_,_,_,_,_,3,2,1,0]
    //   В Trie нет слова, начинающегося
    //   на "o" → dp[6]=3
    //
    // i = 5: позиция 5 — "leets[c]ode"
    //   суффикс = "code"
    //   сначала dp[5] = 1 + dp[6] = 4
    //   (временно считаем "c" лишним)
    //   В Trie есть путь "c"→"o"→"d"→"e",
    //   и узел после "e" помечен как конец
    //   слова "code".  
    //   Тогда можно не считать эти символы
    //   лишними: 
    //   → dp[5] = min(4, dp[9]=0) = 0
    //   dp = [_,_,_,_,_,0,3,2,1,0]
    //
    // i = 4: позиция 4 — "leet[s]code"
    //   суффикс = "scode"
    //   dp[4] = 1 + dp[5] = 1 + 0 = 1
    //   dp = [_,_,_,_,1,0,3,2,1,0]
    //   В Trie нет слова, начинающегося
    //   на "s" → dp[4]=1
    //
    // i = 3: позиция 3 — "lee[t]scode"
    //   суффикс = "tscode"
    //   dp[3] = 1 + dp[4] = 1 + 1 = 2
    //   dp = [_,_,_,2,1,0,3,2,1,0]
    //   В Trie нет слова, начинающегося
    //   на "t" → dp[3]=2
    //
    // i = 2: позиция 2 — "le[e]tscode"
    //   суффикс = "etscode"
    //   dp[2] = 1 + dp[3] = 1 + 2 = 3
    //   dp = [_,_,3,2,1,0,3,2,1,0]
    //   В Trie нет слова, начинающегося
    //   на "e" → dp[2]=3
    //
    // i = 1: позиция 1 — "l[e]etscode"
    //   суффикс = "eetscode"
    //   dp[1] = 1 + dp[2] = 1 + 3 = 4
    //   dp = [_,4,3,2,1,0,3,2,1,0]
    //   В Trie нет слова, начинающегося
    //   на "e" → dp[1]=4
    //
    // i = 0: позиция 0 — "[l]eetscode"
    //   суффикс = "leetscode"
    //   dp[0] = 1 + dp[1] = 1 + 4 = 5
    //   (временно считаем "l" лишним)
    //   В Trie есть путь "l"→"e"→"e"→"t",
    //   узел после "t" — конец слова "leet".  
    //   Тогда dp[0] = min(5, dp[4]=1) = 1  
    //   dp = [1,4,3,2,1,0,3,2,1,0]
    //

    // Сначала считаем символ s[i] лишним:
    // добавляем 1 к значению dp[i+1]
    dp[i] = 1 + dp[i + 1];

    // Пытаемся «взять» слово,
    // начиная с позиции i, идя по Trie
    // Этот фрагмент кода перебирает
    // все подстроки s[i..j],
    // начинающиеся в позиции i, и проверяет,
    // есть ли они в словаре Trie.
    // Если подстрока присутствует, мы можем
    // «закрыть» её без лишних символов и
    // посмотреть результат на суффиксе
    // после неё.
    //
    // Инициализируем curr = trie.root,
    // чтобы каждый раз начинать обход
    // префиксного дерева с его корня.
    let curr = trie.root;
    for (let j = i; j < n; j++) {

      // Если символ s[j] не продолжает
      // ни одно слово в Trie – выходим
      if (!curr.children[s[j]]) break;

      // Иначе спускаемся по ветви,
      // соответствующей s[j]
      curr = curr.children[s[j]];

      // Если текущий узел не отмечен
      // как конец слова, продолжаем
      // углубляться
      if (!curr.isEndOfWord) continue;

      // Дошли до конца слова s[i..j]
      // в словаре; можно не считать
      // эти символы лишними
      // обновляем dp[i], сравнивая
      // текущий вариант с dp[j+1]
      //
      // В наших ключевых примерах:
      //  - при i=5 слово "code"
      //    сбрасывает dp[5] до dp[9]=0
      //  - при i=0 слово "leet"
      //    даёт dp[0]=dp[4]=1
      //
      // dp[i] (1 + dp[i + 1]) может оказаться
      // меньше если слово
      // есть в словаре, но оно «отнимает»
      // слишком выгодное место для более
      // длинного совпадения чуть позже.
      // 
      // Также dp[i] (1 + dp[i + 1]) может
      // оказаться меньше, когда после
      // подстроки-слова остаётся
      // слишком длинный хвост неподходящих
      // символов.
      // В таком случае значение dp[j + 1]
      // будет большим, и алгоритм выберет
      // вариант с пропуском текущего символа,
      // если 1 + dp[i + 1] < dp[j + 1].
      dp[i] = Math.min(dp[i], dp[j + 1]);
    }
  }

  // Итог: 
  // dp[0] хранит минимальное число лишних символов
  // для всей строки s
  return dp[0];
}
