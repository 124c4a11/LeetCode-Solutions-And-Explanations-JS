/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 * 
 * Функция принимает массив nums
 * и целое число k.
 * 
 * Возвращает true, если в массиве есть
 * два одинаковых элемента с индексами
 * i и j, такими что |i - j| ≤ k.
 * Иначе возвращает false.
 * 
 * Пример 1: 
 *  nums = [1,2,3,1], k = 3 → true,
 *  потому что nums[0] === nums[3]
 *  и |3 - 0| = 3 ≤ k.
 * 
 * Пример 2: 
 *  nums = [1,0,1,1], k = 1 → true,
 *  потому что nums[2] === nums[3]
 *  и |3 - 2| = 1 ≤ k.
 * 
 * Пример 3:
 *  nums = [1,2,3,1,2,3], k = 2 → false,
 *  ни один дубликат не в пределах
 *  расстояния 2.
 */
function containsNearbyDuplicate(nums, k) {

  // Создаем пустое множество numSet
  // для хранения элементов текущего
  // окна размера ≤ k.
  //
  // Используем Set, чтобы операции
  // проверки наличия и удаления
  // выполнялись за O(1).
  //
  // Состояние до начала итераций:
  // numSet = {}
  const numSet = new Set();

  // Инициализируем левый указатель
  // окна l = 0.
  // Будем поддерживать окно [l, r] так,
  // чтобы его длина не превышала
  // k + 1 элементов.
  //
  // Начальное состояние окна:
  // пустое, l = 0. 
  let l = 0;

  // Перебираем массив с помощью правого
  // указателя r.
  // На каждой итерации окно охватывает
  // индексы от l до r включительно.
  for (let r = 0; r < nums.length; r++) {

    // Если текущий размер окна r − l
    // превышает k, нужно сдвинуть
    // окно вправо:
    // 1. удалить элемент nums[l] из Set,
    //   так как он выходит за пределы окна.
    // 2. увеличить l на 1
    //
    // Так мы гарантируем, что в Set
    // хранятся только элементы с индексами
    // между l и r включительно.
    //
    // После того как правая граница выйдет
    // за пределы окна размера k
    // (то есть при r = k + 1),
    // выражение r - l > k будет истинным
    // в каждой итерации цикла. 
    if (r - l > k) {

      // Удаляем элемент nums[l] из Set,
      // так как после того, как мы
      // сдвинем левую границу окна l 
      // вправо он выходит за пределы
      // окна. 
      numSet.delete(nums[l]);

      // Сдвигаем левую границу окна
      // вправо, теперь окно охватывает
      // диапазон [l+1 ... r]
      l++;
    }

    // Проверяем, содержится ли nums[r] в
    // множестве numSet.
    //
    // Если да, значит мы уже встречали такое
    // значение в текущем окне длиной ≤ k,
    // то есть найдена пара дубликатов,
    // и условие |i - j| ≤ k выполняется.
    //
    // В этом случае можем сразу вернуть true.
    if (numSet.has(nums[r])) return true;

    // Если nums[r] ещё не встречался
    // в текущем окне, добавляем его в numSet.
    numSet.add(nums[r]);
  }

  // Если после полного прохода по массиву
  // ни одно окно не содержало дубликаты,
  // возвращаем false.
  return false;
}
