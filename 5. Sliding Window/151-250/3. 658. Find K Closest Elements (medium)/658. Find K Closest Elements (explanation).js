/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 * 
 * Функция findClosestElements находит
 * k элементов массива arr,
 * наиболее близких по значению к x.
 * 
 * Пример вызова:
 * findClosestElements([1, 2, 3, 4, 5], 4, 3) 
 * вернёт [1, 2, 3, 4]
 */
function findClosestElements(arr, k, x) {

  // Устанавливаем левую границу l = 0.
  // l — минимальный возможный индекс
  // начала окна из k элементов.
  //
  // В примере потенциальные начала окна:
  // 0 или 1, поэтому l = 0.
  let l = 0;

  // Устанавливаем правую границу
  // r = arr.length - k.
  // r — максимальный возможный индекс
  // начала окна, чтобы окно длиной k
  // завершалось в конце массива
  // и не выходило за его пределы.
  //
  // В примере r = 5 - 4 = 1.
  let r = arr.length - k;

  // Бинарный поиск по диапазону [l, r]
  // для определения оптимального
  // начала окна.
  //
  // ---
  //
  // Почему используем `while (l < r)`,
  // а не `while (l <= r)`
  //
  // Когда мы ищем границу
  // (начало оптимального окна) и в итоге
  // возвращаем индекс l, нам важно,
  // чтобы цикл останавливался ровно тогда,
  // когда интервал сузился до одного кандидата.
  // Шаблон с while (l < r) гарантирует,
  // что мы перестаём шагать, как только l == r,
  // и сразу возвращаем это значение без лишних
  // проверок.
  //
  // ---
  //
  // 1. Поиск границы (lower bound) vs проверка
  //    наличия элемента
  //  - while (l <= r)` обычно применяется,
  //    когда внутри цикла мы проверяем условие
  //    «нашли ли мы нужный элемент», и выходим
  //    досрочно через break или return.  
  //  - Здесь же мы не ищем точное совпадение,
  //    а двигаем границы вплоть до одной точки.
  //    while (l < r) идеально подходит для поиска
  //    минимального l, удовлетворяющего неравенству.
  //
  // ---
  //
  // 2. Гарантия сужения интервала
  //  - При каждом шаге мы вычисляем 
  //    midd = Math.floor(l + (r - l) / 2).  
  //  - Ветвь l = mid + 1 уменьшает правую длину
  //    интервала, а r = mid уменьшает левую.  
  //  - Так как в обеих ветвях мы строго
  //    уменьшаем (или сдвигаем) границы,
  //    интервал всегда сокращается на шаг,
  //    и цикл закончится, как только l «догонит» r.
  //
  // ---
  //
  // 3. Риск бесконечного цикла с `<=`
  // Если бы мы писали while (l <= r), то при l == r
  // мы всё ещё вошли бы внутрь цикла:
  // 1. midd = Math.floor(l + (r - l) / 2) === l.
  // 2. В ветке r = mid — границы не меняются,
  //    цикл никогда не выйдет.
  // 3. В ветке `l = mid + 1` — `l` перестанет быть ≤ `r`,
  //    но если выбор ветви другой (или смешанный),
  //    мы можем застрять.
  //
  // ---
  //
  // 4. Правильный шаблон для поиска границы
  // Используйте while (l < r) когда:
  // - Не нужно явное break или return.
  // - Не нужно проверять «нашли ли совпадение».
  // - Нужно получить минимальный (или максимальный) индекс,
  //   удовлетворяющий условию.
  //
  // В нашем случае это идеально: цикл завершается,
  // когда найден единственный корректный старт окна,
  // а `l` сразу его и отдаёт.
  while (l < r) {

    // midd — середина отрезка [l, r],
    // округлённая вниз.
    const midd = Math.floor(l + (r - l) / 2);

    // Сравниваем два кандидата на границы окна:
    // левый — arr[midd], правый — arr[midd + k].
    // Определяем, какое значение ближе к x.
    //
    // В примере:
    //   arr[midd]      = arr[0] = 1, |3 - 1| = 2
    //   arr[midd + k]  = arr[4] = 5, |5 - 3| = 2
    // Получаем 2 > 2? Нет,
    // значит переходим в ветку else.
    //
    // ---
    //
    // Критерии близости элементов к x:
    //
    // Мы говорим, что элемент arr[i] «ближе» к x,
    // если абсолютная разница |arr[i] - x| меньше,
    // чем у любого другого кандидата.
    //
    // - Основная метрика: |arr[i] - x|.
    // - При равных значениях этой метрики отдаётся
    //   предпочтение меньшему элементу (за счёт того,
    //   что массив отсортирован и окно «смещается»
    //   влево при равенстве).
    //
    // ---
    //
    // Почему выбран непрерывный отрезок длины k:
    //
    // В отсортированном массиве любые k ближайших
    // по значению элементов образуют подряд
    // идущий фрагмент. Если бы они были разбросаны,
    // между ними существовали бы более удалённые
    // от x элементы, что противоречит условию
    // «k самых близких».
    //
    // Пример
    // - arr = [1, 2, 3, 4, 5], k = 3, x = 3
    // - Возможные наборы по абсолютной разнице:
    //   - окно [1,2,3] → разницы [2,1,0]
    //   - окно [2,3,4] → разницы [1,0,1]
    //   - окно [3,4,5] → разницы [0,1,2]
    // - Лучшие — это подряд идущие окна
    //   [2,3,4] и [1,2,3], но [2,3,4] лучше,
    //   потому что максимальное отклонение
    //   (крайние значения разницы) меньше
    //   чем у других окон
    //   (1 против 2).
    //
    // Таким образом, критерий «наиболее близких»
    // опирается на минимизацию абсолютной разницы,
    // а бинарный поиск над начальным индексом окна
    // гарантирует, что мы найдём именно тот подряд
    // идущий фрагмент длины k, суммарно наиболее
    // «плотно» прилегающий к x.
    //
    // ---
    //
    // Сужение диапазона через бинарный поиск
    //
    // На каждой итерации:
    // 1. Вычисляем 
    //    midd = Math.floor(l + (r - l) / 2);
    //    — кандидат на старт окна.
    // 2. Сравниваем два края этого окна:
    //    - левый элемент  = arr[midd],
    //      расстояние до x = x − arr[midd];
    //    - правый элемент = arr[midd + k],
    //      расстояние до x = arr[midd + k] − x.
    // 3. Если левое расстояние больше правого,
    //    значит окно, начинающееся в midd,
    ///   слишком далеко слева, и лучше сдвинуться
    //    вправо:
    //      l = midd + 1
    //    Иначе окно либо уже оптимально, 
    //    либо нуждается в сдвиге влево:
    //      r = midd
    //
    // Таким образом мы отсекаем ту половину стартовых
    // позиций, где окно гарантированно
    // «хуже» по критерию близости к x.
    //
    // ---
    //
    // Итог:
    //
    // Алгоритм опирается на два ключевых соображения:
    // - абсолютные отклонения от x определяют,
    //   какие элементы ближе;
    // - при выборе окна длины k достаточно сравнивать
    //   только два крайних элемента, чтобы понять,
    ///  в какую сторону сместить окно.
    //
    // Так мы за O(log(n−k)) шагов находим оптимальные
    // границы без перебора всех возможных фрагментов.
    if (x - arr[midd] > arr[midd + k] - x) {

      // Если правая граница ближе к x,
      // значит окно должно сдвинуться вправо:
      // новая левая граница = midd + 1.
      //
      // В примере этот блок не выполнится,
      // поскольку 2 > 2 — ложь.
      l = midd + 1;
    } else {
      
      // Иначе окно сдвигается влево,
      // правая граница диапазона становится midd.
      //
      // В примере r = midd = 0.
      //
      // ---
      //
      // Почему используем r = mid, а не r = mid - 1
      // Используем r = mid, чтобы не исключить mid
      // как потенциальный ответ. 
      // При r = mid - 1 мы теряем проверенный элемент
      // и можем пропустить искомую границу.
      //
      // 1. Сохранение кандидата mid
      // Когда в ветке
      // «условие выполнено» cond(mid) == true,
      // mid сам по себе уже удовлетворяет условию
      // поиска.  
      // Если мы сделаем r = mid - 1, то исключим
      // этот индекс из дальнейших проверок
      // и потеряем реальный ответ.
      //
      // 2. Гарантия сужения и корректного завершения
      // - При r = mid интервал сужается с правой
      //   стороны, но mid остаётся в диапазоне [l, r].
      // - При l = mid + 1 интервал сужается с левой
      //   стороны, исключая все индексы ≤ mid.
      // - Так мы всегда уменьшаем размер интервала
      //   и обеспечиваем l == r как единственную
      //   точку завершения.
      //
      // 3. Пример пропуска границы
      // Допустим, у нас есть массив индексов 0…4,
      // и оптимальная граница — это 2.
      // 1. l = 0, r = 4 → mid = 2 → условие выполнено →
      //    - с `r = mid` → l = 0, r = 2
      //    - с `r = mid - 1` → l = 0, r = 1 (мы уже пропустили 2!)
      // 2. В первом случае 2 остаётся в диапазоне
      //    и будет возвращён. Во втором — ответ
      //    никогда не попадёт в проверку.
      //
      // 4. Когда уместен r = mid - 1
      // - В классическом шаблоне while (l <= r)
      //   вместе с досрочным break или return,
      //   когда вы точно знаете, что mid не годится 
      //   (например, вы ищете точное совпадение и
      //   `arr[mid] > target`).
      // - Тогда безопасно исключить mid и двигать
      //   правую границу в mid - 1.
      // - В классическом бинарном поиске
      //   с условием while (l <= r)
      //   замена r = mid - 1 на r = mid приведёт к
      //   бесконечному циклу, поскольку при l == r
      //   границы перестанут сужаться.
      //
      // Дополнительные советы по шаблонам
      // бинарного поиска:
      // - Для поиска "нижней границы" (lower_bound)
      //   используйте while (l < r), r = mid.
      // - Для поиска "верхней границы" (upper_bound)
      //   применяйте while (l < r), l = mid + 1,
      //   затем возвращайте l - 1.
      // - Для классического поиска элемента
      //   с возможностью break или return
      //   — while (l <= r), и в зависимости от
      //   сравнения 
      //   r = mid - 1 или l = mid + 1.
      r = midd;
    }
  }

  // В конце цикла l == r — оптимальный индекс начала окна.
  // Возвращаем k элементов, начиная с l.
  //
  // В примере: 
  // l = r = 0, возвращается arr.slice(0, 4) = [1, 2, 3, 4].
  return arr.slice(l, l + k);
}
