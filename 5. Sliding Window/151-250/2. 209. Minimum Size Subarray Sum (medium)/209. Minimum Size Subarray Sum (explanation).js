/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 * 
 * minSubArrayLen(target, nums) ищет
 * минимальную длину непрерывного
 * подмассива массива nums,
 * сумма которого >= target.
 * 
 * Пример для 
 * target = 7 и nums = [2, 3, 1, 2, 4, 3]
 * результат равен 2,
 * так как [4, 3] — самый короткий
 * подмассив с суммой >= 7.
 */
function minSubArrayLen(target, nums) {

  // result будет хранить минимальную
  // длину подходящего подмассива. 
  //
  // Инициализируем Infinity,
  // чтобы любое реальное значение длины
  // было меньше и могло перезаписать
  // Infinity при помощи
  // Math.min(result, r - l + 1)
  //
  // После поиска, если result
  // так и останется Infinity, значит
  // подходящего подмассива нет.
  let result = Infinity;

  // windowSum копит сумму элементов в
  // текущем скользящем окне между
  // индексами l и r.
  //
  // Изначально окно пустое, 
  // поэтому начальноe значение 0.
  let windowSum = 0;

  // l указывает на левую границу
  // текущего окна. Начинаем с 0.
  let l = 0;

  // r пробегает от начала до конца
  // массива, выступая правой границей
  // окна.
  //
  // На каждой итерации расширяем окно
  // вправо на один элемент.
  for (let r = 0; r < nums.length; r++) {

    // Добавляем текущий элемент nums[r]
    // в сумму окна.
    //
    // Пример 
    // для target=7 и nums = [2,3,1,2,4,3]:
    //  r=0 → windowSum = 0 + 2 = 2
    //  r=1 → windowSum = 2 + 3 = 5
    //  r=2 → windowSum = 5 + 1 = 6
    //  r=3 → windowSum = 6 + 2 = 8
    windowSum += nums[r];

    // После включения нового элемента проверяем,
    // выполняется ли условие windowSum >= target.
    //
    // Если условие выполняется,
    // значит сумма окна достигла или превысила
    // target. Пытаемся сжать окно слева,
    // чтобы найти максимально короткий подмассив
    // с суммой >= target.
    //
    // Для этого:
    //  1. Убираем из окна левый элемент nums[l],
    //     уменьшая сумму.
    //  2. Сдвигаем левую границу окна вправо.
    //
    // После каждого удаления nums[l] проверяем
    // условие заново. 
    while (windowSum >= target) {

      // Вычисляем длину текущего окна: (r - l + 1).
      //
      // Если она меньше ранее найденного result,
      // обновляем result.
      result = Math.min(result, r - l + 1);

      // Убираем из окна левый элемент nums[l],
      // уменьшая сумму.
      windowSum -= nums[l];

      // Сдвигаем левую границу окна вправо.
      l++;
    }

    // После выхода из while окно снова становится
    // «маленьким», сумма < target,
    // и мы продолжаем расширять окно дальше
    // по правому указателю r.
  }

  // По завершении цикла проверяем результат:
  // если result остался Infinity, значит
  // ни один подмассив не дал sum >= target,
  // возвращаем 0.
  //
  // Иначе возвращаем найденную минимальную длину.
  return result === Infinity ? 0 : result;
}
