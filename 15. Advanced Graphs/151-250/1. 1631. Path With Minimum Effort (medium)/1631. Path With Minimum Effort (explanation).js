/**
 * @param {number[][]} heights
 * @return {number}
 * 
 * minimumEffortPath вычисляет минимально возможное
 * значение наибольшего перепада высот (effort)
 * вдоль пути от верхнего левого угла матрицы до
 * нижнего правого угла, где путь допускает
 * перемещения только по четырём соседним клеткам
 * (вверх, вниз, влево, вправо).
 * 
 * Параметры: 
 *   heights — двумерный массив чисел (матрица) вида
 *   number[][], где heights[r][c] — высота в клетке
 *   с координатами (r,c).  
 * 
 * Возвращаемое значение:
 *   число (number) — минимально возможный максимум
 *   абсолютной разницы высот между соседними
 *   клетками вдоль выбранного пути.
 * 
 * Пример для:
 *   heights = [[1,2,2],[3,8,2],[5,3,5]]
 * Результат:
 *   2
 * Пояснение: 
 *   Маршрут [1,3,5,3,5] имеет максимальную
 *   абсолютную разность 2 в последовательных
 *   ячейках.
 *
 *   Это лучше, чем маршрут [1,2,2,2,5], где
 *   максимальная абсолютная разность составляет
 *   abs(2 - 5) = 3.
 */
function minimumEffortPath(heights) {

  // Массив направлений для обхода соседей:
  // вправо, влево, вниз, вверх.
  //
  // Каждая пара [dr, dc] — приращение индекса
  // строки и столбца.
  const directions = [

    // Сдвиг в столбце +1 (вправо)
    [0, 1],

    // Сдвиг в столбце -1 (влево)
    [0, -1],

    // Сдвиг в строке +1 (вниз)
    [1, 0],

    // Сдвиг в строке -1 (вверх)
    [-1, 0]
  ];

  // ROWS — количество строк в исходной матрице
  // heights.
  const ROWS = heights.length;

  // COLS — количество столбцов в первой строке
  // heights.
  //
  // Предполагается, что heights непустой и все
  // строки одного размера.
  const COLS = heights[0].length;

  // Инициализация матрицы dist того же размера,
  // что и heights.
  //
  // dist[r][c] будет хранить минимально возможный
  // максимум разницы высот (effort) для
  // достижения клетки (r,c) из (0,0)
  //
  // По умолчанию все значения заполнены
  // Infinity — это означает, что клетки ещё
  // недостижимы.
  const dist = Array.from(
    { length: ROWS },
    () => new Array(COLS).fill(Infinity)
  );

  // Установка начального состояния:
  // для стартовой клетки (0,0) усилие равно 0,
  // потому что мы уже там и не совершали
  // переходов.
  dist[0][0] = 0;

  // Создание минимальной приоритетной очереди
  // (min-heap), элементом в очереди будет объект,
  // содержащий поле diff — ключ приоритета,
  // и координаты r, c.
  //
  // Очередь упорядочивает элементы по возрастанию
  // diff, что позволяет извлекать текущую клетку
  // с наименьшим известным максимальным усилием
  // (поведение аналогично алгоритму Дейкстры,
  // но с метрикой max вместо суммы).
  const minHeap = new MinPriorityQueue((a) => a.diff);

  // Помещаем начальный узел в приоритетную
  // очередь: на старте diff = 0, r = 0, c = 0.
  //
  // Это запускает обход от верхнего левого угла.
  minHeap.enqueue({ diff: 0, r: 0, c: 0 });

  // Основной цикл: пока в очереди есть элементы,
  // извлекаем узел с наименьшим diff и пытаемся
  // расширить пути из него.
  while (!minHeap.isEmpty()) {

    // Извлечение объекта с минимальным ключом
    // diff из очереди и деструктуризация полей.
    //
    // Переменная diff отражает текущую
    // минимальную возможную максимальную
    // разницу на пути до (r, c).
    const { diff, r, c } = minHeap.dequeue();

    // Если извлечённая клетка — целевая
    // (нижний правый угол), возвращаем её diff
    // как ответ: это минимально возможный
    // максимальный перепад вдоль оптимального
    // пути.
    if (
      r === ROWS - 1
      && c === COLS - 1
    ) return diff;

    // Если для этой клетки в dist уже хранится
    // значение меньше текущего diff, это значит,
    // что мы ранее нашли более выгодный путь
    // к этой клетке и можем пропустить эту запись.
    if (dist[r][c] < diff) continue;

    // Перебираем все 4 соседних клетки
    for (const [dr, dc] of directions) {

      // nr, nc — индексы соседней клетки
      const nr = r + dr;
      const nc = c + dc;

      // Пропускаем соседа, если он выходит
      // за границы матрицы:
      // отрицательный индекс в любой
      // координате или индекс равен размеру.
      if (
        Math.min(nr, nc) < 0
        || nr === ROWS
        || nc === COLS
      ) continue;

      // newDiff — усилие при переходе в
      // соседнюю клетку через текущий путь:
      // это максимум между уже накопленным
      // diff (максимум перепадов вдоль пути
      // до (r,c)) и абсолютной разницей высот
      // между текущей и соседней клеткой,
      // потому что по определению усилие пути
      // — максимальная из локальных разниц.
      const newDiff = Math.max(
        diff,
        Math.abs(heights[r][c] - heights[nr][nc]),
      );

      // Если через текущий путь мы можем
      // добиться меньшего значения усилия
      // для (nr,nc), чем ранее найденное,
      // обновляем dist и добавляем соседнюю
      // клетку в кучу для последующей
      // обработки.
      if (newDiff < dist[nr][nc]) {

        // Обновляем минимально известный
        // diff для соседа
        dist[nr][nc] = newDiff;

        // Добавление обновлённого состояния
        // в приоритетную очередь.
        minHeap.enqueue({
          diff: newDiff,
          r: nr,
          c: nc
        });
      }
    }
  }

  // Если цикл завершился без достижения целевой
  // клетки, возвращаем 0.
  //
  // В корректных входных данных (связная матрица)
  // этот случай обычно недостижим.
  return 0;
}
