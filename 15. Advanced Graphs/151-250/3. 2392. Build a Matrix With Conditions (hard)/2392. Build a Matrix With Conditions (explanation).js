/**
 * @param {number} k
 * @param {number[][]} rowConditions
 * @param {number[][]} colConditions
 * @return {number[][]}
 * 
 * buildMatrix строит матрицу размера k×k,
 * в которой числа от 1 до k располагаются так,
 * чтобы выполнялись заданные порядковые
 * ограничения по строкам и по столбцам.
 * 
 * Порядковые ограничения — это пары чисел
 * [a, b], которые задают относительное
 * положение двух значений в итоговой матрице.
 * 
 * По строкам:
 * - Пара [a, b] означает: число a должно
 *   находиться в строке выше, чем число b.
 * 
 * - То есть строковый индекс a должен быть
 *   меньше строкового индекса b.
 * 
 * - Эти пары формируют ориентированный граф
 *   зависимостей между числами.
 *   Топологическая сортировка этого графа
 *   даёт порядок строк.
 * 
 * По столбцам:
 * - Пара [a, b] означает: число a должно
 *   находиться в столбце левее, чем число b.  
 * 
 * - То есть столбцовый индекс a должен быть
 *   меньше столбцового индекса b.  
 * 
 * - Эти пары формируют отдельный
 *   ориентированный граф зависимостей.
 *   Его топологическая сортировка даёт
 *   порядок столбцов.
 * 
 * Последствия и ограничения:
 * - Если в наборе пар есть цикл (например,
 *   [1,2], [2,3], [3,1]), то топологический
 *   порядок невозможен и функция возвращает
 *   пустой массив.
 * 
 * - Пары по строкам и по столбцам независимы
 *   друг от друга: допустимо, чтобы порядок
 *   по строкам и порядок по столбцам для
 *   одной и той же пары отличался, главное
 *   — каждая пара соблюдается в
 *   соответствующей координате.  
 * 
 * - После получения двух независимых
 *   порядков каждое число получает
 *   конкретную строку и столбец, и оно
 *   заносится в соответствующую клетку
 *   матрицы.  
 * 
 * Параметры:
 * - k — целое число, размер матрицы. Числа,
 *   которые надо разместить, это 1..k.  
 * 
 * - rowConditions — массив пар [a, b],
 *   задающих, что число a должно находиться
 *   в строке выше числа b (ориентированные
 *   ребра для порядка по строкам).  
 * 
 * - colConditions — массив пар [a, b],
 *   задающих, что число a должно находиться
 *   в столбце левее числа b (ориентированные
 *   ребра для порядка по столбцам).  
 * 
 * Возвращаемое значение: 
 *   Двумерный массив размера k × k с числами
 *   1..k, размещёнными по найденным порядкам
 *   (незаполненные ячейки содержат 0), либо
 *   пустой массив [] при невозможности
 *   удовлетворить ограничения.
 */
function buildMatrix(k, rowConditions, colConditions) {

  // Вызываем метод topoSort для получения
  // топологического порядка чисел по
  // ограничениям строк
  //
  // Возвращаемый rowOrder представляет
  // упорядоченный список чисел 1..k
  // (верх → низ), где порядок удовлетворяет
  // rowConditions, либо пустой массив при
  // обнаружении циклa
  const rowOrder = topoSort(k, rowConditions);

  // Если топологическая сортировка для
  // строк вернула пустой массив,
  // это означает, что условия по строкам
  // противоречивы (есть цикл) — возвращаем
  // пустую матрицу
  if (!rowOrder.length) return [];

  // Вычисляем топологический порядок по
  // ограничениям на столбцы.
  //
  // Возвращается массив длины k с числами
  // в порядке, определяющем слева → направо
  // столбцы.
  const colOrder = topoSort(k, colConditions);

  // Если топологическая сортировка вернула
  // пустой массив, значит в графе столбцов
  // есть цикл и задача неразрешима
  // — возвращаем пустой массив
  if (!colOrder.length) return [];

  // Создаём Map<num, index> вида
  // число → индекс строки в порядке
  // rowOrder:
  // - ключ — число (1..k),
  // - значение — индекс строки (0..k-1),
  //   в итоговой матрице
  const numToRow = new Map();
  rowOrder.forEach((num, i) => {
    numToRow.set(num, i);
  });


  // Создаём Map<num, index> вида
  // число → индекс строки в порядке
  // colOrder:
  // - ключ — число (1..k),
  // - значение — индекс столбца (0..k-1),
  //   в итоговой матрице
  const numToCol = new Map();
  colOrder.forEach((num, i) => {
    numToCol.set(num, i);
  });

  // Создаём итоговую матрицу размерности
  // k×k, заполненную нулями.
  //
  // В нее будут добавлены числа 1..k
  // по рассчитанным координатам
  const result = Array.from(
    { length: k },
    () => Array(k).fill(0)
  );

  // Проходим по всем числам от 1 до k
  // включительно, каждое число размещаем
  // в матрице по рассчитанным координатам
  for (let num = 1; num <= k; num++) {

    // Получаем индекс строки для текущего
    // числа из numToRow
    const r = numToRow.get(num);

    // Получаем индекс столбца для текущего
    // числа из numToCol
    const c = numToCol.get(num);

    // Записываем текущее число в позицию
    // (r, c) итоговой матрицы
    //
    // Предполагается, что r и c не
    // undefined, так как topoSort вернул
    // корректные порядки.
    result[r][c] = num;
  }

  // Возвращаем заполненную матрицу
  return result;
}

/**
 * @param {number} k
 * @param {number[][]} edges
 * @return {number[]}
 * 
 * topoSort выполняет топологическую сортировку
 * ориентированного графа с вершинами от 1 до k
 * и возвращает порядок вершин, совместимый с
 * заданными ориентациями рёбер.
 * 
 * Параметры
 * - k — целое число, количество вершин в графе.
 *   Вершины предполагаются пронумерованы
 *   от 1 до k.
 * 
 * - edges — массив пар [src, dst], каждое ребро
 *   задаёт ориентированную зависимость src → dst.
 */
function topoSort(k, edges) {

  // Создаём список смежности длиной k+1.
  //
  // Индексация вершин от 1 до k удобна для
  // прямого использования чисел. Индекс 0
  // не используется
  const adj = Array.from(
    { length: k + 1 },
    () => []
  );

  // Заполняем список смежности:
  // для каждого условия [src, dst] добавляем
  // dst в список соседей src (src должен
  // идти перед dst)
  edges.forEach(([src, dst]) => {
    adj[src].push(dst);
  });

  // Массив order будет содержать вершины
  // в порядке пост-обработки DFS.
  //
  // После завершения DFS он будет в обратном
  // топологическом порядке и его нужно будет
  // развернуть, чтобы получить топологическую
  // сортировку
  const order = [];

  // visitStatus хранит состояние каждой
  // вершины:
  //  0 — не посещена,
  //  1 — в стеке вызовов (в процессе),
  //  2 — полностью обработана
  const visitStatus = new Int32Array(k + 1);

  // Вложенная рекурсивная функция DFS,
  // возвращает true при успешной обработке,
  // false при обнаружении цикла
  function dfs(src) {

    // Если текущая вершина уже в стеке
    // вызовов, найден цикл, возвращаем
    // false
    if (visitStatus[src] === 1) return false;

    // Если вершина уже полностью
    // обработана, нет необходимости
    // обходить её повторно, возвращаем true
    if (visitStatus[src] === 2) return true;

    // Отмечаем вершину как находящуюся
    // в стеке вызовов
    visitStatus[src] = 1;

    // Проход по всем соседям (вершинам,
    // которые должны идти после src)
    for (const nei of adj[src]) {

      // Если при обходе соседа
      // обнаружен цикл
      // (dfs вернул false), немедленно
      // прекращаем выполение цикла и
      // возвращаем false
      if (!dfs(nei)) return false;
    }

    // Добавляем вершину в список в момент
    // возврата из рекурсии (пост-обход)
    order.push(src);

    // Отмечаем вершину как полностью
    // обработанную
    visitStatus[src] = 2;

    // Возвращаем true — обработка
    // завершена успешно
    return true;
  };

  // Запускаем DFS для каждой вершины, если
  // она ещё не посещена. Это гарантирует,
  // что учитываются все компоненты графа,
  // включая несвязные
  for (let src = 1; src <= k; src++) {

    // Если вершина уже посещена
    // (статус 1 или 2), пропускаем её
    if (visitStatus[src]) continue;

    // Если при DFS обнаружился цикл,
    // возвращаем пустой массив как
    // индикатор невозможности
    // топологической сортировки
    if (!dfs(src)) return [];
  }

  // Поскольку вершины добавлялись в порядке
  // пост-обработки DFS (в обратном
  // топологическом порядке), разворачиваем
  // его, чтобы получить корректный
  // топологический порядок, и возвращаем
  return order.reverse();
}
