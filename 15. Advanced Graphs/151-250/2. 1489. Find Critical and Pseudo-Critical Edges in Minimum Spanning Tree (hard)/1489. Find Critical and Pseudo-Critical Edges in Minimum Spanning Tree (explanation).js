// Назначение структуры данных DSU
//
// Структура данных DSU (Disjoint Set Union),
// или «система непересекающихся множеств»,
// предназначена для эффективного управления
// множествами элементов при их динамическом
// объединении и проверке взаимосвязей.
//
//
// Основные задачи DSU
//
// - Отслеживание принадлежности элемента к
//   определённому множеству.
// - Быстрое объединение двух множеств в одно.
// - Проверка, находятся ли два элемента
//   в одном множестве.
//
// Благодаря техникам «объединения по рангу»
// и «сжатия путей» операции find и union
// выполняются практически за амортизированное
// константное время.
//
//
// Типичные сценарии применения
//
// 1. Алгоритм Краскала (минимальное остовное дерево)
//    - Каждое ребро сортируется по весу,
//      затем по возрастанию добавляется в дерево,
//      если его концы принадлежат разным множествам.
//    - DSU гарантирует, что добавление не создаст цикл,
//      и быстро объединяет компоненты.
//
// 2. Объединение аккаунтов по общим email
//    - Как в вашем примере: каждый email связывается
//      с индексом аккаунта, а одинаковые email
//      вызывают union, что группирует все связанные
//      аккаунты вместе.
//
// 3. Задачи динамической связи (dynamic connectivity)
//    - Поддержка запросов «соединить два узла»
//      и «проверить, связаны ли узлы» в сетях и графах.
//
// 4. Объединение областей в алгоритмах обработки
//    изображений
//    - Например, при сегментации пикселей по цвету или
//      яркости соседние пиксели объединяются в компоненты.
//
// 5. Поиск компонент связанности в неориентированных
//    графах
//    - Быстрый подсчёт числа связных компонент
//      или проверка связи двух вершин.
//
//
// Преимущества DSU
//
// - Амортизированная сложность операций практически O(1)
//   для каждого find/union.
// - Простота реализации и небольшие накладные расходы
//   по памяти.
// - Универсальность: DSU легко адаптируется к различным
//   задачам и типам данных.
class DSU {

  // Конструктор DSU принимает количество элементов n
  // и инициализирует две структуры:
  // parent — массив, где parent[i] = i означает,
  //   что каждый элемент изначально — корень
  //   собственного дерева и указывает сам на себя
  // rank — массив, в котором каждый элемент
  //   представляет  «вес» компоненты (количество узлов)
  //   в компоненте rank[i], где i — корень.
  //   Начальное значение для всех элементов 1,
  //   потому что каждое множество в начале содержит
  //   ровно 1 элемент, и мы храним «размер» или «вес»
  //   этого множества для оптимального объединения.
  //
  // Пример для n = 5:
  // parent = [0,1,2,3,4],
  // rank = [1,1,1,1,1]
  constructor(n) {

    // Пример изменения parent для сценария:
    // parent = [0, 1, 2, 3, 4]: 
    // 1. Выполнили union(1, 0) → parent = [0, 0, 2, 3, 4]
    // 2. Выполнили union(2, 1) → parent = [0, 0, 0, 3, 4]
    //
    // 1. Исходное состояние  
    // parent = [0, 1, 2, 3, 4]
    //
    // Здесь для любого i:  
    // - parent[i] = i → каждый элемент сам себе родитель,
    //   значит у нас 5 отдельных деревьев:
    //
    // 0  1  2  3  4
    // 
    //
    // 2. После union(1, 0) → parent = [0, 0, 2, 3, 4]
    //
    // - parent[1] = 0 означает: в компоненте узел 1
    //   теперь «принадлежит» корню 0.  
    // - Остальные parent[2]=2, parent[3]=3, parent[4]=4
    //   не меняются, их деревья по-прежнему отдельные.
    //
    // Деревья визуально:
    //
    //    0
    //   /
    //  1
    //
    // 2  3  4
    // 
    //
    // 3. После union(2, 1) → parent = [0, 0, 0, 3, 4]
    //
    // - Сначала find(2) дал корень 2,
    //   find(1) дал корень 0, корни разные,
    //   значит привязываем 2 к 0:  
    //   parent[2] = 0  
    // - parent[0]=0, parent[1]=0 уже было.
    //
    // Итоговая структура:
    //
    //     0
    //    / \
    //   1   2
    //
    // 3  4
    //
    //   
    // Таким образом, массив parent хранит
    // для каждого индекса i ссылку на его
    // «родителя» в дереве.
    //
    // Если parent[i] = i, i — корень своего
    // дерева.
    //
    // После операций связывания (union) мы
    // меняем значение parent у корней меньших
    // деревьев, прикрепляя их к новым корням.
    this.parent = Array.from({ length: n }, (_, i) => i);

    // rank хранит размер (число узлов) в
    // дереве, корнем которого является данный
    // элемент.
    //
    //
    // 1. Исходное состояние  
    // parent = [0, 1, 2, 3, 4]  
    // rank   = [1, 1, 1, 1, 1]  
    //
    // - Каждый узел сам себе корень, потому
    //   размер каждого «дерева» равен 1.  
    // - Визуализация:
    // 
    //   0(1)  1(1)  2(1)  3(1)  4(1)
    // 
    //   Здесь в скобках указано значение rank.
    //
    //
    // 2. После union(1, 0)  
    // parent = [0, 0, 2, 3, 4]  
    // rank   = [2, 1, 1, 1, 1]  
    //
    // - Корни до объединения:
    //   find(1)=1, find(0)=0.  
    // - Поскольку оба дерева одинакового размера,
    //   мы присоединяем дерево с корнем 1
    //   к дереву с корнем 0.  
    // - Новый размер дерева с корнем 0 = 1 + 1 = 2,
    //   поэтому rank[0]=2.  
    //
    // Дерево:  
    //
    //    0(2)
    //   /
    //  1(1)
    //
    // 2(1)  3(1)  4(1)
    //
    //
    // 3. После union(2, 1)  
    // parent = [0, 0, 0, 3, 4]  
    // rank   = [3, 1, 1, 1, 1]  
    //
    // - Корни до объединения:
    //   find(2)=2, find(1)=0.  
    // - Дерево с корнем 2 (size=1) присоединяем
    //   к более крупному - корню 0 (size=2).  
    // - Новый размер дерева с корнем 0 = 2 + 1 = 3,
    //   поэтому rank[0]=3.  
    //
    // Дерево:  
    //
    //      0(3)
    //     / \
    //  1(1)  2(1)
    //
    // 3(1)  4(1)
    //
    //
    // Вывод  
    // - rank[i] показывает количество узлов
    //   в компоненте, где i — корень.  
    // - После каждого объединения размер (rank)
    //   у корня увеличивается на размер
    //   присоединяемого поддерева.  
    // - Не-корневые элементы сохраняют своё
    //   старое значение rank, но оно больше не
    //   учитывается при сравнении.
    this.rank = new Int32Array(n).fill(1);

    // Сохраняем текущее число компонент
    // связности (количество независимых
    // множеств).
    //
    // Изначально каждая вершина — отдельная
    // компонента
    this.n = n;
  }

  // Метод find находит «корень» (представителя)
  // множества, в которое входит заданный элемент,
  // и одновременно выполняет сжатие пути, чтобы
  // ускорить последующие операции.
  //
  //
  // Как работает find
  //
  // - Начинаем с переданного узла node.
  // - Пока node не является своим же родителем
  //   (parent[node] !== node), повторяем
  //   два шага:
  //   - Перенаправляем parent[node]
  //     на «дедушку»:
  //       this.parent[node] =
  //         this.parent[this.parent[node]];
  //     это уменьшает высоту дерева.
  //   - Сдвигаем node вверх по дереву:
  //       node = this.parent[node];
  //
  // - В конце цикла node указывает на корень
  //   своего множества.
  // - Возвращаем этот корневой индекс.
  //
  //
  // Почему path compression важен
  //
  // - Без сжатия пути дерево может вырасти в
  //   список, и поиск займет O(n).
  // - Сжатие пути делает деревья почти «плоскими»,
  //   что уменьшает амортизированную сложность
  //   операций find и union до почти константного
  //   уровня α(n) (обратная функция Аккермана).
  //
  //
  // Дополнительное применение
  //
  // - Метод find используется для проверки,
  //   принадлежат ли два элемента одному множеству:
  //   if (dsu.find(u) === dsu.find(v)) {
  //     // u и v уже соединены
  //   }
  //
  // - В комбинации с union позволяет решать задачи
  //   на компоненты связности, проверку циклов в
  //   графе, кластеризацию и многое другое.
  //
  //
  // Детальный пример работы метода find
  // с визуализацией деревьев
  //
  // 1. Исходное состояние  
  //    parent = [0, 1, 2, 3, 4]  
  //
  // Каждый узел сам себе родитель.  
  // Визуализация (каждый столбец — отдельное дерево):  
  // 
  // 0  1  2  3  4
  //
  //
  // 2. После union(1, 0)  
  // - Выполняем find(1) → 1, find(0) → 0  
  // - Поскольку ранги равны, делаем parent[1] = 0  
  // - Новое состояние: parent = [0, 0, 2, 3, 4]  
  //
  // Дерево компоненты {0,1}:
  //
  //    0
  //   /
  //  1
  //
  // Компоненты 2, 3, 4 остаются отдельными:
  // 
  // 2  3  4
  //
  //
  // 3. После union(2, 1) 
  // - find(2) → 2, find(1) →  
  //   - parent[1] = 0 → не корень
  //     → поднимаемся к parent[0] = 0  
  //   - возвращаем 0  
  // - Корни 2 и 0 различны → делаем parent[2] = 0  
  // - Новое состояние: parent = [0, 0, 0, 3, 4]  
  //
  // Дерево компоненты {0,1,2}:  
  // 
  //     0
  //    / \
  //   1   2
  //  
  // Отдельные компоненты:  
  // 
  // 3  4
  //
  //
  // 4. Первый вызов find(2)  
  // 1. Инициализируем node = 2  
  // 2. Проверяем parent[2] = 0 (не равен 2)
  //    → нужно подниматься выше  
  // 3. Выполняем path compression:  
  //    parent[2] = parent[parent[2]] = parent[0] = 0
  //      
  // 4. Переходим к node = 0  
  // 5. Теперь parent[0] = 0
  //    → останавливаемся и возвращаем 0  
  //
  // Во время этого прохода реальная структура
  // не изменилась (parent[2] уже был 0),
  // но гарантируется, что путь от 2 до корня
  // максимально краток.
  //
  //
  // 5. Последующий вызов find(2)  
  // - Сразу видим parent[2] = 0, поднимаемся
  //   к 0 и возвращаем его.  
  // - Одна итерация без сжатия пути - максимально
  //   быстрый сценарий.
  //
  //
  // Итог  
  // - После двух union-операций все узлы 1 и 2
  //   «подвесились» к корню 0.  
  // - Первый find(2) прошёл по пути 2 → 0,
  //   выполнил сжатие пути.  
  // - Следующий find(2) сразу возвращает 0 за
  //   одну проверку.
  find(node) {

    // Пока node не указывает на самого себя,
    // есть куда «взбираться» вверх по дереву
    while (this.parent[node] !== node) {

      // Сжатие пути: переподвешиваем node
      // к прародителю
      this.parent[node] = this.parent[this.parent[node]];

      // Переходим на уровень выше
      node = this.parent[node];
    }

    // Возвращаем полученный корень
    return node;
  }

  // Метод union(u, v) в структуре DSU выполняет
  // объединение двух множеств, которым
  // принадлежат элементы u и v. 
  //
  // Основная задача - связать эти два множества
  // так, чтобы все узлы из них оказались в одной
  // компоненте с общим корнем, и одновременно
  // выполняет сжатие пути, чтобы сохранить
  // деревья «плоскими» (за счёт рангов)
  // и минимизировать высоту получаемых деревьев
  // для ускорения последующих операций.
  //
  // Сжатие пути делает деревья почти «плоскими»,
  // что уменьшает амортизированную сложность
  // операций find и union до почти константного
  // уровня α(n) (обратная функция Аккермана)
  //
  // В результате метод union не только объединяет
  // два множества, но и поддерживает их
  // оптимальную структуру, сводящую высоту
  // деревьев к минимуму, что критично для быстрого
  // выполнения последующих find и union.
  union(u, v) {

    // Нахождение корней:
    // - Вызываем find(u) и find(v), чтобы
    //   определить корневые представители
    //   множеств — pu и pv.  
    // - В процессе поиска применяется
    //   сжатие пути: каждый посещённый узел
    //   сразу «переподвешивается» к корню.
    let pu = this.find(u);
    let pv = this.find(v);

    // Проверка на уже объединённость:
    // - Если корни совпадают (pu === pv), значит
    //   u и v уже в одном множестве, объединение
    //   не нужно.
    // - Попытка добавить ребро (u, v) создаст цикл.
    // - В этих случаях метод возвращает false и не
    //   выполняет дальнейших действий.
    // - Вы можете трактовать return false как
    //   сигнал «цикл найден».
    //
    // В общем случае это просто защита от лишнего
    // объединения, но в задаче поиска цикла - это
    // проверка на его появление.
    if (pu === pv) return false;

    // Выбор корня для присоединения:
    // - Сравниваем rank[pu] и rank[pv], то есть
    //   оценки «веса» или «высоты» двух деревьев
    // - Если дерево pv «тяжелее»
    //   (rank[pv] > rank[pu]), меняем их местами,
    //   чтобы гарантировать, что pu - всегда
    //   является коренем более «тяжёлого»
    //   множества.
    //
    //
    // Этот фрагмент - это оптимизация, которую
    // называют «union by size»
    // (или «union by rank», когда rank хранит
    // размер).
    // Его роль проста:
    //
    // Если дерево pv больше дерева pu, меняем их
    // местами
    //
    // 1. Это гарантирет, что
    //    - pu указывает на корень большего
    //      (тяжёлого) множества,
    //    - pv - на корень меньшего.
    //
    // 2. А дальше достаточно одной операции
    //    объединения:
    //
    //      parent[pv] = pu;
    //      rank[pu] += rank[pv];
    //
    // - и никакой дополнительной логики 
    //   и проверок «кто меньше, кто больше»
    //   уже не нужно.
    //
    // Без этого обмена пришлось бы либо
    // дублировать код:
    //
    //      if (rank[pv] > rank[pu]) {
    //        parent[pu] = pv;
    //        rank[pv] += rank[pu];
    //      } else {
    //        parent[pv] = pu;
    //        rank[pu] += rank[pv];
    //      }
    //
    // либо вводить дополнительные переменные
    // и ветвления. А так - единая, лаконичная
    // схема:
    // - один раз сравнили,
    // - при необходимости переприсвоили
    //   pu и pv,
    // - далее всегда «меньшее к большему».
    //
    // Это позволяет писать код короче,
    // и поддерживать деревья максимально
    // «плоскими», что критично для высокой
    // производительности DSU.
    if (this.rank[pv] > this.rank[pu]) {
      [pu, pv] = [pv, pu];
    }

    // Объединение деревьев:
    // - Делаем pu родителем pv:  
    //      this.parent[pv] = pu;  
    // - Увеличиваем ранг (или размер) корня
    //   pu на величину ранга pv, поскольку
    //   к множеству pu присоединяется всё
    //   дерево с корнем pv:
    //      this.rank[pu] += this.rank[pv];
    this.parent[pv] = pu;
    this.rank[pu] += this.rank[pv];

    // Поскольку два множества объединились
    // в одно, уменьшаем счётчик компонент
    // связности на единицу.
    this.n--;

    // Возврат результата:
    // - Если объединение прошло успешно,
    //   возвращаем true
    return true;
  }

  // Метод isConnected проверяет, все ли
  // элементы теперь принадлежат одной
  // компоненте связности.
  //
  // Возвращает true только тогда, когда
  // число компонент равно 1.
  isConnected() {

    // Простая проверка целочисленного
    // счётчика компонент: true если
    // ровно одна компонента, иначе
    // false.
    return this.n === 1;
  }
}

/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[][]}
 * 
 * findCriticalAndPseudoCriticalEdges 
 * находит и возвращает два списка рёбер
 * в неориентированном взвешенном графе:
 * - critical — индексы рёбер, которые
 *   обязательны во всех MST (удаление такого
 *   ребра увеличивает минимальный суммарный
 *   вес остова);
 * - pseudo-critical — индексы рёбер, которые
 *   могут входить в некоторый MST
 *   (при принудительном включении можно
 *   получить MST того же веса), но не
 *   обязательны во всех MST.
 * 
 * Параметры:
 * - n — целое число, количество вершин
 *   в графе (вершины пронумерованы
 *   от 0 до n-1).
 * - edges — массив рёбер, где каждое ребро
 *   представлено как массив [u, v, w], где
 *   - u — начальная вершина (целое),
 *   - v — конечная вершина (целое),
 *   - w — вес ребра (число).
 * 
 * Возвращаемое значение:
 * Функция возвращает массив из двух списков:
 * [critical, pseudo], где элементы списков
 * — исходные индексы рёбер из переданного
 * массива edges.
*/
function findCriticalAndPseudoCriticalEdges(n, edges) {

  // Цикл по всем рёбрам для записи их
  // исходного положения (индекса) в исходный
  // массив edges.
  //
  // Это нужно, потому что далее массивы
  // рёбер будут сортироваться и изменяться,
  // а нам нужно вернуть ответы в терминах
  // первоначальных индексов рёбер.
  for (let i = 0; i < edges.length; i++) {

    // Для текущего ребра edges[i]
    // (формат [u, v, w]) добавляем в
    // конец его исходный индекс i,
    // в результате элементы становятся
    // [u, v, w, originalIndex].
    edges[i].push(i);
  }

  // Сортируем массив рёбер по возрастанию
  // веса (третьему элементу каждого
  // подмассива).
  //
  // Это подготовка для алгоритма Крускала:
  // сортировка по весу позволяет брать ребра
  // в оптимальном порядке.
  edges.sort((a, b) => a[2] - b[2]);

  // Вложенная функция findMST вычисляет вес
  // минимального остовного дерева (MST).
  //
  // Параметры:
  // - ndx — индекс ребра, которое мы хотим
  //   либо принудительно включить, либо
  //   исключить
  // - include — булево: если true, то ребро
  //   с индексом ndx сначала обязательно
  //   добавляется, если false и ndx задан,
  //   то при обходе основного цикла это ребро
  //   пропускается (эффект исключения).
  function findMST(ndx, include) {

    // Создаётся экземпляр DSU (disjoint
    // set union, объединение
    // непересекающихся множеств) для
    // отслеживания компонент связности
    // при построении MST.
    const dsu = new DSU(n);

    // Инициализация суммарного веса
    // построенного дерева.
    let weight = 0;

    // Если include === true, то сначала
    // принудительно добавляем ребро
    // с индексом ndx:
    //
    // это обеспечивает проверку, может ли
    // данное ребро входить в какое-либо MST.
    if (include) {

      // При добавлении увеличиваем
      // суммарный вес на вес включаемого
      // ребра.
      weight += edges[ndx][2];

      // Объединяем две вершины, которые
      // соединяет это ребро, в DSU.
      dsu.union(edges[ndx][0], edges[ndx][1]);
    }

    // Этот цикл реализует основную часть
    // алгоритма Крускала: он последовательно
    // просматривает все рёбра, пытается
    // добавить каждое ребро в текущее
    // остовное дерево и накапливает
    // суммарный вес только тех рёбер,
    // которые действительно включены
    // (то есть которые соединяют разные
    // компоненты).
    // 
    // Переменная ndx используется для того,
    // чтобы в одном вызове функции пропустить
    // конкретное ребро — это позволяет
    // моделировать либо его исключение,
    // либо избегать дублированного добавления
    // после принудительного включения.
    //
    // Массив edges предварительно
    // отсортирован по весу. Благодаря этому
    // цикл добавляет сначала рёбра с
    // минимальным весом, что и обеспечивает
    // минимальность итоговой суммы в
    // соответствии с алгоритмом Крускала.
    //
    // Если рёбра не отсортированы, этот
    // цикл по сути построит некоторый остов,
    // но не гарантированно минимальный.
    for (let i = 0; i < edges.length; i++) {

      // Если текущий индекс совпадает с
      // заданным ndx, это ребро
      // пропускается и не рассматривается
      // в данном проходе.
      //
      // Причины пропуска:
      // - при моделировании исключения
      //   ребра ndx мы не хотим
      //   рассматривать его в выборе
      //   остова;
      // - при моделировании включения
      //   ребра ndx ранее оно уже было
      //   объединено в DSU, поэтому
      //   повторно его не добавляют.
      if (i === ndx) continue;

      // Вызывается операция union структуры
      // DSU для концов текущего ребра.
      // - dsu.union возвращает true тогда
      //   и только тогда, когда вершины были
      //   в разных компонентах и операция
      //   объединения действительно произошла.
      // - Возвращаемое false означает,
      //   что ребро образует цикл и не должно
      //   быть включено в остов.
      if (dsu.union(edges[i][0], edges[i][1])) {

        // Если union вернул true, ребро
        // добавлено в остов и его вес
        // аккумулируется в переменной
        // weight.
        weight += edges[i][2];
      }
    }

    // После прохода проверяем, связал ли DSU
    // все n вершин в одну компоненту.
    //
    // Если да — возвращаем суммарный вес
    // построенного остова.
    // Если нет — возвращаем Infinity,
    // означающее, что MST невозможен с данной
    // комбинацией включённых и исключённых
    // рёбер при конкретном вызове findMST
    return dsu.isConnected() ? weight : Infinity;
  };

  // Массив для хранения индексов
  // псевдокритических рёбер (edges, которые
  // могут присутствовать в некотором MST,
  // но не обязательны для всех MST).
  const pseudo = [];

  // Массив для хранения индексов критических
  // рёбер (ребра, удаление которых
  // увеличивает минимальный вес MST или
  // делает MST невозможным — они присутствуют
  // во всех MST).
  const critical = [];

  // Сначала вычисляем вес одного эталонного
  // MST без принудительных включений или
  // исключений.
  //
  // Передаём ndx = -1 и include = false:
  // это значит, что мы не исключаем и не
  // включаем никакое ребро заранее.
  //
  // Значение -1 передаётся в параметр ndx
  // и служит маркером «ни одно ребро не
  // выбрано/не исключено» для этого вызова
  // функции.
  //
  // Поскольку индексы ребёр всегда
  // неотрицательные (0, 1, 2, ...),
  // ndx = -1 никогда не равен ни одному i
  // при итерации, то есть ни одно ребро
  // не будет пропущено.
  //
  // Одновременно второй параметр
  // include = false говорит, что функция
  // не будет принудительно включать в
  // остов какое‑либо конкретное ребро
  // (ветка if (include) не выполняется),
  // и вызов просто выполняет обычный
  // алгоритм Крускала по всем ребрам.
  const mstWeight = findMST(-1, false);

  // Проходим по всем рёбрам и для каждого
  // проверяем два случая:
  // 1. если при полном исключении этого
  //    ребра MST становится дороже 
  //    (или невозможен) — оно критическое
  // 2. если при принудительном включении
  //    этого ребра можно получить MST того
  //    же минимального веса — оно
  //    псевдокритическое.
  for (let i = 0; i < edges.length; i++) {

    // Если при исключении ребра
    // (findMST(i, false)) минимальный
    // возможный вес увеличился
    // (или Infinity), то это ребро
    // обязательно в каждом MST и
    // является критическим.
    //
    // Записываем его исходный индекс
    // (edges[i][3]) в массив critical.
    if (mstWeight < findMST(i, false)) {
      critical.push(edges[i][3]);

      // Если при принудительном
      // включении ребра i вес MST
      // становится равен эталонному
      // mstWeight, то ребро
      // псевдокритическое (его можно
      // вставить в некоторый MST,
      // но оно не обязательно должно
      // присутствовать во всех MST)
      //
      // Записываем его исходный индекс
      // (edges[i][3]) в массив pseudo.      
    } else if (mstWeight === findMST(i, true)) {
      pseudo.push(edges[i][3]);
    }
  };

  // Возврат результата:
  // - первый элемент — массив критических
  //   ребер (исходные индексы),
  // - второй элемент — массив
  //   псевдокритических ребер
  //   (исходные индексы)
  return [critical, pseudo];
}
