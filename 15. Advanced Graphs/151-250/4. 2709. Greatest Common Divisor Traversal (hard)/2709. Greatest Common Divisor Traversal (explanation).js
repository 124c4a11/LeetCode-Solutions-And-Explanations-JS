// Назначение структуры данных DSU
//
// Структура данных DSU (Disjoint Set Union),
// или «система непересекающихся множеств»,
// предназначена для эффективного управления
// множествами элементов при их динамическом
// объединении и проверке взаимосвязей.
//
//
// Основные задачи DSU
//
// - Отслеживание принадлежности элемента к
//   определённому множеству.
// - Быстрое объединение двух множеств в одно.
// - Проверка, находятся ли два элемента
//   в одном множестве.
//
// Благодаря техникам «объединения по рангу»
// и «сжатия путей» операции find и union
// выполняются практически за амортизированное
// константное время.
//
//
// Типичные сценарии применения
//
// 1. Алгоритм Краскала (минимальное остовное дерево)
//    - Каждое ребро сортируется по весу,
//      затем по возрастанию добавляется в дерево,
//      если его концы принадлежат разным множествам.
//    - DSU гарантирует, что добавление не создаст цикл,
//      и быстро объединяет компоненты.
//
// 2. Объединение аккаунтов по общим email
//    - Как в вашем примере: каждый email связывается
//      с индексом аккаунта, а одинаковые email
//      вызывают union, что группирует все связанные
//      аккаунты вместе.
//
// 3. Задачи динамической связи (dynamic connectivity)
//    - Поддержка запросов «соединить два узла»
//      и «проверить, связаны ли узлы» в сетях и графах.
//
// 4. Объединение областей в алгоритмах обработки
//    изображений
//    - Например, при сегментации пикселей по цвету или
//      яркости соседние пиксели объединяются в компоненты.
//
// 5. Поиск компонент связанности в неориентированных
//    графах
//    - Быстрый подсчёт числа связных компонент
//      или проверка связи двух вершин.
//
//
// Преимущества DSU
//
// - Амортизированная сложность операций практически O(1)
//   для каждого find/union.
// - Простота реализации и небольшие накладные расходы
//   по памяти.
// - Универсальность: DSU легко адаптируется к различным
//   задачам и типам данных.
class DSU {

  // Конструктор DSU принимает количество элементов n
  // и инициализирует две структуры:
  // parent — массив, где parent[i] = i означает,
  //   что каждый элемент изначально — корень
  //   собственного дерева и указывает сам на себя
  // rank — массив, в котором каждый элемент
  //   представляет  «вес» компоненты (количество узлов)
  //   в компоненте rank[i], где i — корень.
  //   Начальное значение для всех элементов 1,
  //   потому что каждое множество в начале содержит
  //   ровно 1 элемент, и мы храним «размер» или «вес»
  //   этого множества для оптимального объединения.
  //
  // Пример для n = 5:
  // parent = [0,1,2,3,4],
  // rank = [1,1,1,1,1]
  constructor(n) {

    // Пример изменения parent для сценария:
    // parent = [0, 1, 2, 3, 4]: 
    // 1. Выполнили union(1, 0) → parent = [0, 0, 2, 3, 4]
    // 2. Выполнили union(2, 1) → parent = [0, 0, 0, 3, 4]
    //
    // 1. Исходное состояние  
    // parent = [0, 1, 2, 3, 4]
    //
    // Здесь для любого i:  
    // - parent[i] = i → каждый элемент сам себе родитель,
    //   значит у нас 5 отдельных деревьев:
    //
    // 0  1  2  3  4
    // 
    //
    // 2. После union(1, 0) → parent = [0, 0, 2, 3, 4]
    //
    // - parent[1] = 0 означает: в компоненте узел 1
    //   теперь «принадлежит» корню 0.  
    // - Остальные parent[2]=2, parent[3]=3, parent[4]=4
    //   не меняются, их деревья по-прежнему отдельные.
    //
    // Деревья визуально:
    //
    //    0
    //   /
    //  1
    //
    // 2  3  4
    // 
    //
    // 3. После union(2, 1) → parent = [0, 0, 0, 3, 4]
    //
    // - Сначала find(2) дал корень 2,
    //   find(1) дал корень 0, корни разные,
    //   значит привязываем 2 к 0:  
    //   parent[2] = 0  
    // - parent[0]=0, parent[1]=0 уже было.
    //
    // Итоговая структура:
    //
    //     0
    //    / \
    //   1   2
    //
    // 3  4
    //
    //   
    // Таким образом, массив parent хранит
    // для каждого индекса i ссылку на его
    // «родителя» в дереве.
    //
    // Если parent[i] = i, i — корень своего
    // дерева.
    //
    // После операций связывания (union) мы
    // меняем значение parent у корней меньших
    // деревьев, прикрепляя их к новым корням.
    this.parent = Array.from({ length: n }, (_, i) => i);

    // rank хранит размер (число узлов) в
    // дереве, корнем которого является данный
    // элемент.
    //
    //
    // 1. Исходное состояние  
    // parent = [0, 1, 2, 3, 4]  
    // rank   = [1, 1, 1, 1, 1]  
    //
    // - Каждый узел сам себе корень, потому
    //   размер каждого «дерева» равен 1.  
    // - Визуализация:
    // 
    //   0(1)  1(1)  2(1)  3(1)  4(1)
    // 
    //   Здесь в скобках указано значение rank.
    //
    //
    // 2. После union(1, 0)  
    // parent = [0, 0, 2, 3, 4]  
    // rank   = [2, 1, 1, 1, 1]  
    //
    // - Корни до объединения:
    //   find(1)=1, find(0)=0.  
    // - Поскольку оба дерева одинакового размера,
    //   мы присоединяем дерево с корнем 1
    //   к дереву с корнем 0.  
    // - Новый размер дерева с корнем 0 = 1 + 1 = 2,
    //   поэтому rank[0]=2.  
    //
    // Дерево:  
    //
    //    0(2)
    //   /
    //  1(1)
    //
    // 2(1)  3(1)  4(1)
    //
    //
    // 3. После union(2, 1)  
    // parent = [0, 0, 0, 3, 4]  
    // rank   = [3, 1, 1, 1, 1]  
    //
    // - Корни до объединения:
    //   find(2)=2, find(1)=0.  
    // - Дерево с корнем 2 (size=1) присоединяем
    //   к более крупному - корню 0 (size=2).  
    // - Новый размер дерева с корнем 0 = 2 + 1 = 3,
    //   поэтому rank[0]=3.  
    //
    // Дерево:  
    //
    //      0(3)
    //     / \
    //  1(1)  2(1)
    //
    // 3(1)  4(1)
    //
    //
    // Вывод  
    // - rank[i] показывает количество узлов
    //   в компоненте, где i — корень.  
    // - После каждого объединения размер (rank)
    //   у корня увеличивается на размер
    //   присоединяемого поддерева.  
    // - Не-корневые элементы сохраняют своё
    //   старое значение rank, но оно больше не
    //   учитывается при сравнении.
    this.rank = new Int32Array(n).fill(1);

    // Сохраняем текущее число компонент
    // связности (количество независимых
    // множеств).
    //
    // Изначально каждая вершина — отдельная
    // компонента
    this.n = n;
  }

  // Метод find находит «корень» (представителя)
  // множества, в которое входит заданный элемент,
  // и одновременно выполняет сжатие пути, чтобы
  // ускорить последующие операции.
  //
  //
  // Как работает find
  //
  // - Начинаем с переданного узла node.
  // - Пока node не является своим же родителем
  //   (parent[node] !== node), повторяем
  //   два шага:
  //   - Перенаправляем parent[node]
  //     на «дедушку»:
  //       this.parent[node] =
  //         this.parent[this.parent[node]];
  //     это уменьшает высоту дерева.
  //   - Сдвигаем node вверх по дереву:
  //       node = this.parent[node];
  //
  // - В конце цикла node указывает на корень
  //   своего множества.
  // - Возвращаем этот корневой индекс.
  //
  //
  // Почему path compression важен
  //
  // - Без сжатия пути дерево может вырасти в
  //   список, и поиск займет O(n).
  // - Сжатие пути делает деревья почти «плоскими»,
  //   что уменьшает амортизированную сложность
  //   операций find и union до почти константного
  //   уровня α(n) (обратная функция Аккермана).
  //
  //
  // Дополнительное применение
  //
  // - Метод find используется для проверки,
  //   принадлежат ли два элемента одному множеству:
  //   if (dsu.find(u) === dsu.find(v)) {
  //     // u и v уже соединены
  //   }
  //
  // - В комбинации с union позволяет решать задачи
  //   на компоненты связности, проверку циклов в
  //   графе, кластеризацию и многое другое.
  //
  //
  // Детальный пример работы метода find
  // с визуализацией деревьев
  //
  // 1. Исходное состояние  
  //    parent = [0, 1, 2, 3, 4]  
  //
  // Каждый узел сам себе родитель.  
  // Визуализация (каждый столбец — отдельное дерево):  
  // 
  // 0  1  2  3  4
  //
  //
  // 2. После union(1, 0)  
  // - Выполняем find(1) → 1, find(0) → 0  
  // - Поскольку ранги равны, делаем parent[1] = 0  
  // - Новое состояние: parent = [0, 0, 2, 3, 4]  
  //
  // Дерево компоненты {0,1}:
  //
  //    0
  //   /
  //  1
  //
  // Компоненты 2, 3, 4 остаются отдельными:
  // 
  // 2  3  4
  //
  //
  // 3. После union(2, 1) 
  // - find(2) → 2, find(1) →  
  //   - parent[1] = 0 → не корень
  //     → поднимаемся к parent[0] = 0  
  //   - возвращаем 0  
  // - Корни 2 и 0 различны → делаем parent[2] = 0  
  // - Новое состояние: parent = [0, 0, 0, 3, 4]  
  //
  // Дерево компоненты {0,1,2}:  
  // 
  //     0
  //    / \
  //   1   2
  //  
  // Отдельные компоненты:  
  // 
  // 3  4
  //
  //
  // 4. Первый вызов find(2)  
  // 1. Инициализируем node = 2  
  // 2. Проверяем parent[2] = 0 (не равен 2)
  //    → нужно подниматься выше  
  // 3. Выполняем path compression:  
  //    parent[2] = parent[parent[2]] = parent[0] = 0
  //      
  // 4. Переходим к node = 0  
  // 5. Теперь parent[0] = 0
  //    → останавливаемся и возвращаем 0  
  //
  // Во время этого прохода реальная структура
  // не изменилась (parent[2] уже был 0),
  // но гарантируется, что путь от 2 до корня
  // максимально краток.
  //
  //
  // 5. Последующий вызов find(2)  
  // - Сразу видим parent[2] = 0, поднимаемся
  //   к 0 и возвращаем его.  
  // - Одна итерация без сжатия пути - максимально
  //   быстрый сценарий.
  //
  //
  // Итог  
  // - После двух union-операций все узлы 1 и 2
  //   «подвесились» к корню 0.  
  // - Первый find(2) прошёл по пути 2 → 0,
  //   выполнил сжатие пути.  
  // - Следующий find(2) сразу возвращает 0 за
  //   одну проверку.
  find(node) {

    // Пока node не указывает на самого себя,
    // есть куда «взбираться» вверх по дереву
    while (this.parent[node] !== node) {

      // Сжатие пути: переподвешиваем node
      // к прародителю
      this.parent[node] = this.parent[this.parent[node]];

      // Переходим на уровень выше
      node = this.parent[node];
    }

    // Возвращаем полученный корень
    return node;
  }

  // Метод union(u, v) в структуре DSU выполняет
  // объединение двух множеств, которым
  // принадлежат элементы u и v. 
  //
  // Основная задача - связать эти два множества
  // так, чтобы все узлы из них оказались в одной
  // компоненте с общим корнем, и одновременно
  // выполняет сжатие пути, чтобы сохранить
  // деревья «плоскими» (за счёт рангов)
  // и минимизировать высоту получаемых деревьев
  // для ускорения последующих операций.
  //
  // Сжатие пути делает деревья почти «плоскими»,
  // что уменьшает амортизированную сложность
  // операций find и union до почти константного
  // уровня α(n) (обратная функция Аккермана)
  //
  // В результате метод union не только объединяет
  // два множества, но и поддерживает их
  // оптимальную структуру, сводящую высоту
  // деревьев к минимуму, что критично для быстрого
  // выполнения последующих find и union.
  union(u, v) {

    // Нахождение корней:
    // - Вызываем find(u) и find(v), чтобы
    //   определить корневые представители
    //   множеств — pu и pv.  
    // - В процессе поиска применяется
    //   сжатие пути: каждый посещённый узел
    //   сразу «переподвешивается» к корню.
    let pu = this.find(u);
    let pv = this.find(v);

    // Проверка на уже объединённость:
    // - Если корни совпадают (pu === pv), значит
    //   u и v уже в одном множестве, объединение
    //   не нужно.
    // - Попытка добавить ребро (u, v) создаст цикл.
    // - В этих случаях метод возвращает false и не
    //   выполняет дальнейших действий.
    // - Вы можете трактовать return false как
    //   сигнал «цикл найден».
    //
    // В общем случае это просто защита от лишнего
    // объединения, но в задаче поиска цикла - это
    // проверка на его появление.
    if (pu === pv) return false;

    // Выбор корня для присоединения:
    // - Сравниваем rank[pu] и rank[pv], то есть
    //   оценки «веса» или «высоты» двух деревьев
    // - Если дерево pv «тяжелее»
    //   (rank[pv] > rank[pu]), меняем их местами,
    //   чтобы гарантировать, что pu - всегда
    //   является коренем более «тяжёлого»
    //   множества.
    //
    //
    // Этот фрагмент - это оптимизация, которую
    // называют «union by size»
    // (или «union by rank», когда rank хранит
    // размер).
    // Его роль проста:
    //
    // Если дерево pv больше дерева pu, меняем их
    // местами
    //
    // 1. Это гарантирет, что
    //    - pu указывает на корень большего
    //      (тяжёлого) множества,
    //    - pv - на корень меньшего.
    //
    // 2. А дальше достаточно одной операции
    //    объединения:
    //
    //      parent[pv] = pu;
    //      rank[pu] += rank[pv];
    //
    // - и никакой дополнительной логики 
    //   и проверок «кто меньше, кто больше»
    //   уже не нужно.
    //
    // Без этого обмена пришлось бы либо
    // дублировать код:
    //
    //      if (rank[pv] > rank[pu]) {
    //        parent[pu] = pv;
    //        rank[pv] += rank[pu];
    //      } else {
    //        parent[pv] = pu;
    //        rank[pu] += rank[pv];
    //      }
    //
    // либо вводить дополнительные переменные
    // и ветвления. А так - единая, лаконичная
    // схема:
    // - один раз сравнили,
    // - при необходимости переприсвоили
    //   pu и pv,
    // - далее всегда «меньшее к большему».
    //
    // Это позволяет писать код короче,
    // и поддерживать деревья максимально
    // «плоскими», что критично для высокой
    // производительности DSU.
    if (this.rank[pv] > this.rank[pu]) {
      [pu, pv] = [pv, pu];
    }

    // Объединение деревьев:
    // - Делаем pu родителем pv:  
    //      this.parent[pv] = pu;  
    // - Увеличиваем ранг (или размер) корня
    //   pu на величину ранга pv, поскольку
    //   к множеству pu присоединяется всё
    //   дерево с корнем pv:
    //      this.rank[pu] += this.rank[pv];
    this.parent[pv] = pu;
    this.rank[pu] += this.rank[pv];

    // Поскольку два множества объединились
    // в одно, уменьшаем счётчик компонент
    // связности на единицу.
    this.n--;

    // Возврат результата:
    // - Если объединение прошло успешно,
    //   возвращаем true
    return true;
  }

  // Метод isConnected проверяет, все ли
  // элементы теперь принадлежат одной
  // компоненте связности.
  //
  // Возвращает true только тогда, когда
  // число компонент равно 1.
  isConnected() {

    // Простая проверка целочисленного
    // счётчика компонент: true если
    // ровно одна компонента, иначе
    // false.
    return this.n === 1;
  }
}

// Этот фрагмент строит таблицу простых
// делителей для всех чисел от 2 до 100000
// и одновременно находит простые числа в
// этом диапазоне методом, близким к решету
// Эратосфена.
// 
// 
// Что создаётся в начале
// 
// - Создаётся пустое множество primes,
//   которое изначально содержит кандидатов
//   на простые числа.  
// - Создаётся пустая Map numberToFactors,
//   где ключ — число от 2 до 100000,
//   а значение — массив его простых
//   делителей.  
// - В первом цикле for для каждого i
//   от 2 до 100000 в numberToFactors
//   создаётся запись с пустым массивом,
//   и i добавляется в множество primes.
// 
// 
// Главный алгоритм и логика
// 
// - Второй цикл for перебирает i
//   от 2 до 100000 как потенциальные простые
//   числа.  
// - Если i уже удалён из множества primes
//   (то есть помечен как составное), итерация
//   пропускается.  
// - Когда i остаётся в primes, алгоритм считает
//   i простым и выполняет две вещи:
//   - Добавляет i в список простых множителей
//     для самого числа
//     i: numberToFactors.get(i).push(i).  
//   - Перебирает все кратные числа i (j * i),
//     начиная с j = 2, пока j * i ≤ 100000,
//     и для каждого кратного:
//     - добавляет i в массив его простых
//       делителей:
//       numberToFactors.get(i * j).push(i),  
//     - удаляет этот кратный из множества
//       primes, помечая его как составное:
//       primes.delete(i * j).
// 
// 
// Итоговые структуры после выполнения
// 
// - numberToFactors — Map, где для каждого
//   числа n (2..100000) хранится массив
//   всех найденных простых делителей
//   n (в порядке обнаружения). Для простого
//   числа p массив будет содержать p как
//   единственный элемент.  
// - primes — множество, содержащее только
//   те числа из диапазона 2..100000, которые
//   не были помечены как кратные каких-либо
//   меньших простых, то есть фактически
//   простые числа.
// 
// 
// Сложность и особенности
// 
// - Временная сложность близка к O(n log log n)
//   для нахождения простых (как у решета) плюс
//   дополнительная работа по добавлению делителей
//   в массивы: работа с каждым кратным включает
//   push и delete.  
// - Память: хранится массив делителей для каждого
//   числа в диапазоне, что может занимать
//   значительный объём при n = 100000.  
// - Массивы делителей содержат только простые
//   множители (не включаются составные делители
//   и не дублируются одни и те же простые
//   множители для одного числа в этой реализации).
// 
// 
// Небольшой пример работы
// 
// - Для диапазона до 10 результат будет примерно:
//   - primes = {2,3,5,7}  
//   - numberToFactors:  
//     - 2 → [2]  
//     - 3 → [3]  
//     - 4 → [2]  
//     - 5 → [5]  
//     - 6 → [2,3]  
//     - 7 → [7]  
//     - 8 → [2]  
//     - 9 → [3]  
//     - 10 → [2,5]
//
// ----
//
// Создаём пустое множество primes, которое будет
// использоваться как "таблица" кандидатов на
// простые числа.
//
// Изначально мы будем помещать сюда все числа
// от 2 до 100000 и затем удалять из него
// составные числа.
//
// Составное число — натуральное число больше 1,
// у которого есть делитель, отличный от 1 и
// самого числа. Другими словами, его можно
// представить как произведение двух натуральных
// чисел больше 1
// (например, 4 = 2·2, 6 = 2·3, 12 = 3·4).
//
// Числа, у которых таких делителей нет,
// называются простыми.
//
// Число 1 не является ни простым, ни составным.
const primes = new Set();

// Создаём пустую карту numberToFactors, где
// ключ — целое число,
// значение — массив простых делителей этого
// числа.
//
// Это предварительно вычисляемая таблица для
// быстрого доступа к простым множителям
// любого числа в диапазоне.
const numberToFactors = new Map();

// Инициализация:
// для каждого i от 2 до 100000 создаём
// запись в numberToFactors с пустым массивом,
// и добавляем i во множество primes как
// предварительный кандидат на простое число.
//
// Почему цикл начинается с 2:
// - В математике простые числа определяются
//   как натуральные числа больше 1, поэтому
//   минимальное возможное простое число — 2.  
// - Числа 0 и 1 не имеют смысла для задачи
//   поиска простых делителей: 0 не
//   рассматривают как натуральный кандидат,
//   а 1 не является ни простым, ни составным
//   и не имеет простых множителей.  
// - Для заполнения отображения numberToFactors
//   и множества primes нужно обходить именно
//   те числа, у которых могут быть простые
//   делители, то есть от 2 и далее.  
// - Алгоритм похож на решето Эратосфена,
//   которое по определению стартует с первого
//   простого 2 и помечает его кратные, поэтому
//   логично начинать цикл с i = 2.
for (let i = 2; i <= 100000; i++) {

  // Для каждого числа i создаём в Map
  // пустой массив — в него позже добавим
  // простые делители.
  numberToFactors.set(i, []);

  // Помещаем i во множество primes.
  // На этом этапе считаем все числа
  // потенциально простыми.
  primes.add(i);
}

// Заполнение таблицы простых делителей и
// фильтрация составных чисел из множества
// primes.
//
// Это имитация простого варианта решета
// Эратосфена: для каждого обнаруженного
// простого i мы отмечаем его как делитель
// всех кратных ему чисел.
for (let i = 2; i <= 100000; i++) {

  // Если i был удалён из primes ранее,
  // значит i — составное и мы
  // пропускаем его.
  if (!primes.has(i)) continue;

  // Число i простое.
  //
  // Простое число является делителем
  // самого себя, поэтому добавляем i
  // в список его простых делителей.
  numberToFactors.get(i).push(i)

  // Проходим по кратным i начиная
  // с 2*i (j = 2) i: 2*i, 3*i,
  // чтобы:
  // 1. добавить i в список простых
  //    делителей числа i * j,
  // 2. пометить i * j как составное,
  //    удалив его из множества primes.
  //
  // Используем выражение j * i, чтобы
  // перебрать все кратные числа для
  // текущего простого i.
  // - Выражение j * i даёт
  //   последовательные кратные числа
  //   i: 2*i, 3*i, 4*i и так далее.
  // - Начало j с 2 пропускает само
  //   число i (1 * i), потому что для
  //   пометки составных чисел нас
  //   интересуют только кратные больше
  //   самого i.
  // - Условие j * i <= 100000
  //   гарантирует, что мы не выйдем
  //   за предел заранее заданного
  //   диапазона и не попробуем
  //   обратиться к несуществующим
  //   записям в numberToFactors.
  // - Такой перебор обеспечивает, что
  //   каждый составной, имеющий
  //   простой делитель i, получит i в
  //   списке своих простых множителей.
  // - Умножение предпочтительнее
  //   сложения в этой конструкци,
  //   потому что явно выражает
  //   кратность и даёт простой способ
  //   проверить границу диапазона.
  for (let j = 2; j * i <= 100000; j++) {

    // Для кратного (i * j)
    // добавляем i как один из его
    // простых делителей.
    //
    // Используем i * j, потому что
    // это выражение даёт конкретное
    // кратное числа i 
    // (2*i, 3*i, 4*i и т.д.).
    // - numberToFactors хранит
    //   список простых делителей для
    //   каждого числа, поэтому нужно
    //   добавить i именно в запись
    //   числа, которое делится на i,
    //   то есть в запись для i * j.
    // - j перебирает множители, а i
    //   фиксирован в текущей итерации
    //   внешнего цикла. Произведение
    //   i * j явно указывает, для
    //   какого числа добавлять
    //   множитель i.
    // - Начало j с 2 обеспечивает,
    //   что мы не добавляем i в список
    //   для самого i через 1 * i,
    //   а обрабатываем только кратные,
    //   отличные от самого простого.
    // - Порядок умножения не важен
    //   математически (i * j === j * i),
    //   но запись i * j читабельнее в
    //   контексте двойного цикла,
    //   где внешний цикл — i,
    //   а внутренний — j.
    // - Это также позволяет легко
    //   проверить границу диапазона
    //   через условие i * j <= 100000 и
    //   безопасно обращаться к
    //   numberToFactors.get(i * j).
    numberToFactors.get(i * j).push(i)

    // Так как i * j имеет делитель i,
    // это составное число — удаляем его
    // из primes.
    primes.delete(i * j)
  }
}

/**
 * @param {number[]} nums
 * @return {boolean}
 * 
 * canTraverseAllPairsй проверяет,
 * можно ли связать все числа из
 * переданного массива так, чтобы
 * каждую пару чисел можно было пройти
 * по пути, переходя только между
 * числами, у которых есть общий
 * простой множитель.
 * 
 * Функция использует предвычисленные
 * простые делители для проверки,
 * образуют ли все числа одну связную
 * компоненту, где ребро между числами
 * существует, если они имеют общий
 * простой делитель (>1).
 * 
 * Параметры:
 *   nums — массив чисел 
 * 
 * Возвращает:
 *   true если все числа образуют одно
 *   связное множество через отношения
 *   «имеют общий простой множитель»,
 *   иначе false.
 */
function canTraverseAllPairs(nums) {

  // 1. убрать дубликаты (несколько
  //    одинаковых чисел не дают новых
  //    вершин),
  // 2. ускорить проверки наличия
  //    конкретного числа
  const numSet = new Set(nums);

  // Специальный случай:
  // если есть более одного элемента
  // и среди них присутствует 1, то 1
  // не имеет делителей >1, а значит
  // 1 не будет соединён с другими
  // числами через простые делители
  // - нельзя соединить все
  // пары, возвращаем false
  if (
    nums.length > 1
    && numSet.has(1)
  ) return false;

  // Если после удаления дубликатов
  // остался один уникальный элемент,
  // то тривиально "все пары" связаны,
  // возвращаем true.
  if (numSet.size === 1) return true;

  // Создаём структуру
  // Disjoint Set Union (DSU) размера
  // равного количеству уникальных
  // чисел.
  //
  // DSU будет хранить компоненты
  // связности по принципу: два числа
  // оказываются в одной компоненте,
  // если есть путь через общие
  // простые множители.
  const dsu = new DSU(numSet.size);

  // Map от простого числа к индексу
  // первого встретившегося числа из
  // numSet, содержащего этот простой
  // делитель.
  //
  // Когда мы встречаем тот же простой
  // в другом числе, мы объединяем их
  // индексы в DSU.
  const primeToNdx = new Map();

  // Индекс текущего уникального числа
  // в итерации.
  //
  // Используется как идентификатор
  // вершины в DSU.
  let i = 0;

  // Итерация по каждому уникальному
  // числу из numSet (порядок итерации
  // определяется порядком Set)
  for (const num of numSet) {

    // Для каждого простого делителя
    // текущего числа получаем набор
    // простых делителей заранее
    // вычисленный в numberToFactors
    // и проходим по ним
    for (const prime of numberToFactors.get(num)) {

      // Если этот простой делитель
      // уже встречался в
      // предыдущем числе, то
      // объединяем текущий индекс i
      // с индексом того предыдущего
      // числа:
      // все числа, содержащие один
      // и тот же простой множитель,
      // должны попасть в одну
      // компоненту.
      if (primeToNdx.has(prime)) {
        dsu.union(primeToNdx.get(prime), i);
      } else {

        // Если простой ещё не
        // встречался, запоминаем
        // индекс текущего числа
        // как репрезентативный
        // для этого простого.
        primeToNdx.set(prime, i);
      }
    }

    // Переходим к индексу следующего
    // уникального числа
    i++
  }

  // После обработки всех чисел проверяем,
  // образуют ли они одну общую компоненту
  // в DSU.
  //
  // Если да — можно пройти между всеми
  // парами, иначе — нельзя.
  return dsu.isConnected();
}
