/**
 * @param {string} s
 * @return {string}
 * 
 * replaceDigits и строит и возвращает новую строку, в
 * которой символы на чётных индексах (0, 2, 4, …)
 * (буквы) копируются без изменений, а символы на
 * нечётных индексах (1, 3, 5, …) (цифры) заменяются
 * на символ, полученный сдвигом кодовой точки
 * предыдущего символа на значение этой цифры.
 * 
 * То есть для каждого нечётного i результат содержит
 * символ с кодовой точкой
 * s.codePointAt(i - 1) + Number(s[i]).
 * 
 * Параметры:
 * - s — строка, содержащая чередующиеся буквы и цифры в
 *   нужных позициях (буква на чётной позиции, цифра на
 *   следующей нечётной).
 * 
 *   Индексация — нулевая (первый символ имеет индекс 0).
 * 
 * 
 * Пример для:
 *   s = "a1b2c3d4e"
 * Результат:
 *   "abbdcfdhe"
 * Пояснение:
 *   Цифры заменяются следующим образом:
 *   - s[1] → shift('a', 1) = 'b' 
 *   - s[3] → shift('b', 2) = 'd'
 *   - s[5] → shift('c', 3) = 'f'
 *   - s[7] → shift('d', 4) = 'h'
 */
function replaceDigits(s) {

  // Инициализация пустого массива result для накопления
  // отдельных символов результирующей строки.
  //
  // Массив выбран вместо конкатенации строк, чтобы избежать
  // квадратичной сложности при многократной конкатенации
  // строк в цикле.
  //
  // Многократная конкатенация строк в цикле обычно имеет
  // худшую практическую производительность и может вести к
  // O(n^2) по времени в худшем случае, тогда как сбор в
  // массив с последующим join даёт линейную сложность O(n)
  // и обычно быстрее и экономичнее по памяти при больших
  // объёмах данных.
  const result = [];

  // Запускаем цикл for для итерации по всем индексам строки
  // s.
  for (let i = 0; i < s.length; i++) {

    // Проверяем, является ли текущий индекс нечётным.
    // 
    // Оператор % возвращает остаток от деления.
    // 
    // Для нечётных индексов i % 2 === 1.
    // 
    // В JavaScript значение 1 интерпретируется как true в
    // условном выражении.
    //
    // Если индекс нечетный (i % 2 === 1), значит по условию
    // задачи s[i] содержит цифру
    if (i % 2) {

      // Вычисляет новый символ, полученный сдвигом кодовой
      // точки предыдущего символа на числовое значение
      // текущего символа, и добавляет этот символ в массив
      // result:
      // 1. s.codePointAt(i - 1) — получает числовую кодовую
      //    точку символа, стоящего непосредственно перед
      //    текущим.
      // 
      // 2. Number(s[i]) — преобразует символ в позиции i в
      //    число. Ожидается, что s[i] — символ-цифра
      //    ('0'..'9').
      // 
      // 3. Складываем кодовую точку предыдущего символа и
      //    числовое значение цифры, получаем новую кодовую
      //    точку.
      // 
      // 4. String.fromCodePoint(...) — создаёт строковый
      //    символ по полученной кодовой точке. Это
      //    позволяет получить символ Unicode,
      //    соответствующий сумме кодовой точки и цифры.
      // 
      // 5. result.push(...) — добавляет полученный символ
      //    в конец массива result.
      result.push(String.fromCodePoint(s.codePointAt(i - 1) + Number(s[i])));
    } else {

      // Блок выполняется для чётных индексов (включая 0).
      // 
      // Ожидается, что на чётных позициях находятся буквы,
      // которые нужно оставить без изменений.
      // 
      // Добавляем исходный символ s[i] в массив result.
      result.push(s[i]);
    }
  }

  // После завершения цикла объединяем все элементы массива
  // result в одну строку.
  // 
  // Метод join('') соединяет элементы без разделителя,
  // формируя итоговую строку.
  // 
  // Возвращаем полученную строку как результат работы
  // функции.
  return result.join('');
}
