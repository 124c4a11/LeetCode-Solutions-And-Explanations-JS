/**
 * @param {string} s
 * @return {string}
 * 
 * maximumOddBinaryNumber формирует из битов входной двоичной
 * строки максимально возможное по значению нечётное двоичное
 * число той же длины, переставляя биты (то есть используя
 * ровно то же количество 1 и 0, что и в исходной строке s).
 * 
 * Чтобы найти максимальное нечётное двоичное число, нужно
 * понять два ключевых момента:
 * - Что делает двоичное число нечётным? Двоичное число
 *   нечётно, когда его наименее значимый бит (правый крайний)
 *   равен '1' — в конце обязательно должна стоять '1'.
 * 
 * - Что делает двоичное число больше? В двоичной записи биты
 *   слева имеют больший вес. Каждая позиция бита
 *   соответствует степени двойки, при этом самые левые биты
 *   соответствуют наибольшим степеням. Поэтому, чтобы
 *   максимизировать двоичное число, нужно размещать '1' как
 *   можно левее.
 * 
 * 
 * Пример для:
 *   s = "0101"
 * Результат:
 *   "1001"
 * Пояснение:
 *   Одна из '1' должна находиться в крайней правой позиции.
 *   Максимальное число, которое можно составить из оставшихся
 *   цифр — "100". Поэтому ответ — "1001".
 */
function maximumOddBinaryNumber(s) {

  // Подсчёт количества символов '1' в строке:
  // 1. s.replace(/0/g, '') создаёт новую строку, в которой
  //    удалены все символы '0' (регулярное выражение
  //    /0/g — глобальный поиск всех нулей); 
  //
  // 2. s.replace(...).length — длина строки после удаления
  //    нулей. Полученная длина даёт число удалённых символов,
  //    то есть исходное количество '1'.
  // 
  // Временная сложность этого подхода O(n), память — O(n)
  // из‑за создания новой строки.
  const onesCnt = s.replace(/0/g, '').length;

  // Количество нулей в строке вычисляется как разница между
  // общей длиной s и количеством единиц.
  // 
  // Это эквивалентно подсчёту '0' напрямую, но экономит ещё
  // один проход по строке, используя уже известное значение
  // onesCnt.
  const zerosCnt = s.length - onesCnt;

  // Формирование и возврат результирующей строки,
  // представляющей максимальное нечётное двоичное число,
  // которое можно получить перестановкой битов исходной
  // строки при условии, что результат должен быть нечётным.
  // 
  // Логика:
  // 1. '1'.repeat(onesCnt - 1) — создаём блок единиц,
  //    который будет стоять в начале. Оставляем одну
  //    единицу для конца, чтобы обеспечить нечётность
  //    (последний бит = '1').
  // 
  // 2. '0'.repeat(zerosCnt) — затем размещаем все нули
  //    подряд, чтобы уменьшить вес младших разрядов и тем
  //    самым сделать число максимально большим при
  //    фиксированном количестве единиц и требовании
  //    нечётности.
  // 
  // 3. '+ '1'' — добавляем одну единицу в конец строки,
  //    чтобы число стало нечётным.
  return '1'.repeat(onesCnt - 1) + '0'.repeat(zerosCnt) + '1';
}
