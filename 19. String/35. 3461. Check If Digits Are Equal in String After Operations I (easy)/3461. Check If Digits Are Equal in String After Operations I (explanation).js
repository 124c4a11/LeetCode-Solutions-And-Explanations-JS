/**
 * @param {string} s
 * @return {boolean}
 * 
 * hasSameDigits принимает строку s, состоящую из цифр.
 * 
 * Для каждой пары соседних цифр в s, начиная с первой,
 * вычисляется новая цифра как сумма этих двух цифр по
 * модулю 10.
 * 
 * Затем формируется последовательность новых цифр в
 * порядке их вычисления. Операция повторяется до тех пор,
 * пока длина последовательности не станет равной двум.
 * 
 * Результат
 *   true, если окончательные две цифры в s одинаковы.
 *   В противном случае верните false.
 * 
 * 
 * Пример для:
 *   s = "3902"
 * Результат:
 *   true
 * Пояснение:
 *   Изначально s = "3902"
 *  
 *   Первая операция:
 *     (s[0] + s[1]) % 10 = (3 + 9) % 10 = 2
 *     (s[1] + s[2]) % 10 = (9 + 0) % 10 = 9
 *     (s[2] + s[3]) % 10 = (0 + 2) % 10 = 2
 *     s становится "292"
 * 
 *   Вторая операция:
 *     (s[0] + s[1]) % 10 = (2 + 9) % 10 = 1
 *     (s[1] + s[2]) % 10 = (9 + 2) % 10 = 1
 *     s становится "11"
 *   
 *   Поскольку цифры в "11" одинаковы, результат — true.
 */
function hasSameDigits(s) {

  // Создаёт новый массив nums из итерируемого объекта s
  // (строки).
  //
  // Для каждого символа строки вызывается
  // функция-преобразователь, которая приводит символ к
  // числу через Number. Это требуется для того, чтобы не
  // использовать приведение к числу на каждой итерации в
  // последующих циклах.
  //
  // Результат: массив чисел той же длины, что и строка s.
  const nums = Array.from(s, (char) => Number(char));

  // Внешний цикл управляет текущей "длиной"
  // рассматриваемой части массива.
  // 
  // currLen инициализируется как nums.length и уменьшается
  // на единицу в каждой итерации до значения 2.
  // 
  // Это означает, что мы последовательно выполняем
  // уменьшение длины рассматриваемой части массива, пока
  // длина этой части больше значения 2.
  for (let currLen = nums.length; currLen > 2; currLen--) {

    // Внутренний цикл проходит по индексам от 0 до
    // currLen-1
    // 
    // На каждой итерации обновляется элемент nums[i] на
    // основе текущего значения nums[i] и соседнего
    // nums[i+1].
    // 
    // Важно:
    // Обновление происходит "на месте" — то есть
    // последующие итерации внутреннего цикла используют
    // уже обновлённые значения nums[i].
    // 
    // Диапазон i < currLen - 1 гарантирует, что обращение
    // к nums[i + 1] всегда в пределах рассматриваемой
    // части массива.
    for (let i = 0; i < currLen - 1; i++) {

      // Операция суммирует соседние элементы и берёт
      // остаток по модулю 10, то есть сохраняет только
      // последнюю цифру в диапазоне 0–9.
      nums[i] = (nums[i] + nums[i + 1]) % 10;
    }
  }

  // После завершения вложенных циклов первые два элемента
  // массива nums (nums[0] и nums[1]) содержат итоговые
  // значения, полученные в результате последовательного
  // суммирования соседних цифр по модулю 10.
  // 
  // Функция возвращает true, если значения совпадают,
  // иначе false.
  return nums[0] === nums[1];
}
