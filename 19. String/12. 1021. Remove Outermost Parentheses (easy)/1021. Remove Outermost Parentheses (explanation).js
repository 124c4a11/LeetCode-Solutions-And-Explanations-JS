/**
 * @param {string} s
 * @return {string}
 * 
 * removeOuterParentheses удаляет внешние
 * (самые внешние) скобки у каждой примитивной
 * корректной группы скобок в строке и возвращает
 * новую строку без этих внешних скобок.
 * 
 * Параметр: 
 * - s - строка, содержащая только символы '(' и ')'
 *   и представляющую корректную (сбалансированную)
 *   последовательность скобок.
 * 
 * 
 * Пример для:
 *   s = "(()())(())"
 * Результат:
 *   "()()()"
 * Пояснение:
 *   Входная строка "(()())(())" разбивается на
 *   примитивы "(()())" + "(())".
 *  
 *   После удаления внешних скобок каждой части
 *   получаем "()()" + "()" = "()()()".
 */
function removeOuterParentheses(s) {

  // Создаём пустой массив result для накопления
  // символов результата.
  // 
  // Используем массив вместо конкатенации строк
  // для лучшей производительности при
  // множественных добавлениях (push)
  // 
  // Затем объединим в строку через join.
  const result = [];

  // Переменная depth хранит текущую глубину
  // вложенности скобок при проходе по строке.
  // 
  // Семантика: 
  // depth = количество открытых '(', которые
  // ещё не были закрыты. 
  //
  // На входе depth = 0 (мы вне любой пары скобок).
  //
  // depth увеличивается при встрече '(' и
  // уменьшается при ')'.
  let depth = 0;

  // Итерация по каждому символу входной строки s
  // в порядке слева направо.
  for (const char of s) {

    // Если текущий символ — открывающая скобка,
    // сначала увеличиваем глубину.
    // 
    // Важно:
    // Увеличение depth происходит до проверки
    // добавления символа в результат, чтобы
    // отличить внешнюю открывающую скобку (которая
    // не должна попасть в результат) от внутренней
    // (которая должна).
    if (char === '(') depth++;

    // Добавляем текущий символ в result только
    // если глубина после возможного увеличения
    // больше 1.
    // 
    // Это условие гарантирует, что внешние скобки
    // (те, которые соответствуют depth === 1 при
    // открытии или закрытии) не попадут в
    // итоговую строку.
    // 
    // Таким образом:
    // - для открывающей скобки:
    //   внешняя '(' приводит к depth === 1 и не
    //   добавляется.
    //
    //   Внутренняя '(' (depth >= 2) добавляется.
    // 
    // - для закрывающей скобки:
    //   проверка выполняется до уменьшения depth,
    //   поэтому если перед закрывающей скобкой
    //   depth > 1, то эта ')' считается
    //   внутренней и добавляется.
    //
    //   если depth === 1, то это внешняя ')' и
    //   она не добавляется.
    if (depth > 1) result.push(char);

    // Если текущий символ — закрывающая скобка,
    // уменьшаем глубину вложенности.
    // 
    // Уменьшение выполняется после возможного
    // добавления символа в result, что важно:
    // мы хотим, чтобы внутренняя закрывающая
    // скобка (когда depth > 1 до уменьшения)
    // была добавлена, а внешняя 
    // (когда depth === 1 до уменьшения) — не
    // была.
    if (char === ')') depth--;
  }

  // После прохода по всей строке собираем
  // символы из массива result в одну строку
  // и возвращаем её.
  // 
  // join('') даёт результирующую строку без
  // разделителей - это и есть результирующая
  // строка без внешних скобок.
  // 
  // Временная сложность:
  //   O(n),
  // дополнительная память:
  //   O(n) в худшем случае.
  return result.join('');
}
