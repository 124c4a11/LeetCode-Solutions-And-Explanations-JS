/**
 * @param {string} s
 * @return {string[]}
 * 
 * cellsInRange генерирует и возвращает массив строковых
 * адресов всех ячеек, находящихся внутри указанного
 * диапазона в табличном формате (аналогично адресам в
 * Excel).
 * 
 * Она перебирает столбцы от начального до конечного и
 * для каждого столбца перебирает строки от начальной до
 * конечной, формируя адреса вида "A1", "A2", "B1" и
 * т. д., и собирает их в массив.
 * 
 * Параметры:
 * - s — строка. Ожидаемый формат:
 *   "<StartCol><StartRow>:<EndCol><EndRow>",
 *   например "A1:B2".
 * 
 * 
 * Пример для: 
 *   s = "K1:L2"
 * Результат:
 *   ["K1","K2","L1","L2"]
 */
function cellsInRange(s) {

  // Получаем числовой код Unicode (code point) символа
  // в позиции 0 строки s — это символ начального
  // столбца (например 'A').
  // 
  // codePointAt возвращает число (например 65 для 'A').
  //
  // Это позволяет итерировать по кодам символов для
  // последовательных букв.
  const startCol = s.codePointAt(0);

  // Получаем числовой код Unicode символа в позиции 3
  // строки s — это символ конечного столбца
  // (например 'C').
  // 
  // Предполагается, что формат всегда такой, что
  // символ конечного столбца находится на индексе 3.
  //
  // Если формат другой, результат будет некорректен.
  const endCol = s.codePointAt(3);

  // Берём символ в позиции 1 строки s (второй символ)
  // и преобразуем его в число.
  // 
  // Ожидается, что это цифра начальной строки
  // (например '1').
  //
  // При формате "K1:L2" позиция 1 содержит '1'
  //
  // По условию задачи номер строки находится в
  // диапазоне от 1 до 9
  const startRow = Number(s[1]);

  // Берём символ в позиции 4 строки s и приводим его к
  // числу — это номер конечной строки
  //
  // При формате "K1:L2" позиция 4 содержит '2'
  const endRow = Number(s[4]);

  // Инициализируем пустой массив для накопления
  // строковых обозначений всех ячеек в диапазоне.
  // 
  // Формат элементов массива будет строкой вида
  // "K1", "K2" и т.д.
  const result = [];

  // Внешний цикл: 
  // Перебираем коды столбцов от startCol до endCol
  // включительно.
  // 
  // Поскольку startCol и endCol — числовые коды Unicode,
  // мы итерируем по числам, соответствующим буквам.
  // 
  // Это обеспечивает последовательность столбцов по
  // алфавиту (например, 65 → 'A', 66 → 'B').
  //
  // Вначале проходим по колонкам потому, что функция
  // должна выдавать ячейки в порядке по столбцам
  // (сначала все строки для первого столбца, затем для
  // следующего)
  for (let c = startCol; c <= endCol; c++) {

    // Внутренний цикл:
    // Перебираем номера строк от startRow до endRow
    // включительно.
    // 
    // r — числовое значение строки. Комбинируя его с
    // символом столбца, получаем адрес ячейки.
    for (let r = startRow; r <= endRow; r++) {

      // Формируем строку адреса ячейки:
      // Преобразуем код столбца обратно в символ с
      // помощью String.fromCodePoint(c), затем
      // конкатенируем с числом строки r 
      // (автоматически приводится к строке).
      // 
      // Например, при c = 65 и r = 1 получится "A1".
      result.push(String.fromCodePoint(c) + r);
    }
  }

  // Возвращаем массив result, содержащий все адреса
  // ячеек в указанном диапазоне в порядке:
  // Сначала по столбцам, внутри — по строкам. 
  // 
  // Порядок будет таким:
  // Для каждого столбца перечисляются все строки от
  // startRow до endRow, затем переход к следующему
  // столбцу.
  return result;
}
