/**
 * @param {string} s
 * @return {string}
 * 
 * freqAlphabets декодирует строку, закодированную по правилу:
 * одиночные цифры '1'–'9' соответствуют буквам 'a'–'i', а
 * двухзначные числа с суффиксом '#' — '10#'–'26#' —
 * соответствуют буквам 'j'–'z'.
 * 
 * Функция проходит по входной строке и строит расшифрованную
 * строку из букв латинского алфавита в нижнем регистре.
 * 
 * Параметры:
 * - s — строка содержит последовательность символов,
 *   состоящую только из цифр и символов #, в формате
 *   кодирования, описанном выше
 * 
 * 
 * Пример для:
 *   s = "10#11#12"
 * Результат:
 *   "jkab"
 * Пояснение:
 *   "j" → "10#" , "k" → "11#" , "a" → "1" , "b" → "2".
 * 
 * 
 * Пример для:
 *   s = "1326#"
 * Результат:
 *   "acz"
 */
function freqAlphabets(s) {
  const n = s.length;

  // Инициализируем пустой массив result, в который будем по
  // одному добавлять декодированные символы.
  //
  // Массив выбран вместо конкатенации строк, чтобы избежать
  // квадратичной сложности при многократной конкатенации
  // строк в цикле.
  //
  // Многократная конкатенация строк в цикле обычно имеет
  // худшую практическую производительность и может вести к
  // O(n^2) по времени в худшем случае, тогда как сбор в
  // массив с последующим join даёт линейную сложность O(n)
  // и обычно быстрее и экономичнее по памяти при больших
  // объёмах данных.
  const result = [];

  // Инициализируем индекс i нулём — он указывает на текущую
  // позицию в строке s при итерации.
  let i = 0;

  // Проходим по строке s
  //
  // На каждой итерации обрабатываем либо один символ, либо
  // группу "XY#".
  while (i < n) {

    // Проверяем условие для формата с '#':
    // 
    // 1. i + 2 < n — убеждаемся, что доступ к s[i+2]
    //    безопасен (не выйдем за пределы строки).
    // 
    // 2. s[i + 2] === '#' — проверяем, что третий символ
    //    от текущей позиции равен символу '#', что
    //    означает, что текущая и следующая цифры образуют
    //    число от 10 до 26, соответствующее букве.
    if (
      i + 2 < n
      && s[i + 2] === '#'
    ) {

      // Если условие истинно, извлекаем двухсимвольную
      // подстроку от позиции i до i + 2 (не включая i + 2).
      // 
      // Это даёт строку из двух цифр, например "10" или "26".
      const numStr = s.slice(i, i + 2);

      // Преобразуем строку numStr в число с помощью
      // Number(numStr).
      // 
      // Затем прибавляем 96, потому что в Unicode код
      // символа 'a' равен 97, а нам нужно получить букву,
      // соответствующую числу 1 → 'a', 2 → 'b', ..., 26 → 'z',
      // поэтому нам необходимо смещение на + 96
      // 
      // Пример:
      //   1 + 96 = 97 → 'a'.
      //   2 + 96 = 98 → 'b'.
      //   ...
      //   26 + 96 = 122 → 'z'.
      // 
      // String.fromCodePoint используется для получения
      // символа по коду Unicode.
      // 
      // Полученный символ добавляем в массив result.
      result.push(String.fromCodePoint(Number(numStr) + 96));

      // Так как мы обработали два цифровых символа и символ
      // '#', пропускаем их, увеличив i на 3.
      // 
      // Это перемещает указатель на следующее за # число в
      // строке
      i += 3;
    } else {

      // Если условие с '#' не выполнено, обрабатываем
      // одиночный символ (цифру от '1' до '9').
      // 
      // Берём символ s[i], преобразуем его в число,
      // прибавляем 96 и получаем соответствующую букву.
      // 
      // Это покрывает случаи, когда кодировка использует
      // одиночные цифры для букв 'a'..'i'.
      result.push(String.fromCodePoint(Number(s[i]) + 96));

      // Переходим к следующему символу, увеличивая i на 1.
      i++;
    }
  }

  // После завершения цикла объединяем все элементы массива
  // result в одну строку без разделителей и возвращаем эту
  // строку как результат работы функции.
  return result.join('');
}
