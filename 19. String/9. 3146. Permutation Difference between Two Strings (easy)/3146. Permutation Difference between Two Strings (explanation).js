/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 * 
 * findPermutationDifference принимает две строки s и t
 * одинаковой длины и возвращает разницу между
 * перестановками s и t.
 * 
 * Разница между перестановками s и t определяется как
 * сумма абсолютных разностей между индексом появления
 * каждого символа в s и индексом появления того же
 * символа в t.
 * 
 * Параметры:
 * - s и t, ожидаются строчные латинские буквы и
 *   одинаковая длина. 
 * 
 * Возвращает:
 * - число — сумма абсолютных разностей между индексом
 *   появления каждого символа в s и индексом появления
 *   того же символа в t.
 * 
 * 
 * Пример для:
 *   s = "abc",
 *   t = "bac"
 * Результат:
 *   2
 * Пояснение:
 * Для s = "abc" и t = "bac" разница перестановок
 * между s и t равна сумме:
 * - Абсолютной разницы между индексом вхождения "a" в s
 *   и индексом вхождения "a" в t.
 * 
 * - Абсолютной разницы между индексом вхождения "b" в s
 *   и индексом вхождения "b" в t.
 * 
 * - Абсолютной разницы между индексом вхождения "c" в s
 *   и индексом вхождения "c" в t.
 * То есть разница перестановок между s и t равна
 * |0 - 1| + |1 - 0| + |2 - 2| = 2.
 */
function findPermutationDifference(s, t) {

  // Получаем длину строки s и сохраняем в константу n.
  //
  // Предполагается, что s.length === t.length;
  const n = s.length;

  // Создаём массив типа Int32Array длиной 26 для
  // хранения позиций букв из строки s.
  //
  // Индекс массива соответствует букве:
  // 0 → 'a', 1 → 'b', ..., 25 → 'z'. 
  //
  // Значение — индекс этой буквы в строке s.
  //
  // Использование Int32Array экономит память и даёт
  // быстрый доступ по индексу.
  const sCharToNdx = new Int32Array(26);

  // Проходим по всем индексам строки s, чтобы заполнить
  // отображение символ → его индекс в s.
  //
  // Цикл предполагает, что в s каждая буква встречается
  // ровно один раз (перестановка).
  for (let i = 0; i < n; i++) {

    // s.codePointAt(i) возвращает числовой код Unicode
    // символа в позиции i.
    //
    // Для строчных латинских букв код 'a' равен 97,
    // поэтому вычитание 97 даёт индекс для каждой 
    // буква в диапазоне 0..25, где
    // 0 → 'a', 1 → 'b', ..., 25 → 'z'. 
    //
    // Полученный индекс используется как позиция в
    // массиве sCharToNdx, куда записывается
    // i - позиция текущей буквы в строке s.
    //
    // Это позволяет в дальнейшем по букве быстро
    // получить её позицию в исходной строке s.
    sCharToNdx[s.codePointAt(i) - 97] = i;
  }

  // Инициализируем аккумулятор result нулём.
  //
  // В нём будет накапливаться суммарная абсолютная
  // разница позиций.
  let result = 0;

  // Проходим по всем позициям строки t.
  //
  // Для каждой позиции i будем находить
  // соответствующую позицию того же символа в s и
  // добавлять абсолютную разницу индексов в result.
  for (let i = 0; i < n; i++) {

    // Для символа t[i] аналогично вычисляем индекс
    // текущей буквы в диапазоне 0..25.
    //
    // Затем по этому индексу из массива sCharToNdx
    // извлекаем позицию этой буквы в строке s.
    const sCharNdx = sCharToNdx[t.codePointAt(i) - 97];

    // Прибавляем к result абсолютную разницу между
    // позицией символа в s и текущей позицией i в t.
    //
    // Math.abs гарантирует неотрицательное значение.
    result += Math.abs(sCharNdx - i);
  }

  // Возвращаем сумму абсолютных разностей между
  // индексом появления каждого символа в s и
  // индексом появления того же символа в t.
  return result;
}
