/**
 * @param {string} key
 * @param {string} message
 * @return {string}
 * 
 * decodeMessage декодирует зашифрованную строку, используя 
 * ключ — строку, из которой формируется подалфавит на основе
 * первых уникальных букв.
 * 
 * Параметры:  
 * - key — строка, содержащая последовательность символов
 *   (буквы и пробелы).
 * 
 *   key используется для формирования подалфавита:
 *   Берутся первые вхождения каждой буквы
 *   (игнорируются пробелы и повторные буквы).
 * 
 *   key состоит из строчных английских букв и кавычек.
 * 
 * - message — строка, представляющая зашифрованное сообщение.
 *   Функция декодирует её, заменяя каждую букву по соответствию,
 *   полученному из key.
 * 
 *   Пробелы в message сохраняются.
 * 
 *   message состоит из строчных английских букв и кавычек.
 * 
 * Возвращает декодированную строку в нижнем регистре.
 */
function decodeMessage(key, message) {

  // Объявление константы alphabet — строка из 26 букв латинского
  // алфавита в нижнем регистре.
  // 
  // Будет использоваться для получения буквы по её порядковому
  // индексу (0..25).
  const alphabet = 'abcdefghijklmnopqrstuvwxyz';

  // Создаём массив длиной 26, где каждый индекс соответствует букве
  // 0 → 'a', 1 → 'b', ..., 25 → 'z',
  // а значение — индекс в псевдо-алфавите, сформированном из ключа.
  //
  // Изначально заполняем -1, что означает "сопоставление не
  // установлено"
  //
  // Используем массив а не Map, для экономии памяти и ускорения
  // работы кода
  const keyCharToAlphabetNdx = new Array(26).fill(-1);

  // Счётчик следующего свободного индекса в псевдо-алфавите,
  // который мы присваиваем уникальным буквам из key.
  // 
  // Начинается с 0 и увеличивается при обнаружении новой уникальной
  // буквы в ключе.
  let alphabetNdx = 0;

  // Проходим по каждому символу строки key в порядке их появления
  for (const char of key) {

    // Если текущий символ — пробел, он не участвует в формировании
    // сопоставления, поэтому пропускаем его
    if (char === ' ') continue;

    // Вычисляем числовой индекс буквы в стандартном алфавите:
    // код Unicode символа минус код символа 'a' (97) даёт значение
    // 0..25 для 'a'..'z'.
    const i = char.codePointAt(0) - 97;

    // Если для этой буквы уже было назначено значение (не равно -1),
    // значит это повторное вхождение — пропускаем, чтобы сохранить
    // первое назначение.
    if (keyCharToAlphabetNdx[i] !== -1) continue;

    // Присваиваем для буквы (с индексом i в обычном алфавите)
    // значение текущего счётчика alphabetNdx — это позиция буквы
    // в "алфавите", построенном из ключа.
    keyCharToAlphabetNdx[i] = alphabetNdx;

    // Увеличиваем счётчик, чтобы следующая уникальная буква ключа
    // получила следующий индекс.
    alphabetNdx++;
  }

  // Массив для накопления символов расшифрованного сообщения.
  // 
  // Использование массива и последующий join производительнее,
  // чем конкатенация строк на каждой итерации цикла.
  const result = [];

  // Проходим по каждому символу зашифрованного сообщения message
  for (const char of message) {

    // Если текущий символ — пробел, сохраняем пробел в
    // результирующий массив и переходим к следующему символу,
    // чтобы пробелы в расшифрованном тексте находились на тех
    // же позициях, что и в исходном сообщении message 
    if (char === ' ') {
      result.push(' ');
      continue;
    }

    // Для буквы из message находим её индекс в стандартном
    // алфавите (опять же через codePointAt(0) - 97) и
    // используем этот индекс как ключ для доступа к
    // keyCharToAlphabetNdx, где хранится позиция в подалфавите. 
    // 
    // В переменной alphabetNdx теперь хранится позиция буквы
    // в подалфавите, соответствующая исходной букве ключа.
    const alphabetNdx = keyCharToAlphabetNdx[char.codePointAt(0) - 97];

    // Берём букву из стандартного алфавита по найденному индексу
    // и добавляем её в массив результата.
    //
    // Это и есть операция декодирования:
    // Замена символа зашифрованного сообщения на соответствующую
    // букву обычного алфавита.
    result.push(alphabet[alphabetNdx]);
  }

  // Объединяем элементы массива result в одну строку без
  // разделителей и возвращаем полученную декодированную строку
  // как результат функции.
  return result.join('');
}
