/**
 * @param {string} s
 * @return {string}
 *
 * reverseByType принимает строку и возвращает новую
 * строку, в которой символы двух типов — строчные
 * латинские буквы (a–z) и специальные символы —
 * остаются на своих исходных позициях по типу, но
 * порядок символов внутри каждого типа обращён
 * (т. е. буквы идут в обратном порядке относительно
 * друг друга, и специальные символы тоже идут в
 * обратном порядке).
 *
 * Параметры:
 * - s - строка содержащая строчные латинские буквы
 *   и специальные символы
 *
 *
 * Пример для:
 *   s = ")ebc#da@f("
 * Результат:
 *   "(fad@cb#e)"
 * Объяснение:
 * - Буквы в строке:
 *   ['e', 'b', 'c', 'd', 'a', 'f']
 *
 *   - Обращение порядка букв даёт:
 *     ['f', 'a', 'd', 'c', 'b', 'e']
 *
 *   - После этого s становится
 *     ")fad#cb@e("
 *
 * - Специальные символы в строке:
 *   [')', '#', '@', '(']
 *
 *   - Обращение порядка специальных символов даёт:
 *     ['(', '@', '#', ')']
 *
 *   - В результате s превращается в
 *     "(fad@cb#e)"
 */
function reverseByType(s) {

  // Инициализация массива для хранения строчныx
  // латинскиx букв.
  //
  // Массив будет заполняться в порядке обхода строки,
  // затем использоваться как стек (pop) для получения
  // обратного порядка букв.
  const lettersStack = [];

  // Инициализация массива для хранения "специальных"
  // символов.
  //
  // Аналогично lettersStack, этот массив будет
  // использоваться как стек для обратного порядка
  // специальных символов.
  const specialsStack = [];

  // Проход по каждому символу строки s и заполняем
  // lettersStack и specialsStack
  for (const char of s) {

    // Вызов вспомогательной функции isSpecialChar
    // для определения, считать ли текущий символ
    // "специальным".
    if (isSpecialChar(char)) {

      // Если символ признан специальным, добавляем
      // его в конец массива specialsStack.
      specialsStack.push(char);
    } else {

      // Если символ не специальный (т.е. считается
      // буквой), добавляем его в lettersStack.
      lettersStack.push(char);
    }
  }

  // Создаётся массив result, в который будет поэтапно
  // собираться итоговая строка.
  //
  // Элементы будут добавляться в том же количестве и
  // в тех же позициях, что и в исходной строке, но с
  // обратным порядком внутри каждого типа.
  //
  // Массив выбран вместо конкатенации строк, чтобы
  // избежать квадратичной сложности при многократной
  // конкатенации строк в цикле.
  //
  // Многократная конкатенация строк в цикле обычно
  // имеет худшую практическую производительность и
  // может вести к O(n^2) по времени в худшем случае,
  // тогда как сбор в массив с последующим join даёт
  // линейную сложность O(n) и обычно быстрее и
  // экономичнее по памяти при больших объёмах данных.
  const result = [];

  // Снова проходим по исходной строке s в том же
  // порядке, чтобы на каждой позиции восстановить
  // символ нужного типа, но беря их из
  // соответствующих стеков в обратном порядке
  // появления.
  for (const char of s) {

    // Вызов вспомогательной функции isSpecialChar
    // для определения, считать ли текущий символ
    // "специальным".
    if (isSpecialChar(char)) {

      // Если на текущей позиции исходной строки был
      // специальный символ, то в результирующую
      // позицию помещаем последний добавленный
      // специальный символ (pop), что обеспечивает
      // обратный порядок специальных символов
      // относительно их исходного порядка.
      result.push(specialsStack.pop());
    } else {

      // Иначе (если на этой позиции была буква),
      // помещаем в результат последний добавленный
      // элемент из lettersStack, тем самым обращая
      // порядок букв относительно их исходного
      // порядка.
      result.push(lettersStack.pop());
    }
  }

  // После заполнения массива result объединяем его
  // элементы в одну строку без разделителей и
  // возвращаем как результат функции.
  //
  // Если исходная строка пустая, result пуст и
  // join вернёт пустую строку.
  return result.join('');
}

// Объявляем именованную функцию isSpecialChar,
// которая принимает один символ char и возвращает
// - true - если символ является "сециальным"
//
// - false - если символ является строчной
//   латинской буквой
//
// Эта функция инкапсулирует правило классификации
// символов на "буквы" и "специальные символы".
function isSpecialChar(char) {

  // Возвращает true, если символ находится вне
  // диапазона от 'a' до 'z' включительно.
  //
  // По условию задачи строка s содержит только
  // строчные латинские буквы и специальные символы.
  // Следовательно, чтобы определить специальный
  // символ, достаточно убедиться в том, что он не
  // входит в диапазон строчных латинских букв
  // 'a'...'z'.
  return char < 'a' || 'z' < char;
}
