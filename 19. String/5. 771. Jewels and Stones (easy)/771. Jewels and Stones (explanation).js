/**
 * @param {string} jewels
 * @param {string} stones
 * @return {number}
 * 
 * numJewelsInStones считает, сколько элементов из
 * строки stones совпадают с типами, 
 * перечисленными в строке jewel с учетом регистра. 
 * 
 * Параметры:
 * - jewels — строка, содержащий уникальные
 *   символы/элементы, которые обозначают типы
 *   драгоценных камней. 
 * 
 * - stones — строка, содержащий символы/элементы,
 *   представляющие имеющиеся у вас камни.
 *
 * Возвращает:
 * - целое число — количество совпадений
 *   (учитывается регистр символов)
 * 
 * 
 * Пример для:
 *   jewels = "aA",
 *   stones = "aAAbbbb"
 * Результат:
 *   3
 */
function numJewelsInStones(jewels, stones) {

  // Создаём Set для хранения уникальных значений
  // из jewels.
  // 
  // Set обеспечивает быстрый доступ
  // (амортизированное O(1)) для операций has/add,
  // и автоматически устраняет дубликаты, если
  // jewels содержит повторяющиеся символы.
  const jewelSet = new Set();

  // Итерируем по каждому символу в строке
  // jewels.
  for (const jewel of jewels) {

    // Добавляем текущий элемент jewel в
    // множество jewelSet.
    //
    // Это упрощает последующую проверку
    // принадлежности камня к набору
    // драгоценностей.
    jewelSet.add(jewel);
  }

  // Инициализируем счётчик result значением 0.
  // 
  // В нём будет аккумулироваться количество
  // элементов из stones, которые совпадают с
  // элементами в jewelSet.
  let result = 0;

  // Итерация по каждому символу строки
  // stones.
  for (const stone of stones) {

    // Для каждого stone выполняем проверку
    // наличия в множестве jewelSet.
    // 
    // Если stone присутствует в jewelSet, это
    // означает, что данный камень является
    // драгоценностью, и мы увеличиваем
    // счётчик result на единицу.
    if (jewelSet.has(stone)) result++;
  }

  // Возвращаем итоговый результат — количество
  // камней из stones, которые являются
  // драгоценностями.
  // 
  // При пустых входных данных (пустые строки)
  // вернётся 0.
  return result;
}
