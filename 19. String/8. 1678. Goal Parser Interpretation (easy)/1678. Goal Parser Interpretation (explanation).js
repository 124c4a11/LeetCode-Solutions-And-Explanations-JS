/**
 * @param {string} command
 * @return {string}
 * 
 * interpret преобразует входную строку command,
 * состоящую только из шаблонов G, (), (al), в
 * итоговую строку,
 * где G → "G", () → "o", (al) → "al" 
 * 
 * 
 * Пример для:
 *   command = "G()(al)"
 * Результат:
 *   "Goal"
 * Пояснение:
 *   Парсер команд (Goal Parser) интерпретирует
 *   команду следующим образом:
 *   G → G 
 *   () → o
 *   (al) → al
 *   Итоговый объединённый результат: "Goal".
 */
function interpret(command) {

  // Создаём пустой массив result для накопления
  // частей результирующей строки.
  // 
  // Использование массива предпочтительнее
  // конкатенации строк в цикле, так как
  // push + join обычно эффективнее при
  // множественных добавлениях.
  const result = [];

  // Инициализируем индекс i нулём — он будет
  // указывать на текущую позицию в строке
  // command при пошаговом разборе.
  // 
  // Используется ручное управление шагом, так
  // как i может увеличиваться на разные
  // значения в зависимости от условия.
  let i = 0;

  // Запускаем цикл, который будет выполняться,
  // пока индекс i меньше длины строки.
  // 
  // Внутри цикла мы анализируем шаблоны 
  // символов и продвигаем i на 1, 2 или 4
  // позиции в зависимости от распознанного
  // шаблона.
  while (i < command.length) {

    // Считываем текущий символ по индексу i
    // и сохраняем в currChar.
    const currChar = command[i];

    // Считываем следующий символ по индексу
    // i + 1 и сохраняем в nextChar.
    // 
    // Важно:
    // Если i + 1 выходит за пределы строки,
    // nextChar будет undefined, что
    // корректно обрабатывается в последующих
    // сравнениях.
    const nextChar = command[i + 1];

    // Проверяем, является ли текущий символ
    // буквой 'G'. 
    // 
    // 'G' интерпретируется как 'G'.
    if (currChar === 'G') {

      // Если текущий символ — 'G', добавляем
      // в массив result строку 'G'.
      result.push('G');

      // Переходим к следующему символу,
      // увеличивая i на 1.
      // 
      // Это корректно, потому что мы
      // обработали ровно один символ
      // входной строки.
      i++;

      // Иначе проверяем, не является ли
      // текущая позиция началом шаблона "()",
      // то есть '(' сразу за которым идёт ')'.
    } else if (

      // Проверяем, что текущий символ
      // — открывающая скобка '('.
      currChar === '('

      // И одновременно проверяем, что
      // следующий символ — закрывающая
      // скобка ')'.
      && nextChar === ')'
    ) {

      // Если обнаружен шаблон "()", то по
      // спецификации он интерпретируется как
      // 'o'.
      // 
      // Добавляем символ 'o' в массив result.
      result.push('o');

      // Поскольку мы обработали два символа
      // — '(' и ')', увеличиваем i на 2,
      // чтобы пропустить их и продолжить
      // разбор со следующей позиции.
      i += 2;
    } else {

      // Во всех остальных случаях
      // предполагается, что текущая позиция
      // указывает на начало шаблона "(al)".
      // 
      // Этот блок срабатывает, когда
      // currChar === '(' и nextChar === 'a'
      //
      // По спецификации "(al)"
      // интерпретируется как 'al'.
      //
      // Добавляем символ 'al' в массив
      // result.
      result.push('al');

      // Шаблон "(al)" состоит из четырёх
      // символов: '(' 'a' 'l' ')'. Поэтому
      // пропускаем 4 позиции, увеличивая
      // i на 4.
      i += 4;
    }
  }

  // После завершения цикла объединяем все
  // элементы массива result в одну строку без
  // разделителя и возвращаем её как результат
  // работы функции.
  // 
  // Например, для входа "G()(al)" result
  // будет ['G','o','al'] и join вернёт
  // "Goal".
  return result.join('');
}
