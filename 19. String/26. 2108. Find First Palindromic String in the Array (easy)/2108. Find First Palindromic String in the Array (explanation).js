/**
 * @param {string[]} words
 * @return {string}
 * 
 * firstPalindrome принимает массив строк и возвращает
 * первую строку‑палиндром из этого массива.
 * 
 * Если палиндромов нет, возвращает пустую строку
 * 
 * 
 * Пример для:
 *   words = ["abc","car","ada","racecar","cool"]
 * Результат:
 *   "ada" 
 * Пояснение:
 *   Первой строкой, являющейся палиндромом, является
 *   "ada".
 *
 *   Обратите внимание, что "racecar" также является
 *   палиндромом, но он не первый.
 */
function firstPalindrome(words) {

  // Перебираем элементы массива words по очереди.
  for (const word of words) {

    // Вызов вспомогательной функции isPalindrome с
    // текущей строкой word.
    // 
    // Если isPalindrome вернёт true, строка является
    // палиндромом (читается одинаково слева направо
    // и справа налево) - выполняем немедленный
    // возврат этой строки из функции firstPalindrome
    // 
    // Это обеспечивает ранний выход при нахождении
    // первого палиндрома и экономит время.
    if (isPalindrome(word)) return word;
  }

  // Если цикл завершился и ни одна строка не была
  // палиндромом, возвращаем пустую строку ''.
  // 
  // Пустая строка служит явным индикатором
  // отсутствия подходящего слова.
  return '';
}

/**
 * 
 * @param {string} s 
 * @return {boolean}
 * 
 * isPalindrome, принимает один параметр s — строку
 * и проверяет, является ли эта строка палиндромом
 * 
 * Функция возвращает true, если s является
 * палиндромом, иначе false.
 */
function isPalindrome(s) {

  // Инициализация левого указателя l на индекс
  // первого символа строки (0).
  // 
  // Этот указатель будет двигаться вправо при
  // сравнении пар символов.
  let l = 0;

  // Инициализация правого указателя r на индекс
  // последнего символа строки (длина минус 1).
  // 
  // Этот указатель будет двигаться влево при
  // сравнении пар символов.
  let r = s.length - 1;

  // Цикл while выполняется, пока левый указатель
  // не превысит правый.
  // 
  // Условие l <= r гарантирует, что для нечётной
  // длины центральный символ будет проверён
  // корректно (сравнение самого с собой).
  while (l <= r) {

    // Сравниваем символы на позициях l и r.
    // 
    // Если они не равны, строка не является
    // палиндромом, и можно немедленно вернуть
    // false.
    if (s[l] !== s[r]) return false;

    // Сдвигаем левый указатель вправо, чтобы
    // перейти к следующей паре символов.
    l++;

    // Сдвигаем правую позицию влево на один
    // символ для следующей пары сравнения
    r--;
  }

  // Если цикл завершился без нахождения
  // несовпадающих пар, все соответствующие
  // символы совпадают.
  // 
  // В этом случае строка является палиндромом
  // — возвращаем true.
  return true;
}
