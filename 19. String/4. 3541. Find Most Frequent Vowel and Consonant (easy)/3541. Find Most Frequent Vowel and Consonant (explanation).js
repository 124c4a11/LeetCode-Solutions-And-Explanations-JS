/**
 * @param {string} s
 * @return {number}
 * 
 * maxFreqSum принимает одну строку и возвращает число
 * — сумму двух значений: максимальной частоты появления
 * одной гласной в строке и максимальной частоты появления
 * одной согласной в строке. 
 * 
 * Параметры:
 * - s — строка для анализа. Ожидается, что строка
 *   содержит символы, соответствующие строчным латинским
 *   буквам a – z
 * 
 * 
 * Пример для:
 *   s = "successes"
 * Результат:
 *   6
 * Пояснение:
 *   Гласные: 'u' (частота 1), 'e' (частота 2).
 *   Максимальная частота среди гласных — 2.
 * 
 *   Согласные: 's' (частота 4), 'c' (частота 2).
 *   Максимальная частота среди согласных — 4.
 * Результат:
 *   2 + 4 = 6.
 */
function maxFreqSum(s) {

  // Создаём Set с гласными в нижнем регистре для
  // O(1)-проверок принадлежности символа к гласным.
  const vowelSet = new Set(['a', 'e', 'i', 'o', 'u']);

  // Инициализируем массив фиксированной длины 26 типа
  // Int32Array для хранения частот букв латинского
  // алфавита. 
  // 
  // Int32Array экономит память и может быть быстрее
  // обычного массива для числовых операций.
  // 
  // Индекс 0 соответствует 'a', индекс 25 — 'z'.
  //
  // Значения каждого элемента соответствует количеству
  // вхождений этой буквы в строке s
  //
  // Все элементы по умолчанию равны 0.
  const charFreq = new Int32Array(26);

  // Итерация по каждому символу входной строки s.
  for (const char of s) {

    // Получаем числовой код символа и вычитаем 97 ('a'),
    // чтобы получить индекс в диапазоне 0..25.
    // 
    // codePointAt(0) возвращает кодовую точку символа.
    // Это безопаснее и быстрее, чем charCodeAt для
    // некоторых юникод-символов.
    // 
    // Увеличиваем соответствующий счётчик в массиве
    // частот.
    charFreq[char.codePointAt(0) - 97]++;
  }

  // Переменная для хранения максимальной частоты среди
  // гласных.
  // 
  // Стартует с 0. 
  // 
  // Если в строке нет гласных, останется 0.
  let maxVowelFreq = 0;

  // Переменная для хранения максимальной частоты среди
  // согласных.
  // 
  // Стартует с 0.
  // 
  // Если в строке нет согласных, останется 0.
  let maxConsonantFreq = 0;

  // Второй проход по строке s:
  // 
  // Для каждого символа извлекаем его общую частоту из
  // ранее заполненного массива charFreq и обновляем
  // соответствующий максимум (гласный или согласный).
  for (const char of s) {

    // Получаем частоту текущего символа из массива
    // частот по тому же индексу 0..25 (код символа
    // минус код 'a').
    // 
    // Это константная операция доступа к массиву, O(1).
    const freq = charFreq[char.codePointAt(0) - 97];

    // Проверяем, является ли текущий символ гласной,
    // используя множество vowelSet.
    // 
    // Если да — обновляем максимум для гласных, иначе
    // — для согласных.
    if (vowelSet.has(char)) {

      // Если это гласная, обновляем максимум для
      // гласных:
      // 
      // Выбираем большее из текущего maxVowelFreq и
      // freq.
      maxVowelFreq = Math.max(maxVowelFreq, freq);
    } else {

      // Если символ не найден в множестве гласных,
      // считаем его согласной (в рамках предположения
      // о входных данных) и обновляем максимум для
      // согласных аналогичным образом.
      maxConsonantFreq = Math.max(maxConsonantFreq, freq);
    }
  }

  // Возвращаем сумму двух найденных максимумов:
  // 
  // Максимальной частоты гласной и максимальной
  // частоты согласной.
  // 
  // Если в строке отсутствуют гласные или согласные,
  // соответствующий максимум останется 0, что
  // корректно учитывается в сумме.
  return maxVowelFreq + maxConsonantFreq;
}
