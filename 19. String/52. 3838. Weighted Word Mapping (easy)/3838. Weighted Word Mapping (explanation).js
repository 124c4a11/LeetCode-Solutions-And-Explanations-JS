/**
 * @param {string[]} words
 * @param {number[]} weights
 * @return {string}
 *
 * mapWordWeights принимает массив слов и массив числовых
 * весов для букв, вычисляет для каждого слова суммарный
 * вес (сумму весов его символов), берёт этот суммарный
 * вес по модулю 26 и затем отображает полученное значение
 * в строчную букву английского алфавита в обратном
 * порядке (0 → 'z', 1 → 'y', …, 25 → 'a'). Результатом
 * является строка, полученная конкатенацией таких
 * отображённых букв в том же порядке, в котором шли слова
 * во входном массиве.
 *
 *  Параметры
 * - words — массив строк. Ожидается, что каждый элемент
 *   - слово, состоящее из строчных английских букв
 *   ('a'–'z').
 *
 * - weights — массив чисел длины 26, где weights[i] -
 *   вес i‑й строчной английской буквы. weights[0]
 *   соответствует весу буквы 'a', weights[1] - 'b' и т.д.
 *   до weights[25] для 'z'.
 *
 *
 * Пример для:
 * - words = ["abcd","def","xyz"],
 * - weights =
 *   [5,3,12,14,1,2,3,2,10,6,6,9,7,8,7,10,8,9,6,9,9,8,3,7,7,2]
 * Результат:
 *   "rij"
 * Пояснение:
 * - Вес "abcd" равен 5 + 3 + 12 + 14 = 34. Остаток от
 *   деления 34 % 26 = 8, что соответствует 'r'.
 *
 * - Вес "def" равен 14 + 1 + 2 = 17. Остаток от деления
 *   17 % 26 = 17, что соответствует 'i'.
 *
 * - Вес "xyz" равен 7 + 7 + 2 = 16. Остаток от деления
 *   16 % 26 = 16, что соответствует 'j'.
 * Таким образом, строка, полученная конкатенацией
 * отображённых символов, — "rij".
 */
function mapWordWeights(words, weights) {

  // Инициализируем пустой массив result, в который будем по
  // одному добавлять итоговые символы для каждого слова.
  //
  // В конце он будет объединён в строку
  //
  // Массив выбран вместо конкатенации строк, чтобы избежать
  // квадратичной сложности при многократной конкатенации
  // строк в цикле.
  //
  // Многократная конкатенация строк в цикле обычно имеет
  // худшую практическую производительность и может вести к
  // O(n^2) по времени в худшем случае, тогда как сбор в
  // массив с последующим join даёт линейную сложность O(n)
  // и обычно быстрее и экономичнее по памяти при больших
  // объёмах данных.
  const result = [];

  // Итерация по каждому элементу входного массива words
  for (const word of words) {

    // Для текущего слова заводим аккумулятор wordWeight,
    // который будет хранить суммарный вес букв этого слова.
    let wordWeight = 0;

    // Итерация по каждому символу (char) в строке word
    for (const char of word) {

      // Получаем числовой код символа char с помощью
      // codePointAt(0).
      //
      // Вычитаем 97 (код символа 'a') чтобы получить индекс
      // 0..25  в массиве weights, соответствующий букве
      // латинского алфавита в нижнем регистре.
      //
      // Затем добавляем значение weights[index] к wordWeight.
      wordWeight += weights[char.codePointAt(0) - 97];
    }

    // Нормализуем накопленный вес в диапазон 0..25, беря
    // остаток от деления на 26.
    //
    // Это эквивалентно приведению суммы к позиции в алфавите
    // по модулю длины алфавита.
    wordWeight %= 26;

    // Вычисляем результирующий символ для текущего слова:
    //
    // 1. 25 - wordWeight инвертирует позицию (0 → 25, 25 → 0),
    //    то есть зеркально отображает значение внутри
    //    диапазона 0..25;
    //
    // 2. Прибавляем 97, чтобы получить код символа в Unicode
    //    для строчной латинской буквы;
    //
    // 3. String.fromCodePoint преобразует числовой код
    //    обратно в символ;
    //
    // 4. Полученный символ добавляем в массив result.
    result.push(String.fromCodePoint(25 - wordWeight + 97));
  }

  // Объединяем все символы в массиве result в одну строку
  // без разделителей и возвращаем её как результат работы
  // функции.
  return result.join('');
}
