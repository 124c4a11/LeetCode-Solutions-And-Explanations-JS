/**
 * @param {string} word
 * @param {character} ch
 * @return {string}
 * 
 * reversePrefix находит первую позицию символа ch в
 * строке word и переворачивает префикс от начала до
 * этой позиции включительно.
 * 
 * Если ch не найден, возвращает исходную строку без
 * изменений.
 * 
 * Параметры:  
 * - word — входная строка. Это исходный текст, в
 *   котором ищется символ и который частично будет
 *   изменён.
 * 
 * - ch — одиночный символ. По нему определяется
 *   граница префикса: функция ищет первое
 *   вхождение этого символа и включает его в
 *   переворачиваемый сегмент.
 * 
 * Возвращает 
 * - Cтрокa — либо исходная word, либо новая строка,
 *   в которой префикс от начала до первого
 *   вхождения ch (включая ch) перевёрнут.
 * 
 * 
 * Пример для:
 *   word = "abcdefd",
 *           ^^^^
 *   ch = "d"
 * Результат:
 *   "dcbaefd"
 *    ^^^^
 * Пояснение:
 *   Первое вхождение "d" находится на индексе 3.
 * 
 *   Переверните часть строки word с 0 по 3
 *   (включительно), в результате получается
 *   "dcbaefd".
 */
function reversePrefix(word, ch) {
  const n = word.length;

  // Инициализируем пустой массив prefixArr, в
  // который будем по одному добавлять символы 
  // префикса.
  // 
  // Используем массив вместо конкатенации строк
  // для лучшей производительности при
  // множественных добавлениях символов
  //
  // Этот массив затем можно будет развернуть
  // методом reverse и собрать обратно в строку
  const prefixArr = [];

  // Инициализируем переменную i нулём — она будет
  // индексом текущего символа в цикле
  let i = 0;

  // Запускаем цикл while, который проходит по
  // символам строки до тех пор, пока i < n.
  // 
  // Цикл останавливается либо при нахождении
  // символа ch (break), либо при достижении конца
  // строки.
  while (i < n) {

    // Считываем текущий символ строки word по
    // индексу i и сохраняем в переменную char.
    //
    // Это локальная переменная, удобная для
    // читаемости и повторного использования в
    // теле цикла.
    const char = word[i];

    // Добавляем текущий символ в конец массива
    // prefixArr
    // 
    // В результате после выхода из цикла
    // prefixArr будет содержать все символы от
    // начала строки до текущей позиции
    // включительно (если цикл прерван на
    // совпадении) или до конца строки
    prefixArr.push(char);

    // Сравниваем текущий символ с искомым ch.
    // 
    // Если они равны, значит мы нашли границу
    // префикса (включая этот символ) и можем
    // прекратить обход.
    // 
    // break прерывает цикл немедленно, оставляя
    // i указывать на индекс найденного символа.
    if (char === ch) break;

    // Если текущий символ не равен ch,
    // увеличиваем i и переходим к следующему
    // символу.
    //
    // Важно увеличивать индекс i после условия
    // if (char === ch) break, чтобы в случае,
    // кода ch является последним символом word,
    // i оставался меньше word.length (n), так
    // как дальше i используется для проверки
    // того, дошли ли мы до конца строки без
    // нахождения ch или нет: 
    // - Если мы дошли до конца строки
    //   (i === word.length) - значит символ ch
    //   в строке word не найдет 
    //
    // - Если i < word.length - значит символ ch
    //   найден на позиции i
    //
    // Такой подход позволяет не заводить
    // дополнительную переменную, которая указывает
    // на то, найден ch или нет
    i++;
  }

  // Возвращаем результат работы функции.
  // 
  // Используется тернарный оператор для двух случаев:
  // 1. Если i === n — цикл завершился потому, что
  //    достигнут конец строки и символ ch не найден.
  // 
  //    В этом случае нужно вернуть исходную строку
  //    без изменений.
  // 
  // 2. Иначе — символ ch найден на позиции i, и нужно
  //    вернуть строку, где префикс до i включительно
  //    перевёрнут, а остальная часть строки
  //    (начиная с i+1) добавлена без изменений.
  //
  // Если i равно n, возвращаем исходную строку word
  // — это покрывает случай отсутствия ch.
  //
  // Иначе переворачиваем массив prefixArr методом
  // reverse(), объединяем элементы в строку через
  // join(''), и конкатенируем с частью исходной
  // строки, начиная с позиции i+1 (то есть символы
  // после найденного ch), поскольку i в данный
  // момент указывает на найденный ch.
  // 
  // Если ch был последним символом, slice(i + 1)
  // возвращает пустую строку, что позволяет
  // вернуть только перевёрнутый префикс.
  return i === n
    ? word
    : prefixArr.reverse().join('') + word.slice(i + 1);
}
