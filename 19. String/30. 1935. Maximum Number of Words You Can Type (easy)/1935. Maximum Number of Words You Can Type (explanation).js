/**
 * @param {string} text
 * @param {string} brokenLetters
 * @return {number}
 * 
 * canBeTypedWords подсчитывает, сколько слов из заданной
 * строки text можно полностью напечатать, если некоторые
 * буквы клавиатуры «сломаны» и их использовать нельзя.
 * 
 * Функция предполагает, что слова разделены пробелами и
 * что используются строчные латинские буквы (a–z).
 * 
 * Параметры:
 * - text — строка. Содержит одно или несколько слов,
 *   разделённых пробелами.
 * 
 * - brokenLetters — строка. Содержит набор букв, которые
 *   считаются сломанными и которые нельзя использовать
 *   при наборе слов.
 * 
 * Пример для: 
 *   text = "hello world",
 *   brokenLetters = "ad"
 * Результат:
 *   1
 * Пояснение:
 *   Нельзя напечатать "world", потому что клавиша 'd'
 *   сломана.
 */
function canBeTypedWords(text, brokenLetters) {

  // Создаём массив фиксированной длины 26 для отметки
  // сломанных букв.
  //
  // Используем массив фиксированной длины 26 типа
  // Int32Array для компактного и быстрого хранения
  // флагов для каждой буквы английского алфавита
  // от 'a' до  'z':
  // индекс 0 соответствует 'a', индекс 1 — b, 25 — 'z'.
  //
  // Значение каждого элемента — числовая метка для
  // одной буквы латинского алфавита:
  // - 0 означает «буква не сломана»,
  // - 1 означает «буква сломана».
  //
  // Использование Int32Array даёт нулевое значение по
  // умолчанию, экономит память и даёт быстрый доступ
  // к значению по индексу.
  const charToBroken = new Int32Array(26);

  // Итерация по каждому символу в строке brokenLetters
  for (const char of brokenLetters) {

    // Получаем числовой код символа Unicode
    // (UTF-16/UTF-32), затем вычитаем код 'a' (97),
    // чтобы получить индекс в диапазоне 0–25 для
    // соответствующей буквы.
    // 
    // После этого в массиве charToBroken по этому
    // индексу ставим 1, означающее "эта буква сломана".
    // 
    // Если brokenLetters содержит повторяющиеся символы,
    // повторная запись 1 не изменит результат.
    charToBroken[char.codePointAt(0) - 97] = 1;
  }

  // Разбиваем входную строку text по символу
  // пробела ' ' на массив слов.
  const words = text.split(' ');

  // Инициализируем счётчик result, который будет
  // хранить количество слов, которые можно напечатать
  // без использования сломанных букв.
  let result = 0;

  // Проходим по каждому слову массива words.
  //
  // Метка outer: даёт возможность из вложенного цикла
  // немедленно перейти к следующей итерации внешнего
  // цикла (т.е. перейти к следующему слову), когда
  // обнаружена сломанная буква, чтобы не итерироваться
  // по каждой букве неподходящего слова до конца и не
  // увеличивать result
  outer: for (const word of words) {

    // Проходим по каждому символу текущего слова.
    for (const char of word) {

      // Для текущего символа вычисляем индекс в
      // массиве флагов аналогично тому, как делали для
      // brokenLetters.
      // 
      // Затем проверяем, помечена ли соответствующая
      // позиция как 1 (сломанная буква).
      if (charToBroken[char.codePointAt(0) - 97]) {

        // Если буква сломана, используем continue с
        // меткой outer, чтобы немедленно перейти к
        // следующему слову, пропуская оставшиеся
        // символы текущего слова и не увеличивая
        // счётчик result.
        continue outer;
      }
    }

    // Если внутренний цикл завершился без срабатывания
    // continue outer, значит в слове не найдено ни
    // одной сломанной буквы, и слово можно напечатать
    // — увеличиваем счётчик.
    result++;
  }

  // Возвращаем итоговое количество слов, которые можно
  // напечатать без использования сломанных букв.
  return result;
}
