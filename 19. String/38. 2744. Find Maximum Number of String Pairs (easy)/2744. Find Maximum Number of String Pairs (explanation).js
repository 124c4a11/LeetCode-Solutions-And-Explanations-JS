/**
 * @param {string[]} words
 * @return {number}
 * 
 * maximumNumberOfStringPairs принимает в качестве
 * параметра массив words, элементы которого представлены
 * в виде строк, состоящих из двух символов, и находит
 * максимальное количество пар строк в массиве words, где
 * одна строка является точной реверс‑версией другой.
 * 
 * Каждая строка участвует не более чем в одной паре.
 * 
 * 
 * Пример для:
 *   words = ["cd","ac","dc","ca","zz"]
 * Результат:
 *   2
 * Пояснение:
 * В этом примере можно составить 2 пары строк следующим
 * образом:
 * - Соединяем строку с индексом 0 и строку с индексом 2,
 *   так как реверс строки word[0] — "dc", и он равен
 *   words[2].
 * 
 * - Соединяем строку с индексом 1 и строку с индексом 3,
 *   так как реверс строки word[1] — "ca", и он равен
 *   words[3].
 * Можно доказать, что 2 — это максимальное количество пар,
 * которое можно составить.
 */
function maximumNumberOfStringPairs(words) {

  // Инициализация счётчика найденных пар.
  // 
  // Будет увеличиваться на 1 каждый раз, когда
  // обнаруживается взаимно обратная пара строк.
  let result = 0;

  // Создаём экземпляр Set для хранения строк, которые мы
  // ожидаем встретить позже.
  // 
  // В Set мы помещаем не исходные слова, а "перевёрнутые"
  // версии уже увиденных слов, чтобы при встрече
  // соответствия быстро определять наличие пары.
  const set = new Set();

  // Проходим по каждому элементу входного массива words.
  for (const word of words) {

    // Проверяем, содержится ли текущее слово в множестве
    // ожидаемых перевёрнутых строк.
    // 
    // Если да — это означает, что ранее мы добавили
    // перевёрнутую версию некоторого слова, и теперь
    // встретили её пару.
    if (set.has(word)) {

      // Удаляем текущее слово из множества, потому что
      // пара найдена и больше не должна использоваться
      // для формирования других пар (каждая строка может
      // входить только в одну пару).
      set.delete(word);

      // Увеличиваем счётчик найденных пар.
      result++;

      // Если текущее слово не найдено в множестве
      // ожидаемых перевёрнутых строк, то мы добавляем в
      // множество перевёрнутую версию текущего слова,
      // чтобы в будущем при встрече этой перевёрнутой
      // строки образовалась пара.
    } else {

      // Получаем перевернутую версию текущего слова
      // при помощи конкатенации его второго (word[1]) и
      // первого (word[0]) символов и добавляем полученное
      // слово в множество set
      //
      // Храним только те "ожидаемые" строки, которые ещё
      // не встретились, экономя память по сравнению с
      // хранением всех обработанных строк.
      set.add(word[1] + word[0]);
    }
  }

  // Возвращаем итоговое количество найденных пар.
  return result;
}
