/**
 * @param {string} s
 * @return {number}
 *
 * countPalindromicSubsequence принимает строку s, состоящую
 * только из строчных английских букв. И возвращает
 * количество уникальных палиндромов длины три, которые
 * являются подпоследовательностями строки s.
 *
 * Даже если одну и ту же подпоследовательность можно
 * получить несколькими способами, она учитывается только
 * один раз.
 *
 * Палиндром — это строка, которая читается одинаково слева
 * направо и справа налево.
 *
 * Подпоследовательность строки — это новая строка,
 * полученная из исходной удалением некоторых символов
 * (возможно, никаких) без изменения относительного порядка
 * оставшихся символов. Например "ace" это
 * подпоследовательность в "abcde".
 *                          ^ ^ ^
 *
 *
 * Пример для:
 *   s = "aabca"
 * Результат:
 *   3
 * Пояснение:
 * 3 палиндромические подпоследовательности длины 3:
 * - "aba" — подпоследовательность строки "aabca"
 *                                         ^ ^ ^
 * - "aaa" — подпоследовательность строки "aabca"
 *                                         ^^  ^
 * - "aca" — подпоследовательность строки "aabca"
 *                                         ^  ^^
 */
function countPalindromicSubsequence(s) {

  // Создаётся массив фиксированной длины 26 (по числу букв
  // латинского алфавита), в котором для каждой буквы будет
  // храниться индекс её первого появления в строке.
  //
  // Изначально все элементы равны -1, что означает "буква
  // ещё не встречалась".
  const charToFirstNdx = new Int32Array(26).fill(-1);

  // Аналогично создаём массив для хранения индексов
  // последнего вхождения каждой буквы.
  //
  // Изначально все значения -1, то есть буква не
  // встречалась.
  const charToLastNdx = new Int32Array(26).fill(-1);

  // Проходим по всем символам строки s
  //
  // Этот цикл собирает информацию о первом и последнем
  // вхождении каждой буквы.
  for (let i = 0; i < s.length; i++) {

    // Получаем числовой индекс буквы в диапазоне 0..25:
    // код символа минус код 'a' (97).
    //
    // 'a' → 0, 'b' → 1, ..., 'z' → 25
    const j = s.codePointAt(i) - 97;

    // Если буква встречается впервые (её первый индекс ещё
    // не записан), то фиксируем текущий индекс как первый.
    if (charToFirstNdx[j] === -1) {
      charToFirstNdx[j] = i;
    }

    // Независимо от того, первое это появление или нет,
    // обновляем последний индекс буквы на текущий.
    //
    // В итоге после прохода по строке здесь будет самый
    // правый индекс появления буквы.
    charToLastNdx[j] = i;
  }

  // Переменная для накопления общего количества уникальных
  // палиндромных подпоследовательностей.
  let result = 0;

  // Перебираем все 26 букв алфавита (индексы 0..25
  // соответствуют 'a'..'z').
  //
  // Для каждой буквы мы проверяем, можно ли с её помощью
  // образовать палиндром 'x?x'.
  for (let i = 0; i < 26; i++) {

    // Получаем первый индекс появления буквы i.
    const l = charToFirstNdx[i];

    // Получаем последний индекс появления той же буквы.
    const r = charToLastNdx[i];

    // Если буква не встречалась (l === -1) или встречалась
    // только один раз (l === r), то палиндром длиной 3 вида
    // X?X с этой буквой невозможен — пропускаем ее.
    if (l === -1 || l === r) continue;

    // Создаём множество для хранения всех уникальных символов,
    // которые находятся между первым и последним появлением
    // буквы.
    //
    // Каждый такой уникальный символ Y даст палиндром XYX.
    const innerCharsSet = new Set();

    // Перебираем все символы между l и r (не включая сами
    // границы).
    for (let j = l + 1; j < r; j++) {

      // Добавляем символ в множество.
      //
      // Если символ уже был, он не добавится повторно — это
      // обеспечивает уникальность.
      innerCharsSet.add(s[j]);
    }

    // Количество уникальных символов между l и r — это
    // количество палиндромов X?X для текущей буквы i.
    //
    // Добавляем это число к общему результату.
    result += innerCharsSet.size;
  }

  // Возвращаем итоговое количество уникальных палиндромных
  // подпоследовательностей длины 3.
  return result;
}
