/**
 * @param {string} rings
 * @return {number}
 * 
 * countPoints принимает один параметр rings — строку, где
 * каждые два символа описывают одно кольцо:
 * первый символ — цвет, второй — номер стержня и
 * подсчитывает, на скольких из 10 стержней (0–9) есть все
 * три цвета колец (обычно R, G, B).
 *
 * Параметры:
 *  - rings — строка. Каждые два символа в этой строке
 *    образуют пару:
 *      - первый символ — цвет кольца
 *        (например, 'R', 'G', 'B'),
 *
 *      - второй — номер стержня в виде символа '0'..'9'.
 * 
 *
 * Пример для:
 *   rings = "B0B6G0R6R0R6G9"
 * Результат:
 *   1
 * Пояснение:
 * - На стержне с меткой 0 находятся 3 кольца всех цветов:
 *   красное, зелёное и синее.
 * 
 * - На стержне с меткой 6 находятся 3 кольца, но там
 *   только красные и синие.
 * 
 * - На стержне с меткой 9 находится только одно зелёное
 *   кольцо.
 * Следовательно, количество стержней, на которых
 * присутствуют все три цвета, равно 1.
 */
function countPoints(rings) {

  // Создаём массив длины 10, соответствующий стержням с
  // индексами 0–9.
  // 
  // Для каждого элемента массива создаём новый Set —
  // структура данных, которая хранит только уникальные
  // значения.
  // 
  // Set будет содержать цвета колец, надетых на
  // соответствующий стержень.
  // 
  // Использование Set автоматически исключает дубликаты
  // одного цвета.
  //
  // В результате Set.size будет указывать на количество
  // уникальных цветов колец, которые надеты на этот
  // стержень.
  const rods = Array.from({ length: 10 }, () => new Set());

  // Проходим по строке rings парами символов:
  // - i указывает на позицию цвета,
  //
  // - i+1 — на позицию номера стержня.
  // 
  // Шаг i += 2 гарантирует, что мы читаем именно пары
  // (цвет, стержень) и не смешиваем символы между разными
  // кольцами.
  for (let i = 0; i < rings.length; i += 2) {

    // Берём символ цвета из текущей пары: rings[i].
    // 
    // Берём символ номера стержня из текущей пары:
    // rings[i + 1].
    // 
    // При обращении rods[rings[i + 1]] строковый символ
    // индекса автоматически используется как индекс
    // массива (происходит приведение '0'..'9' к числу).
    // 
    // Добавляем цвет в Set соответствующего стержня:
    // Set.add сохраняет только уникальные значения,
    // поэтому повторные одинаковые цвета на одном стержне
    // не увеличат размер множества.
    rods[rings[i + 1]].add(rings[i]);
  }

  // Инициализируем счётчик result, который будет хранить
  // количество стержней, на которых присутствуют все три
  // разных цвета.
  let result = 0;

  // Проходим по каждому элементу массива rods.
  // 
  // Каждый элемент — это Set, содержащий уникальные
  // цвета для данного стержня.
  for (const rod of rods) {

    // Проверяет размер множества rod.
    //
    // Свойство size у Set возвращает количество
    // уникальных элементов в множестве. 
    // 
    // Если на стержне оказалось ровно три уникальных
    // цвета ('R', 'G' и 'B'), значит этот стержень
    // удовлетворяет условию задачи - увеличиваем result
    // на 1. 
    if (rod.size === 3) result++;
  }

  // Возвращаем итоговое количество стержней, содержащих
  // три уникальных цвета.
  return result;
}
