/**
 * @param {string} s
 * @return {number[]}
 * 
 * diStringMatch принимает строку, состоящую из символов
 * 'I' и 'D', и строит перестановку чисел от 0 до s.length
 * такую, чтобы для каждого индекса i выполнялись
 * следующие условия:
 *   - если s[i] === 'I', то result[i] < result[i+1]
 * 
 *   - если s[i] === 'D', то result[i] > result[i+1]
 * 
 * 
 * Пример для:
 *   s = "IDID"
 * Результат:
 *   [0,4,1,3,2]
 */
function diStringMatch(s) {

  // Создаётся пустой массив result, в который будет
  // собираться итоговая перестановка чисел от 0 до
  // s.length.
  //
  // В результате функция вернёт массив длины
  // s.length + 1, удовлетворяющий шаблону 'I'/'D'.
  const result = [];

  // Инициализируем указатель на наименьшее доступное целое.
  // 
  // Изначально это 0.
  // 
  // lowest всегда указывает на минимальное ещё не
  // использованное число из диапазона [0, s.length]
  let lowest = 0;

  // Инициализируем указатель на наибольшее доступное целое.
  // 
  // Изначально равен длине строки s.
  // 
  // highest всегда указывает на максимальное ещё не
  // использованное число из диапазона [0, s.length]
  let highest = s.length;

  // Проходим по каждому символу входной строки s.
  // 
  // Для каждого символа мы решаем, добавить ли в результат
  // текущее минимальное или максимальное значение.
  for (const char of s) {

    // Если текущий символ — 'I', это означает, что
    // следующий элемент в результирующем массиве должен
    // быть больше текущего.
    // 
    // Чтобы обеспечить возрастание, мы помещаем на
    // текущей позиции минимально возможное оставшееся
    // число.
    if (char === 'I') {

      // Вставляем в результат текущее минимально доступное
      // число.
      // 
      // Это гарантирует, что последующее число может быть
      // больше текущего.
      result.push(lowest);

      // После использования этого минимального числа
      // увеличиваем lowest, чтобы оно больше не
      // использовалось.
      // 
      // Это сужает доступный диапазон чисел слева.
      lowest++;

      // Если символ не 'I', предполагается 'D' (decrease):
      // следующий элемент должен быть меньше предыдущего.
    } else {

      // В случае 'D' добавляем текущее максимальное
      // доступное число, чтобы обеспечить возможность
      // следующему элементу быть меньше текущего.
      result.push(highest);

      // После использования максимального числа уменьшаем
      // highest, чтобы оно больше не использовалось.
      // 
      // Это сужает доступный диапазон чисел справа.
      highest--;
    }
  }

  // После обработки всех символов строки у нас осталось
  // ровно одно неиспользованное число.
  // 
  // lowest и highest к этому моменту равны (поскольку на
  // каждой итерации мы либо инкрементировали lowest,
  // либо декрементировали highest).
  // 
  // Добавляем это оставшееся число в конец результата,
  // чтобы получить массив длины s.length + 1.
  result.push(lowest);

  // Возвращаем сформированный массив перестановки,
  // который удовлетворяет шаблону 'I'/'D'.
  // 
  // Для любой строки s из символов 'I' и 'D' возвращаемый
  // массив содержит все числа от 0 до s.length без
  // повторов
  return result;
}
