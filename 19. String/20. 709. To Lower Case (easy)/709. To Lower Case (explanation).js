/**
 * @param {string} s
 * @return {string}
 * 
 * toLowerCase принимает одну строку s и возвращает новую
 * строку, в которой все ASCII‑заглавные латинские буквы
 * A–Z заменены на соответствующие строчные. Остальные
 * символы остаются без изменений.
 * 
 * 
 * Пример для:
 *   s = "Hello"
 * Результат:
 *   "hello"
 */
function toLowerCase(s) {

  // Создаём пустой массив result, который будет
  // использоваться как буфер для накопления символов.
  // 
  // Массив выбран вместо конкатенации строк, чтобы
  // избежать квадратичной сложности при многократной
  // конкатенации строк.
  //
  // Многократная конкатенация строк в цикле обычно
  // имеет худшую практическую производительность и
  // может вести к O(n^2) по времени в худшем случае,
  // тогда как сбор в массив с последующим join даёт
  // линейную сложность O(n) и обычно быстрее и
  // экономичнее по памяти при больших объёмах данных.
  const result = [];

  // Итерация по каждому символу входной строки s
  for (const char of s) {

    // Получаем числовой код Unicode (code point) для
    // первого кода в символе char.
    const code = char.codePointAt(0);

    // Проверяет, находится ли числовой код в
    // диапазоне ASCII заглавных латинских букв
    // 'A'..'Z' (65..90).
    // 
    // Это условие ограничено только латиницей в
    // базовом ASCII и не затрагивает другие алфавиты
    // или локали.
    if (code >= 65 && code <= 90) {

      // Если символ — заглавная латинская буква,
      // преобразуем её в строчную, прибавив 32 к коду,
      // и добавляем ее в result
      // 
      // В Unicode для латинских букв разница между
      // заглавной и строчной буквой равна 32
      // (например, 'A' 65 → 'a' 97), поэтому это
      // корректно для A–Z.
      // 
      // String.fromCodePoint создаёт символ из
      // указанного code point. 
      result.push(String.fromCodePoint(code + 32));
    } else {

      // Для всех остальных символов (строчные
      // латинские, цифры, знаки пунктуации, символы
      // других алфавитов, эмодзи и т.д.) мы сохраняем
      // исходный символ без изменений, тем самым
      // функция является нейтральной к символам вне
      // A–Z.
      result.push(char);
    }
  }

  // После обработки всех символов объединяем элементы
  // массива в одну строку с помощью join('').
  //
  // Это даёт итоговую строку.
  // 
  // Пустая строка в качестве разделителя означает, что
  // элементы соединяются без дополнительных символов.
  // 
  // Сложность операции линейна по суммарной длине
  // массива.
  // 
  // Возвращаем полученную строку как результат функции.
  return result.join('');
}
