/**
 * @param {string} s
 * @return {boolean}
 * 
 * areOccurrencesEqual принимает строку s и возвращает
 * true, если s — хорошая строка, иначе вернуть false.
 * 
 * Строка s считается хорошей, если все символы, которые
 * в ней встречаются, имеют одинаковое число вхождений,
 * то есть одинаковую частоту.
 * 
 * 
 * Пример для:
 *   s = "abacbc"
 * Результат:
 *   true
 * Пояснение:
 *   В строке s встречаются символы 'a', 'b' и 'c'.
 *   Все символы встречаются по 2 раза.
 * 
 * 
 * Пример для:
 *   s = "aaabb"
 * Вывод:
 *   false
 * Пояснение:
 *   В строке s встречаются символы 'a' и 'b'.  
 *   'a' встречается 3 раза, а 'b' — 2 раза, что не
 *   совпадает по количеству вхождений.
 */
function areOccurrencesEqual(s) {

  // Создаём типизированный массив Int32Array длиной 26
  // для хранения частот букв 'a'..'z'.
  //
  // Индекс 0 соответствует 'a', 25 — 'z'.
  // 
  // По умолчанию все значения инициализированы нулями.
  const charToFreq = new Int32Array(26);

  // Инициализация переменной для хранения максимальной
  // частоты среди уже обработанных символов.
  // 
  // Используется для последующей проверки:
  // все ненулевые частоты должны быть равны этому
  // значению.
  let maxFreq = 0;

  // Итерация по каждому символу строки s
  for (const char of s) {

    // Получаем числовой код символа (UTF-16/Unicode)
    // и вычитаем 97 (код 'a'), чтобы получить индекс
    // в диапазоне 0..25 для букв 'a'..'z'.
    const i = char.codePointAt(0) - 97;

    // Увеличиваем счётчик для буквы с индексом i.
    charToFreq[i]++;

    // Обновляем максимальную частоту:
    // 
    // Сравниваем текущее значение maxFreq и  только
    // что увеличенную частоту для текущего символа,
    // выбирая большее.
    // 
    // Это позволяет в одном проходе поддерживать
    // актуальное значение максимума.
    maxFreq = Math.max(maxFreq, charToFreq[i]);
  }

  // Второй цикл проходит по всем 26 элементам массива
  // частот.
  // 
  // Здесь мы проверяем, что каждая встречающаяся буква
  // имеет частоту, равную maxFreq.
  for (const freq of charToFreq) {

    // Если частота равна 0, значит соответствующая
    // буква в строке не встречалась, и её не нужно
    // учитывать при сравнении частот.
    if (!freq) continue;

    // Если найдена ненулевая частота, отличная от
    // maxFreq, значит не все встречающиеся символы
    // имеют одинаковую частоту — функция может сразу
    // вернуть false.
    if (freq !== maxFreq) return false;
  }

  // Если цикл завершился без возврата false, значит
  // все ненулевые частоты равны maxFreq,
  // следовательно, все встречающиеся символы имеют
  // одинаковое количество вхождений — возвращаем true.
  return true;
}
