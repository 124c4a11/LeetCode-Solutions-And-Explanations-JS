/**
 * @param {string} s
 * @return {string}
 * 
 * sortSentence принимает одну строку s, в которой каждое
 * слово в качестве последнего символа содержит цифру
 * от 1 до 9, обозначающую позицию этого слова в итоговой
 * фразе, и возвращает новую строку, где слова
 * переставлены в соответствии с этими цифрами. 
 * 
 * 
 * Пример для:
 *   s = "is2 sentence4 This1 a3"
 * Результат:
 *   "This is a sentence"
 * Пояснение:
 *   Отсортируйте слова в s в их исходные позиции
 *   "This1 is2 a3 sentence4", затем удалите цифры.
 */
function sortSentence(s) {

  // Создаём пустой массив result, который будет
  // использоваться как контейнер для слов в их
  // правильных позициях.
  // 
  // Индексы массива соответствуют позициям слов минус
  // один (позиция 1 → индекс 0)
  const result = [];

  // Создаём временный массив wordArr для поочерёдного
  // накопления символов текущего слова. 
  //
  // Такой подход позволит собирать слово из нужных
  // символов за один проход строки.
  // 
  // Массив выбран вместо конкатенации строк, чтобы
  // избежать квадратичной сложности при многократной
  // конкатенации строк в цикле.
  //
  // Многократная конкатенация строк в цикле обычно
  // имеет худшую практическую производительность и
  // может вести к O(n^2) по времени в худшем случае,
  // тогда как сбор в массив с последующим join даёт
  // линейную сложность O(n) и обычно быстрее и
  // экономичнее по памяти при больших объёмах данных.
  const wordArr = [];

  // Инициализируем счётчик i, который будет индексом
  // текущего символа в строке s.
  // 
  // Используется цикл while с явным индексом, чтобы
  // обрабатывать строку посимвольно и пропускать
  // цифру и пробел одновременно по необходимости.
  //
  // Такой подход позволяет пропустить итерации
  // указывающие на пробел, тем самым устраняя
  // необходимость дополнительной проверки на каждом
  // шаге цикла, что повышает производительность
  let i = 0;

  // Запускаем цикл, который проходит по всем символам
  // строки s от начала до конца.
  while (i < s.length) {

    // Берём текущий символ строки s по индексу i.
    const char = s[i];

    // Проверяем, является ли текущий символ числом.
    //
    // isNaN(char) возвращает false для строк, которые
    // можно преобразовать в число (например, '1'),
    // поэтому !isNaN(char) истинно, когда char — цифра.
    // 
    // Это простая проверка для однозначных цифровых
    // символов.
    if (!isNaN(char)) {

      // Если встретили цифру, это означает конец
      // текущего слова и указание его позиции.
      // 
      // Преобразуем символ-цифру в числовой индекс:
      // char - 1 (позиция в строке начинается с 1, а
      // индекс массива — с 0).
      //
      // Выражение char - 1 выполняет неявное приведение
      // char к числу и сдвигает индекс на 0-основание
      // (номер 1 → индекс 0).
      //
      // Затем помещаем собранное слово (объединённые
      // символы из wordArr) в соответствующую ячейку
      // result.
      result[char - 1] = wordArr.join('');

      // Быстрая очистка массива wordArr путём установки
      // его длины в 0, чтобы переиспользовать тот же
      // массив для следующего слова без выделения новой
      // памяти
      wordArr.length = 0;

      // Увеличение i на 2:
      //
      // Формат строки s предполагает, что после цифры
      // идёт пробел, поэтому пропускаеm и саму цифру
      // (текущий символ) и следующий пробел.
      // 
      // Такой подход позволяет пропустить итерации
      // указывающие на пробел, тем самым устраняя
      // необходимость дополнительной проверки на каждом
      // шаге цикла, что повышает производительность
      i += 2;

      // Переход к следующей итерации цикла, чтобы не
      // выполнять код, предназначенный для обычных
      // (нечисловых) символов.
      continue;
    }

    // Если текущий символ не распознан как цифра,
    // добавляем его в массив wordArr — таким образом
    // формируется текущее слово посимвольно.
    wordArr.push(char);

    // Переходим к следующему символу строки,
    // увеличивая индекс на 1.
    i++;
  }

  // После прохода по всей строке объединяем элементы
  // массива result в одну строку, разделяя слова одним
  // пробелом, и возвращаем итоговую отсортированную
  // фразу
  return result.join(' ');
}
