/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     constructor(val = 0, left = null, right = null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */


/**
 * @param {TreeNode} root
 * @return {number}
 * 
 * Функция rob принимает на вход корень
 * бинарного дерева и возвращает
 * максимальную сумму  
 * значений «ограбленных» узлов при
 * условии, что нельзя ограбить два
 * соседних узла.
 * 
 * Правило «не грабить два соседних узла»
 * запрещает одновременно брать родителя
 * и одного из его прямых детей.
 * 
 * Пример использования:  
 * для дерева   
 * 
 *        3*  
 *       / \  
 *      2   3  
 *       \   \  
 *        3*  1* 
 * 
 * rob(root) вернёт 7 (сумма 3 + 3 + 1).
 */
function rob(root) {

  // Вспомогательная рекурсивная функция
  // dfs выполняет обход дерева и для
  // каждого узла выдаёт пару значений:
  // [withRoot, withoutRoot], где
  // withRoot    — максимальная сумма,
  //               если текущий узел
  //               ограблен,
  // withoutRoot — максимальная сумма,
  //               если текущий узел не
  //               ограблен.
  // node по умолчанию равен корню при
  // первом вызове.
  //
  // Для примера дерева
  //        3  
  //       / \  
  //      2   3  
  //       \   \  
  //        3   1  
  // шаги:
  // dfs(3-left-right) → [3, 0]
  // dfs(1) → [1, 0]
  // dfs(2) → [2, 3]
  // dfs(3-right) → [3, 1]
  //
  //             3
  //            / \  
  //   [2, 3]  2   3  [3, 1]
  //            \   \  
  //     [3, 0]  3   1   [1, 0]
  //
  // dfs(root=3) → 
  // withRoot = 
  // 3 + 3 (без левого) + 1 (без правого) = 7
  //        3*  
  //       / \  
  //      2   3  
  //       \   \  
  //        3*  1* 
  //
  // withoutRoot =
  // max(2,3) + max(3,1) = 3 + 3 = 6
  //        3  
  //       / \  
  //      2   3*  
  //       \   \  
  //        3*  1 
  //
  // итоговая пара dfs(root) = [7, 6],
  //
  //             3 [7, 6]  
  //            / \  
  //   [2, 3]  2   3  [3, 1]
  //            \   \  
  //     [3, 0]  3   1   [1, 0]
  //
  // значит rob(root) = 7
  function dfs(node = root) {

    // Базовый случай: если узел
    // отсутствует, нельзя ограбить
    // или пропустить что-либо,
    // возвращаем [0, 0].
    //
    // Пример:
    // dfs(null) всегда возвращает 
    // [0, 0].
    if (!node) return [0, 0];

    // Рекурсивно обходим левое поддерево.
    //
    // Для узла со значением 2
    // (левый ребёнок корня)
    // вызов dfs(node.left)
    // вернёт [2, 3].
    //
    //             3
    //            / \  
    //   [2, 3]  2   3
    //            \   \  
    //     [3, 0]  3   1
    //
    const leftPair = dfs(node.left);

    // Рекурсивно обходим правое поддерево.
    //
    // Для узла со значением 3
    // (правый ребёнок корня)
    // вызов dfs(node.right)
    // вернёт [3, 1].
    //
    //             3
    //            / \  
    //   [2, 3]  2   3  [3, 1]
    //            \   \  
    //     [3, 0]  3   1   [1, 0]
    //
    const rightPair = dfs(node.right);

    // Считаем вариант, когда текущий узел
    // ограблен:
    // его собственное значение плюс
    // варианты «не ограблен» у обоих детей.
    //
    // Пример:
    // node.val (root) = 3,
    // leftPair = [2, 3], rightPair = [3, 1]  
    // withRoot = 
    // 3 + 3 (без левого) + 1 (без правого) = 7
    //
    //            3*  
    //           / \  
    //  [2, 3]  2   3  [3, 1] 
    //           \   \  
    //    [3, 0]  3*  1*  [1, 0]
    //
    const withRoot =
      node.val + leftPair[1] + rightPair[1];

    // Считаем вариант, когда текущий
    // узел пропущен:
    // для каждого ребёнка выбираем
    // максимальную из двух возможностей
    // (ограбить или нет).
    //
    // Пример:
    // leftPair = [2, 3] → max = 3,
    // rightPair = [3, 1] → max = 3  
    // withoutRoot = 3 + 3 = 6
    //
    //            3   
    //           / \  
    //  [2, 3]  2   3*  [3, 1]  
    //           \   \  
    //    [3, 0]  3*  1  [1, 0]       
    //
    // Почему возможно суммировать 3 + 3:
    //
    // Вот в чём ключевой момент: правило
    // «не грабить два соседних узла»
    // запрещает одновременно брать
    // родителя и одного из его прямых детей.
    // Если же родитель не ограблен, его
    // дети (или внуки) могут
    // быть ограблены независимо друг от
    // друга.
    //
    // 1. Мы считаем  
    //    withoutRoot = 
    //    max(2, 3) + max(3, 1) = 3 + 3 = 6  
    //
    //    где  
    //    - max(2, 3)=3 — это выбор «ограбить»
    //      внука левой ветви 
    //      (узел со значением 3),
    //      а не самого ребёнка
    //      (со значением 2).  
    //    - max(3, 1)=3 — это выбор «ограбить»
    //      ребёнка правой ветви
    //      (узел со значением 3),
    //      а не его внука (со значением 1).  
    //
    // 2. Почему это не нарушает правило соседства?  
    //    - Мы не ограбили корень
    //      (root со значением 3), значит мы
    //      свободны грабить его детей и внуков.  
    //    - Узел 3 в левой ветви — это внук корня,
    //      у него нет прямого ребра с корнем.  
    //    - Узел 3 в правой ветви — это прямой
    //      ребёнок корня, но корень не ограблен.  
    //    - Между левым внуком и правым ребёнком
    //      корня вообще нет прямого соединяющего
    //      ребра, значит они не «соседи».  
    //
    // Итог: оба узла, которые дают по 3, не связаны
    // ребром между собой и ни один из них не грабит
    // корень, поэтому их суммы можно просто сложить.
    const withoutRoot =
      Math.max(...leftPair) + Math.max(...rightPair);

    // Возвращаем пару 
    // [с учётом ограбления текущего узла, без учёта].
    //
    // Пример для root 3:
    // возвращается [7, 6].
    //
    //             3 [7, 6]  
    //            / \  
    //   [2, 3]  2   3  [3, 1]
    //            \   \  
    //     [3, 0]  3   1   [1, 0]
    //
    return [withRoot, withoutRoot];
  };

  // Запускаем dfs от корня и выбираем
  // лучший из двух вариантов для корня.
  //
  // итоговая пара dfs(root) = [7, 6],
  //
  //             3 [7, 6]  
  //            / \  
  //   [2, 3]  2   3  [3, 1]
  //            \   \  
  //     [3, 0]  3   1   [1, 0]
  //
  // значит rob(root) = 7
  return Math.max(...dfs());
}
