/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     constructor(val = 0, left = null, right = null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 * 
 * Функция insertIntoBST вставляет значение val так,
 * чтобы дерево оставалось корректным BST.
 * 
 * Признаки корректного BST
 * 
 * Корректное бинарное дерево поиска (BST) — это такая
 * структура, где для каждого узла сохраняются
 * определённые отношения между значением самого узла
 * и значениями узлов в его поддеревьях.
 *
 * Основные свойства
 * 
 * - Для любого узла node все элементы в левом
 *   поддереве имеют значение меньше, чем node.val.  
 * - Для любого узла node все элементы в правом
 *   поддереве имеют значение больше, чем node.val.  
 * - Это правило применяется рекурсивно ко всем узлам
 *   во всём дереве, гарантируя глобальный порядок.
 */
function insertIntoBST(root, val) {

  // Создаём новый узел с переданным значением
  const node = new TreeNode(val);

  // Если дерево пустое (root равно null),
  // новый узел становится корнем.
  if (!root) return node;

  // Устанавливаем указатель curr
  // на начало — корень дерева
  // curr будет перемещаться по дереву,
  // пока не найдёт место для вставки
  let curr = root;

  // Выполняет цикл до тех пор, пока не встретит
  // оператор return.
  //
  // Используем цикл вместо рекурсии, чтобы избежать
  // переполнения стека.
  //
  // Использование `while (true)` здесь 
  // — преднамерённый приём для организаци
  // и бесконечного цикла поиска
  // места вставки  и выхода из него только тогда,
  // когда новое значение реально вставлено.
  // Вот детальный разбор «почему так»
  // и «как это работает»:
  //
  // 1. Гарантия выхода  
  // - В данном методе мы заранее знаем,
  //   что в какой-то момент — при спуске по дереву
  //   — мы обязательно найдём пустую ветку 
  //   (либо left, либо right), куда можно вставить
  //   новый узел.
  // - Цикл while (true) означает «продолжай спуск
  //   до тех пор, пока не вставишь узел», а выход
  //   из цикла происходит через return сразу после
  //   установки ссылки на новый узел. 
  //
  // 2. Чистота и простота кода  
  // — Не нужно комбинировать несколько логических
  //   условий в заголовке while (например,
  //   while (curr) или while (!inserted)),
  //   что делает код громоздким.  
  // — Вся логика движений (влево/вправо) и проверки
  //   вставки сосредоточена внутри одного цикла без
  //   внешних флагов.  
  while (true) {

    // Если значение текущего узла больше
    // вставляемого — нужно идти в левое поддерево
    if (curr.val > val) {

      // Если в левом поддереве нет узла,
      // вставляем новый узел слева
      if (!curr.left) {
        curr.left = node;
        return root;
      }

      // Иначе спускаемся ниже по левому поддереву
      // и повторяем проверку
      curr = curr.left;

      // Если вставляемое значение не меньше
      // текущего — переходим в правое поддерево
    } else {

      // Если правого потомка нет, создаём связь
      // curr.right = node и возвращаем исходный
      // корень
      if (!curr.right) {
        curr.right = node;
        return root;
      }

      // Иначе спускаемся ниже по правому поддереву
      // и повторяем сравнение
      curr = curr.right;
    }
  }
}
