/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     constructor(val = 0, left = null, right = null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

/**
 * @param {TreeNode} root
 * @return {number[]}
 * 
 * inorderTraversal выполняет обход
 * бинарного дерева в порядке inorder
 * «лево → корень → право»
 * Принимает на вход root — корень дерева.
 * 
 * Например, для дерева:
 *     1
 *    / \
 *   2   3
 * результат будет [2, 1, 3]
 */
function inorderTraversal(root) {

  // result накапливает значения узлов
  // в порядке inorder
  //
  // Начальное состояние: result = []
  const result = [];


  // stack симулирует стек вызовов
  // рекурсии, чтобы запомнить узлы
  // для возврата
  //
  // Начальное состояние: stack = []
  const stack = [];

  // curr указывает на текущий узел,
  // стартует с корня (значение 1)
  //
  // curr = root (1)
  let curr = root;

  // Основной цикл: выполняем,
  // пока есть текущий узел
  // или в стеке остались
  // отложенные узлы
  //
  // старт: curr = 1, stack = []
  while (curr || stack.length) {

    // Внутренний цикл: спускаемся
    // в самое левое поддерево.
    //
    // Цикл заполняет стек узлами по
    // левой «ветке» от текущего
    // положения до самого глубокого
    // левого потомка.
    //
    // Итерация 1: 
    //   curr = 1,
    //   кладем в stack → stack = [1],
    //   curr = 1.left = 2
    // Итерация 2:
    //   curr = 2,
    //   кладем в stack → stack = [1, 2],
    //   curr = 2.left = null
    while (curr) {

      // Сохраняем текущий узел в стеке
      // перед спуском влево
      stack.push(curr);

      // Переходим к левому потомку
      curr = curr.left;
    }

    // Здесь curr == null, значит больше
    // нет левого поддерева, извлекаем
    // из стека последний отложенный узел
    //
    // stack = [1, 2] → pop → curr = 2,
    // stack = [1]
    curr = stack.pop();

    // Добавляем значение узла в result
    // после обработки его левого поддерева
    //
    // result = [] → push(2) → result = [2]
    result.push(curr.val);

    // Переходим к правому поддереву
    // этого узла
    //
    // Пример:
    // у узла 2 правого поддерева
    // нет, curr = null
    curr = curr.right;

    // возвращаемся в основной цикл:
    // curr = null, 
    // но stack = [1] → извлечем 1,
    // добавим 1 → result = [2,1],
    // curr = 1.right = 3
    // затем аналогично обработаем
    // узел 3 → result = [2,1,3]
  }

  // Все узлы обработаны: возвращаем массив
  // значений в порядке inorder
  //
  // Пример:
  // по завершении result = [2, 1, 3]
  return result;
}
