/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     constructor(val = 0, left = null, right = null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 * 
 * deleteNode удаляет узел со значением key
 * из двоичного дерева поиска (BST)
 */
function deleteNode(root, key) {

  // Базовый случай рекурсии: если текущий
  // узел отсутствует, возвращаем null.
  //
  // Пример:
  // удаляем из пустого дерева null
  // deleteNode(null, 5) → null
  if (!root) return root;

  // Если значение текущего узла больше key,
  // искомый узел лежит в левом поддереве.
  //
  // Пример: в дереве
  //      5
  //     / \
  //    3   8
  // ищем key = 3, 5 > 3, спускаемся налево
  if (root.val > key) {
    // Рекурсивно удаляем в левом поддереве
    // и обновляем ссылку root.left.
    //
    // После удаления 3 из
    //      5
    //     / \
    //    3*  8
    // дерево станет просто
    //      5
    //       \
    //        8
    root.left = deleteNode(root.left, key);

    // Если значение текущего узла меньше
    // key, узел лежит в правом поддереве.
    //
    // Пример:
    // в том же дереве ищем key = 8, 5 < 8,
    // спускаемся вправо
  } else if (root.val < key) {
    // Рекурсивно удаляем в правом поддереве
    // и обновляем ссылку root.right.
    //
    // После удаления 8 из
    //      5
    //     / \
    //    3   8*
    // дерево станет просто
    //      5
    //     / 
    //    3 
    root.right = deleteNode(root.right, key);

    // Иначе root.val === key:
    // нашли узел, который нужно удалить
  } else {
    // Случай 1: у узла нет левого потомка
    // — возвращаем правый 
    // (подъём правого поддерева).
    //
    // Пример:
    //    3
    //     \
    //      4
    // удаляем 3 → возвращается поддерево
    //    4
    if (!root.left) return root.right;

    // Случай 2: у узла нет правого потомка
    // — возвращаем левый
    // (подъём левого поддерева).
    //
    // Пример:
    //    3
    //   /
    //  2
    // удаляем 3 → возвращается поддерево
    //    2
    if (!root.right) return root.left;

    // Случай 3: оба потомка присутствуют
    // — найдём преемника
    // (минимальный узел в правом поддереве).
    //
    // Пример: удаляем 5 из
    //      5
    //     / \
    //    3   8
    //       / \
    //      7   9
    let curr = root.right;

    // Идём по левым ссылкам до самого
    // левого узла в правом поддереве
    // (значение 7).
    //
    // curr = 8 → 
    // curr.left = 7 →
    // curr = 7 →
    // curr.left = null → остановка
    while (curr.left) curr = curr.left;

    // Скопируем значение преемника (7)
    // в текущий узел вместо удаляемого (5).
    //
    // Получаем дерево
    //      7
    //     / \
    //    3   8
    //       / \
    //      7*  9
    root.val = curr.val;

    // Удаляем дубликат
    // (узел-преемник со старым значением 7)
    // из правого поддерева.
    //
    // После удаления 7* из поддерева 8
    // результат:
    //      7
    //     / \
    //    3   8
    //         \
    //          9
    root.right = deleteNode(root.right, root.val);
  }

  // Возвращаем корень 
  // (возможно изменённого) поддерева.
  return root;
}
