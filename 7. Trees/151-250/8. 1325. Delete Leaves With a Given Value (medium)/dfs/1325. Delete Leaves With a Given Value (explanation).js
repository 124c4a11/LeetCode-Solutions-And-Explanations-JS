/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     constructor(val = 0, left = null, right = null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */


/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {TreeNode}
 * 
 * Метод removeLeafNodes принимает два аргумента:
 * root — ссылка на корень (или текущий узел)
 *        двоичного дерева
 * target — значение, которое мы хотим удалить
 *          в листьях дерева
 * 
 * Пример вызова:
 *   Для дерева  
 * 
 *       1  
 *      / \  
 *     2   3  
 *    /   / \  
 *   2   2   4  
 * 
 * и target = 2  
 * этот метод удалит все листовые узлы
 * со значением 2
 * 
 * Результат:
 * 
 *       1  
 *        \  
 *         3  
 *          \  
 *           4  
 * 
 */
function removeLeafNodes(root, target) {

  // Проверяем, не достигли ли мы
  // конца ветки.
  // Если root == null, значит нет
  // больше узлов — возвращаем null.
  if (!root) return null;

  // Рекурсивно спускаемся в левое
  // поддерево и присваиваем
  // результат обратно в root.left.
  // Если в левом поддереве найдутся
  // листья со значением target,
  // они будут удалены.
  //
  // Пример: 
  // при root.val = 1,
  // root.left.val = 2,
  // target = 2
  //
  //       1  
  //      / \  
  //     2*  3  
  //    /   / \  
  //   2   2   4
  //
  // после этой строки левое поддерево
  // превратиться в
  //
  //       1  
  //      / \  
  //     2*  3  
  //        / \  
  //       2   4
  //
  root.left = removeLeafNodes(root.left, target);

  // Аналогично обрабатываем правое
  // поддерево.

  // Пример:
  // при root.val = 1,
  // root.right.val = 3,
  // target = 2
  //
  //       1  
  //      / \  
  //     2   3*  
  //        / \  
  //       2   4
  //
  // после этой строки правое
  // поддерево превратиться в
  //
  //       1  
  //      / \  
  //     2   3*  
  //          \  
  //           4
  //
  root.right = removeLeafNodes(root.right, target);

  // Теперь, когда поддеревья
  // обработаны, проверяем:
  // 1. Нет ли у текущего узла больше
  //    ни левого, ни правого потомка
  // 2. Совпадает ли его значение с
  //    target
  // Если оба условия выполняются,
  // считаем его листом, который нужно
  // удалить.
  //
  // В таком случае возвращаем null,
  // что «отвяжет» узел от родителя.
  //
  // Пример:
  // при root.val = 1,
  // root.left.val = 2,
  // target = 2
  //
  //       1  
  //      / \  
  //     2*  3  
  //          \  
  //           4
  //
  // 1. У узла 2* нет потомков
  // 2. Его значение равно target
  //    2* === 2 (target)
  // → удаляем
  //
  //       1  
  //        \  
  //         3  
  //          \  
  //           4
  //
  // при root.val = 1,
  // root.right.val = 3,
  // target = 2
  //
  //       1  
  //        \  
  //         3*  
  //          \  
  //           4
  //
  // 1. У узла 3* есть потомки
  // 2. Его значение не равно target
  //    3* !== 2 (target)
  // → оставляем
  //
  // Результат:
  //
  //       1  
  //        \  
  //         3
  //          \  
  //           4
  //
  if (
    !root.left
    && !root.right
    && root.val === target
  ) return null;

  // Если текущий узел не был удалён,
  // возвращаем его,
  // сохраняя (возможно изменённые)
  // ссылки на детей.
  // Это позволяет корректно «восстановить»
  // обновлённое дерево наверх по рекурсии.
  return root;
}
