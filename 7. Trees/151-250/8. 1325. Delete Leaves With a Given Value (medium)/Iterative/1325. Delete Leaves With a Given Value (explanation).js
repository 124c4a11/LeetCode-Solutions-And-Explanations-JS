/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     constructor(val = 0, left = null, right = null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */


/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {TreeNode}
 * 
 * Метод removeLeafNodes принимает два аргумента:
 * root — ссылка на корень (или текущий узел)
 *        двоичного дерева
 * target — значение, которое мы хотим удалить
 *          в листьях дерева
 * 
 * Пример вызова:
 *   Для дерева  
 * 
 *       1  
 *      / \  
 *     2   3  
 *    /   / \  
 *   2   2   4  
 * 
 * и target = 2  
 * этот метод удалит все листовые узлы
 * со значением 2
 * 
 * Результат:
 * 
 *       1  
 *        \  
 *         3  
 *          \  
 *           4  
 *
 */
function removeLeafNodes(root, target) {

  // Если передан пустой узел,
  // возвращаем null.
  //
  // В нашем примере root = 1,
  // поэтому условие ложно.
  if (!root) return null;

  // Стек для хранения узлов при обходе.
  const stack = [];

  // Переменная visited указывает на
  // последний полностью обработанный узел.
  let visited = null;

  // Текущий узел, с которого начинается
  // обход (изначально корень).
  //
  //        1*
  //       / \
  //      2   3
  //     /   / \
  //    2   2   4
  //
  let curr = root;

  // Шаг 0: перед началом обхода
  //
  // Стек: []
  // visited: null
  // Дерево:
  //
  //        1*
  //       / \
  //      2   3
  //     /   / \
  //    2   2   4
  //

  // Основной цикл: продолжаем,
  // пока есть текущий узел или стек
  // не пуст.
  while (curr || stack.length) {

    // Спускаемся по левым потомкам,
    // пока можем, сохраняя путь в стеке.
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }

    // Шаг 1: достигнут левый край —
    // curr === null
    // Стек хранит путь к самому левому
    // узлу
    //
    // Стек: [1, 2, 2]
    // visited: null
    //
    // Дерево пока без изменений:
    //
    //          1
    //         / \
    //        2   3
    //       /   / \
    //      2   2   4
    //     /
    //  null*
    //

    // Смотрим на узел сверху стека,
    // но пока не извлекаем его.
    //
    // Стек: [1, 2, 2*]
    // visited: null
    //
    //          1
    //         / \
    //        2   3
    //       /   / \
    //      2*  2   4
    //
    curr = stack.at(-1);

    // Если есть правый потомок,
    // который ещё не был посещён,
    // переключаемся на него
    // (обход правых поддеревьев).
    if (
      curr.right
      && curr.right !== visited
    ) {
      curr = curr.right;
      continue;
    }

    // Мы вызываем stack.pop(),
    // чтобы убрать из стека текущий
    // узел после того, как мы завершили
    // его пост-order обработку.
    //
    // Когда мы говорим, что для узла
    // выполнена пост-order обработка,
    // это означает, что над ним
    // произведены все три шага алгоритма:
    //
    // - сначала полностью обработано
    //   (или удалено) его левое поддерево,  
    // - затем полностью обработано
    //   (или удалено) его правое поддерево,  
    // - после чего выполнена собственная
    //   работа над самим узлом
    //   (в нашем случае — проверка на
    //   "лист с целевым значением" и
    //   возможное удаление).  
    //
    // Только после этих действий узел
    // считается "обработанным" в пост-order
    // обходе.
    //
    // После внутреннего прохода по левому
    // и правому потомкам (или если их нет)
    // этот узел больше не нужен в стеке.
    // Благодаря pop() в вершине стека
    // (stack.at(-1)) окажется его родитель,
    // что позволяет:
    // 1. Правильно перейти к обработке
    //    следующего узла в пост-order обходе.
    // 2. При удалении листа
    //    (curr.val === target) сразу иметь
    //    под рукой ссылку на родительский
    //    узел для обнуления соответствующего
    //    указателя parent.left
    //    или parent.right.
    // Если бы мы не удаляли узел из стека,
    // стек накапливал бы уже полностью
    // обработанные узлы, и логика обхода
    // и удаления ломалась бы.
    //
    // Стек: [1, 2]
    // visited: null
    stack.pop();

    // Шаг 2: обрабатываем узел 2 
    // (левый крайний лист)
    // curr = 2 (leaf, val===target)
    //
    // Стек: [1, 2]
    // visited: null
    //
    // До удаления:
    //
    //        1
    //       / \
    //      2   3
    //     /   / \
    //    2*  2   4
    //
    // После удаления:
    //
    //        1
    //       / \
    //      2   3
    //         / \
    //        2   4
    //
    //
    // Блок удаления:
    // если curr — лист с целевым значением,
    // удаляем его через родителей.
    if (
      !curr.left
      && !curr.right
      && curr.val === target
    ) {

      // Если это был единственный узел
      // в дереве, возвращаем null.
      if (!stack.length) return null;

      // Иначе находим родителя
      // на вершине стека.
      //
      // Стек: [1, 2^]
      // visited: null
      //
      // До удаления:
      //
      //            1
      //           / \
      //   parent 2^  3
      //         /   / \
      //   curr 2*  2   4
      //
      const parent = stack.at(-1);

      // Если curr — левый ребёнок,
      // обнуляем parent.left,
      //
      // После удаления:
      //
      //            1
      //           / \
      //   parent 2^  3
      //             / \
      //            2   4
      //
      // иначе обнуляем parent.right.
      if (parent.left === curr) {
        parent.left = null;
      } else if (parent.right === curr) {
        parent.right = null;
      }

      // Шаг 3: удаление первого листа 2
      //
      // Стек: [1, 2]
      // visited: null
      //
      // Дерево после удаления:
      //        1
      //       / \
      //      2   3
      //         / \
      //        2   4
      //
    } else {

      // Если узел не удаляется,
      // помечаем его как посещённый,
      // чтобы при возврате к нему
      // не повторять обход.
      visited = curr;
    }

    // Сбрасываем curr, чтобы продолжить
    // обработку оставшихся узлов из стека.
    //
    // Обнуление curr нужно для того, чтобы
    // при следующей итерации не зайти снова в
    // while (curr) {}
    // и не спуститься по левым детям заново.
    // Вместо этого мы остаёмся в основном
    // "пост-order" потоке, сразу достаём
    // следующий узел из стека. Если бы curr
    // остался ненулевым, внутренний цикл
    // снова бы "утянул" нас влево, и логика
    // обхода нарушилась бы.
    curr = null;

    // Шаг 4: следующий проход 
    //
    // curr=null, 
    // stack=[1,2],
    // visited=null
    // Дерево:
    //
    //        1
    //       / \
    //      2   3
    //     /   / \
    // null*  2   4
    //

    // Переход к вершине стека:
    //
    // curr = 2 (теперь без детей)
    // stack=[1],
    // visited=null
    // Дерево:
    //
    //        1
    //       / \
    //      2*  3
    //         / \
    //        2   4
    //
    // — повторяем логику удаления
    //

    // После удаления второго узла 2:
    //
    // Стек: [1]
    // visited: null
    // Дерево:
    //
    //        1
    //         \
    //          3
    //         / \
    //        2   4
    //

    // Переход в правое поддерево корня:
    //
    // curr = 3, 
    // stack=[1],
    // visited=null
    // Дерево:
    //
    //        1
    //         \
    //          3*
    //         / \
    //        2   4
    //

    // Спускаемся влево:
    //
    // curr = 2, 
    // stack=[1,3]
    // Достигнут лист 2 в правом
    // поддереве:
    // Дерево:
    //
    //        1
    //         \
    //          3
    //         / \
    //        2*  4
    //
    // — повторяем логику удаления
    //


    // после удаления:
    //
    // Стек: [1,3]
    // visited: null
    // Дерево:
    //
    //        1
    //         \
    //          3
    //           \
    //            4
    //

    // Спускаемся вправо:
    //
    // curr=null, 
    // stack=[1,3,4],
    // visited=null
    // Дерево:
    //
    //        1
    //         \
    //          3
    //           \
    //            4
    //             \
    //              null*
    //

    // Возврат к узлу 4:
    //
    // 4 — лист,
    // но 4 !== 2,
    // значит visited=4 после pop
    //
    // curr=4,
    // Стек: [1,3]
    // visited: 4
    // Дерево без изменений:
    //
    //        1
    //         \
    //          3
    //           \
    //            4* visited
    //            

    // Возврат к узлу 3:
    //
    // curr=3,
    // stack=[1],
    // visited=4
    //
    // Поддеревья 3 обработаны,
    // visited обновляется: visited=3
    //
    // Дерево без изменений:
    //
    //        1
    //         \
    //          3* visited
    //           \
    //            4
    //            

    // Возврат к корню 1:
    //
    // curr=1, 
    // stack=[],
    // visited=3
    //
    // Обход завершён
    // Дерево без изменений:
    //
    //        1*
    //         \
    //          3 visited
    //           \
    //            4
    //            

    // После всех шагов:
    // Результат:
    //
    //    1
    //     \
    //      3
    //       \
    //        4
    //
  }

  // Возвращаем корень
  // обновлённого дерева.
  return root;
}
