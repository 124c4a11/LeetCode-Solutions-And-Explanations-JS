/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */


/**
 * @param {ListNode} head
 * @return {ListNode}
 * 
 * Функция принимает head однонаправленного
 * связного списка и вставляет между каждыми
 * двумя соседними узлами новый узел со
 * значением, равным наибольшему общему
 * делителю значений этих двух соседних узлов.
 * 
 * Параметры:
 *   head — ссылка на первый узел
 *   однонаправленного связного списка.
 * 
 * Возвращаемое значение:
 *   Возвращает ту же ссылку head на
 *   модифицированный список или null,
 *   если передан пустой список.
 */
function insertGreatestCommonDivisors(head) {

  // Проверка на пустой список:
  // Если head равен null или undefined,
  // то операции не выполняются и
  // возвращается null.
  if (!head) return null;

  // Объявление вспомогательной функции
  // gcd для вычисления наибольшего общего
  // делителя двух неотрицательных целых
  // чисел a и b с помощью итеративного
  // алгоритма Евклида.
  function gcd(a, b) {

    // Основной цикл алгоритма
    // Евклида, обеспечивающий
    // сокращение пары (a,b).
    //
    // Пока второй аргумент b не стал
    // нулём, продолжаем итерации.
    while (b > 0) {

      // Выполняем шаг алгоритма
      // Евклида:
      //
      // Присваиваем a значение b,
      // а b значение остатка от
      // деления a на b.
      //
      // Деструктуризация используется
      // для компактной записи обмена
      // значениями.
      [a, b] = [b, a % b];
    }

    // После выхода из цикла переменная
    // a содержит НОД исходных a и b,
    // возвращаем её.
    return a;
  };

  // Устанавливаем переменную curr на
  // начало списка, будем использовать
  // её для итерации по списку и вставки
  // новых узлов.
  let curr = head;

  // Цикл проходит пока у текущего узла
  // есть следующий узел.
  //
  // Мы проверяем curr.next потому что
  // вставка происходит между curr и
  // curr.next.
  while (curr.next) {

    // Считываем значение текущего
    // узла в n1.
    //
    // Предполагается что значения
    // являются целыми числами
    const n1 = curr.val;

    // Считываем значение следующего
    // узла в n2.
    //
    // Используем его вместе с n1 для
    // вычисления НОДа.
    const n2 = curr.next.val;

    // Получаем наибольшего общего
    // делителя между двумя соседними
    // значениями.
    const gcdValue = gcd(n1, n2);

    // Создаём новый узел со значением
    // gcdValue.
    //
    // Конструктор ListNode принимает
    // значение и ссылку на следующий
    // узел, здесь следующими делаем
    // узел, который сейчас является
    // curr.next, таким образом новый
    // узел будет вставлен между curr
    // и curr.next (инсерция перед
    // старым curr.next)
    const newNode = new ListNode(gcdValue, curr.next);

    // Вставляем новый узел после
    // curr, переназначив curr.next
    // на вновь созданный узел.
    curr.next = newNode;

    // Продвигаем curr к следующему
    // исходному узлу:
    //
    // newNode.next указывает на
    // узел, который был изначально
    // после curr.
    curr = newNode.next;
  }

  // Метод возвращает head списка.
  //
  // Изменения произведены на месте,
  // поэтому head теперь указывает на
  // модифицированный список.
  return head;
}
