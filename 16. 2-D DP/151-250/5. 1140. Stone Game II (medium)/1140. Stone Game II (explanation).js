/**
 * @param {number[]} piles
 * @return {number}
 * 
 * stoneGameII реализует решение задачи оптимальной
 * игры двух игроков на последовательности куч
 * камней. Она вычисляет максимальное количество
 * камней, которое может собрать первый игрок при
 * оптимальной игре обоих сторон, если игроки по
 * очереди берут X куч с начала оставшейся части
 * массива, где X может быть от 1 до 2*M, а M
 * обновляется как max(M, X) после хода.
 * 
 * Параметры
 *   piles — массив чисел (Array или типизированный
 *   массив) представляющий исходные кучки камней в
 *   порядке. Каждый элемент — количество камней в
 *   соответствующей куче.
 * 
 * Возвращаемое значение
 * Функция возвращает одно число — максимальное
 * количество камней, которое первый игрок может
 * гарантированно собрать при оптимальной стратегии
 * обоих игроков.
 */
function stoneGameII(piles) {
  const n = piles.length;

  // Создаём массив суффиксных сумм suffixSum
  // длины n.
  //
  // suffixSum[i] будет хранить сумму
  // piles[i] + piles[i+1] + ... + piles[n-1].
  //
  // Для примера создаётся Int32Array длиной 5:
  // [0,0,0,0,0].
  const suffixSum = new Int32Array(n);

  // Инициализируем последний элемент suffixSum
  // последним элементом piles, потому что
  // суффиксная сумма от последнего индекса
  // равна самому последнему элементу
  //
  // Это база для построения всех остальных
  // суффиксных сумм.
  //
  // Для примера suffixSum[4] = piles[4] = 4.
  suffixSum[n - 1] = piles[n - 1];

  // Цикл собирает суффиксные суммы справа
  // налево.
  //
  // На каждой итерации присваиваем
  // suffixSum[i] = piles[i] + suffixSum[i + 1].
  //
  // Это позволяет быстро получить сумму всех
  // оставшихся камней с позиции i за O(1).
  //
  // Для примера последовательность вычислений:
  // i=3 → suffixSum[3] 
  //         = piles[3] + suffixSum[4]
  //         = 4 + 4 = 8
  // i=2 → suffixSum[2]
  //         = piles[2] + suffixSum[3]
  //         = 9 + 8 = 17
  // i=1 → suffixSum[1]
  //         = piles[1] + suffixSum[2]
  //         = 7 + 17 = 24
  // i=0 → suffixSum[0]
  //         = piles[0] + suffixSum[1]
  //         = 2 + 24 = 26
  //
  // Итого suffixSum = [26, 24, 17, 8, 4].
  for (let i = n - 2; i >= 0; i--) {
    suffixSum[i] = piles[i] + suffixSum[i + 1];
  }

  // Создаём двумерный массив dp размера
  // n x (n+1) и инициализируем значением -1 для
  // обозначения "не вычислено".
  //
  // dp[i][M] будет кэшем (memo) максимального
  // числа камней, которое может получить текущий
  // игрок, начиная с индекса i при текущем
  // параметре M.
  //
  // Размер по второму измерению n+1 потому, что
  // M никогда не будет больше n в худшем случае,
  // и это упрощает индексацию и позволяет
  // индексу M принимать значения от 0 до n без
  // дополнительных проверок
  //
  // Для примера создаётся массив 5 x 6,
  // все элементы равны -1.
  //
  // dp хранит значение для игрока, который сейчас
  // ходит в состоянии (i, M). Для начального
  // состояния dp[0][1] это значение для Алисы, но
  // в общем dp[i][M] может представлять либо Алису,
  // либо Боба в зависимости от того, чей ход
  // наступает при этих i и M.
  //
  // Объяснение
  // - Определение: dp[i][M] — максимальное число
  //   камней, которое может набрать игрок, чей
  //   сейчас ход, если оставшиеся кучи начинаются
  //   с индекса i и текущее M равно M.  
  //
  // - Почему не только для Алисы: рекурсия
  //   вызывается для следующего состояния
  //   dfs(i+X, max(M, X)), и в этой следующей
  //   записи dp отражает уже другого игрока
  //   (соперника текущего). То есть одни и те же
  //   индексы i, M всегда означают «игрок на ходу»
  //   независимо от того, это Алиса или Боб в
  //   реальной партии.  
  //
  // - Начальное состояние: при вызове dfs(0, 1)
  //   вычисляется выгода игрока, который ходит
  //   первым, то есть Алисы, поэтому
  //   dp[0][1] — значение для Алисы. Все
  //   остальные ячейки dp соответствуют игроку
  //   на очереди в соответствующем состоянии.
  const dp = Array.from(
    { length: n },
    () => new Array(n + 1).fill(-1)
  );

  // Объявление рекурсивной функции dfs(i, M):
  // - i - индекс первой доступной кучи на текущем
  //       ходу (0..n)
  // - M - текущее ограничение: игрок может взять
  //       от 1 до 2*M куч.
  //
  // Функция возвращает максимальное количество
  // камней, которые текущий игрок может получить
  // из подпоследовательности piles[i..n-1] при
  // оптимальной игре обоих.
  function dfs(i, M) {

    // Базовый случай:
    // Если индекс i достиг конца массива,
    // камней нет.
    //
    // Возвращаем 0 — текущий игрок не может
    // взять никаких камней.
    if (i === n) return 0;

    // Ключевой момент для оптимизации:
    // Если значение для состояния (i, M) уже
    // вычислено (не -1), возвращаем кэш
    // - избегаем повторного перебора одних и
    // тех же состояний.
    if (dp[i][M] !== -1) return dp[i][M];


    // Инициализируем локальную переменную
    // result нулём.
    //
    // В процессе перебора X (сколько куч
    // взять) будем обновлять result
    // максимальным значением.
    let result = 0;

    // Перебираем возможное количество взятых
    // куч X: от 1 до 2*M.
    //
    // Правило:
    // игрок может взять не более 2*M куч, но
    // нельзя выходить за правую границу.
    for (let X = 1; X <= 2 * M; X++) {

      // Если i + X выходит за пределы
      // массива (пытаемся взять слишком
      // много куч), прерываем цикл.
      //
      // Это гарантирует, что берем только
      // существующие кучи.
      if (i + X > n) break;

      // Выражение присваивает в result
      // максимальное значение между текущим
      // лучшим результатом и выигрышем при
      // рассмотрении нового варианта X,
      // таким образом аккумулируя лучший из
      // проверенных вариантов. 
      //
      // Эта строка обновляет текущий лучший
      // возможный результат для игрока,
      // который ходит в состоянии (i, M),
      // выбирая оптимальное значение X из
      // перебираемых.
      //
      // Объяснение выражения:
      // - suffixSum[i] — суммарное
      //   количество камней, оставшихся
      //   от i до конца.
      //
      // - dfs(i + X, Math.max(M, X))
      //   - максимальный выигрыш соперника,
      //   если мы возьмём X куч, после чего
      ///  очередь перейдёт к сопернику,
      //   а новое M станет max(M, X).
      //
      // - suffixSum[i] - dfs(...)
      //   - максимальное количество камней,
      //   которое останется нам с учётом
      //   того, что соперник играет
      //   оптимально. Мы выбираем X, который
      //   максимизирует эту разницу.
      //
      // Для примера:
      // рассмотрим состояние
      // i=0, M=1, suffixSum[0]=26.
      // Возможные X: 1 или 2.
      // X=1 → мы берём piles[0]=2,
      //       тогда соперник начнёт с i=1,
      //       M=max(1,1)=1. 
      //       Наш итог = suffixSum[0] - dfs(1,1).
      // X=2 → мы берём piles[0]+piles[1]=2+7=9,
      //       соперник начнёт с i=2,
      //       M=max(1,2)=2.
      //       Наш итог = suffixSum[0] - dfs(2,2).
      result = Math.max(
        result,
        suffixSum[i] - dfs(i + X, Math.max(M, X))
      );
    }

    // Сохраняем вычисленное оптимальное значение
    // в dp[i][M] и возвращаем его.
    //
    // Сокращенная запись от:
    // dp[i][M] = result;
    // return dp[i][M];
    return (dp[i][M] = result);
  };


  // Запускаем DFS с начального состояния:
  // первый игрок (Алиса) начинает с индекса
  // 0 и M = 1.
  //
  // Возвращаем итоговый максимальный результат
  // для первого игрока (Алиса).
  return dfs(0, 1);

  // Пример работы функции:
  //
  // Инициализация входных данных и
  // вспомогательных массивов:
  //   piles = [2, 7, 9, 4, 4]
  //   n = 5
  //   suffixSum = [26, 24, 17, 8, 4]
  // 
  //
  // Ввод и размер dp
  // - Размер dp: 5 x 6 (i = 0..4, M = 0..5).
  //   В реальной логике M всегда >=1, но второй
  //   индекс выделен до n включительно.
  // - Начальное состояние (все значения -1):
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1], // dp[0][M]
  //   [-1, -1, -1, -1, -1, -1], // dp[1][M]
  //   [-1, -1, -1, -1, -1, -1], // dp[2][M]
  //   [-1, -1, -1, -1, -1, -1], // dp[3][M]
  //   [-1, -1, -1, -1, -1, -1], // dp[4][M]
  // ];
  // 
  // ---
  // 
  // Последовательность вызовов и обновлений
  // dp (пошагово)
  // 
  // 1. Входной вызов dfs(0, 1). Нужно
  //    значение dfs(1,1) → продолжаем вглубь.
  // 
  // 2. Вызов dfs(1, 1). Нужно dfs(2,1).
  // 
  // 3. Вызов dfs(2, 1). Нужно dfs(3,1).
  // 
  // 4. Вызов dfs(3, 1). Нужно dfs(4,1).
  // 
  // 5. Вызов dfs(4, 1).
  //    - suffixSum[4] = 4, доступен только X=1
  //      → результат = 4.
  //    - Записываем dp[4][1] = 4.
  //
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1,  4, -1, -1, -1, -1]  // dp[4][1] = 4
  // ];
  //
  // 
  // 6. Возврат в dfs(3,1).
  // - Рассмотрены X=1:
  //   8 - dfs(4,1) = 8 - 4 = 4.
  // - X=2: 8 - dfs(5,2) = 8 - 0 = 8.
  // - Максимум = 8 → записываем dp[3][1] = 8.
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1,  8, -1, -1, -1, -1], // dp[3][1] = 8
  //   [-1,  4, -1, -1, -1, -1]
  // ];
  // 
  //
  // 7. Возврат в dfs(2,1).
  // - X=1: 17 - dfs(3,1) = 17 - 8 = 9.
  // - X=2 требует dfs(4,2) — вызываем dfs(4,2).
  // 
  // 8. Вызов dfs(4,2).
  // - suffixSum[4] = 4, доступен X=1
  //   → результат = 4
  //   → записываем dp[4][2] = 4.
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1,  8, -1, -1, -1, -1],
  //   [-1,  4,  4, -1, -1, -1]  // dp[4][2] = 4
  // ];
  //
  // 
  // 9. Возврат в dfs(2,1).
  // - X=2: 17 - dfs(4,2) = 17 - 4 = 13.
  // - Максимум = 13
  //   → записываем dp[2][1] = 13.
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, 13, -1, -1, -1, -1], // dp[2][1] = 13
  //   [-1,  8, -1, -1, -1, -1],
  //   [-1,  4,  4, -1, -1, -1]
  // ];
  //
  // 
  // 10. Возврат в dfs(1,1).
  // - X=1: 24 - dfs(2,1) = 24 - 13 = 11.
  // - X=2 требует dfs(3,2) — вызываем dfs(3,2).
  // 
  // 11. Вызов dfs(3,2).
  // - Возможные X: 1..4,
  //   но реально X=1..2 (осталось 2 куч).
  // - X=1: 8 - dfs(4,2) = 8 - 4 = 4.
  // - X=2: 8 - dfs(5,2) = 8 - 0 = 8.
  // - Максимум = 8 → записываем dp[3][2] = 8.
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, 13, -1, -1, -1, -1],
  //   [-1,  8,  8, -1, -1, -1], // dp[3][2] = 8
  //   [-1,  4,  4, -1, -1, -1]
  // ];
  //
  // 
  // 12. Возврат в dfs(1,1).
  // - X=2: 24 - dfs(3,2) = 24 - 8 = 16.
  // - Максимум = 16 → записываем dp[1][1] = 16.
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, 16, -1, -1, -1, -1], // dp[1][1] = 16
  //   [-1, 13, -1, -1, -1, -1],
  //   [-1,  8,  8, -1, -1, -1],
  //   [-1,  4,  4, -1, -1, -1]
  // ];
  //
  // 
  // 13. Возврат в dfs(0,1).
  // - X=1: 26 - dfs(1,1) = 26 - 16 = 10.
  // - X=2 требует dfs(2,2) — вызываем dfs(2,2).
  // 
  // 14. Вызов dfs(2,2).
  // - Возможные X: 1..4,
  //   реально X=1..3 (осталось 3 куч).
  // - X=1: 17 - dfs(3,2) = 17 - 8 = 9.
  // - X=2: 17 - dfs(4,2) = 17 - 4 = 13.
  // - X=3: 17 - dfs(5,3) = 17 - 0 = 17.
  // - Максимум = 17 → записываем dp[2][2] = 17.
  // 
  // dp = [
  //   [-1, -1, -1, -1, -1, -1],
  //   [-1, 16, -1, -1, -1, -1],
  //   [-1, 13, 17, -1, -1, -1], // dp[2][2] = 17
  //   [-1,  8,  8, -1, -1, -1],
  //   [-1,  4,  4, -1, -1, -1]
  // ];
  //
  // 
  // 15. Возврат в dfs(0,1).
  // - X=2: 26 - dfs(2,2) = 26 - 17 = 9.
  // - Максимум из {10, 9} = 10
  //   → записываем dp[0][1] = 10.
  // 
  // dp = [
  //   [-1, 10, -1, -1, -1, -1], // dp[0][1] = 10
  //   [-1, 16, -1, -1, -1, -1],
  //   [-1, 13, 17, -1, -1, -1],
  //   [-1,  8,  8, -1, -1, -1],
  //   [-1,  4,  4, -1, -1, -1]
  // ];
  // 
  // ---
  // 
  // Итог
  // - Финальный dp (после всех необходимых
  //   вычислений в ходе dfs(0,1)) показан выше.
}
