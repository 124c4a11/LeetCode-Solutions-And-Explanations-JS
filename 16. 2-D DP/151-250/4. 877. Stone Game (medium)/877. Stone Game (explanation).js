/**
 * @param {number[]} piles
 * @return {boolean}
 * 
 * stoneGame принимает один параметр
 * piles — массив ненулевых целых чисел,
 * где piles[i] — количество камней в i-й куче.
 * 
 * Задача — определить, сможет ли первый игрок (Alice)
 * набрать больше камней, чем второй при оптимальной
 * игре обоих.
 */
function stoneGame(piles) {
  const n = piles.length;

  // Создаем dp для хранения промежуточных
  // результатов динамического программирования,
  // чтобы на основе уже вычисленных значений
  // быстро получить оптимальный результат для
  // большего интервала куч. В этой реализации
  // dp аккумулирует оптимальный счёт первого
  // игрока (Alice) для текущих подзадач так,
  // чтобы не пересчитывать их повторно.
  //
  // В момент обработки фиксированного левого
  // индекса l значение dp[r] означает
  // оптимально достижимый счёт игрока, который
  // делает ход первым на интервале [l..r].
  const dp = new Int32Array(n);

  // Внешний цикл по l идёт справа-налево.
  //
  // l — индекс левой границы текущего
  // рассматриваемого отрезка куч. При
  // фиксированном значении l внутренний
  // цикл перебирает все отрезки вида [l..r],
  // где r растёт от l до n−1, то есть
  // рассматриваются все подпоследовательности,
  // начинающиеся в позиции l. Семантически
  // при обработке этого l dp[r] хранит
  // оптимальный результат для игрока, который
  // ходит первым на отрезке [l..r].
  //
  //
  // Почему цикл идёт в обратном порядке
  // (с n−1 до 0 справа налево)
  // 
  // - При переходах для вычисления значения
  //   на отрезке [l..r] алгоритм использует
  //   результаты для отрезков меньшей длины:
  //   конкретно для [l+1..r] и [l..r−1].  
  // - Обход по убывающему l с внутренним
  //   ростом r гарантирует, что к моменту
  //   вычисления [l..r]:
  //   - значение для [l+1..r] всё ещё доступно
  //     в текущем dp[r] (оно ещё не
  //     перезаписано для этого l),
  //   - значение для [l..r−1] уже записано
  //     в dp[r−1] в текущем проходе по r.
  // - Если бы l шёл вперёд (от 0 к n−1),
  //   требуемые состояния [l+1..r] ещё не
  //   были бы вычислены или были бы
  //   перезаписаны, и однамерный массив dp
  //   перестал бы корректно предоставлять
  //   нужные значения без дополнительной
  //   памяти.
  for (let l = n - 1; l >= 0; l--) {

    // Внутренний цикл по r идёт от l до
    // конца массива и формирует все
    // возможные интервалы [l..r]
    for (let r = l; r < n; r++) {

      // Вычисляем, чётная ли длина
      // отрезка с точки зрения
      // количества шагов (r - l).
      //
      // Если (r - l) чётно, то текущий
      // ход делает первый игрок (Alice)
      // на этом отрезке, иначе — второй
      // (Bob)
      const even = (r - l) % 2 === 0;

      // Если сейчас очередь первого
      // игрока (Alice) (even === true),
      // то при выборе левой кучи он
      // получает piles[l].
      // 
      // Иначе при выборе левой кучи
      // добавляем 0, потому что в DP
      // мы накапливаем очки именно
      // для первого игрока (Alice)
      const leftPile = even ? piles[l] : 0;

      // Аналогично, если ход
      // принадлежит первому игроку
      // (Alice), при выборе правой
      // кучи он получает piles[r],
      // иначе 0
      const rightPile = even ? piles[r] : 0;

      // Базовый случай:
      // Если левая и правая границы
      // совпадают (l === r), то
      // длинна отрезка [l..r] === 1.
      //
      // В такой ситуации есть только
      // одна куча, и игрок, который
      // ходит первым на этом отрезке,
      // обязательно забирает её.
      //
      //
      // Почему присваивается leftPile: 
      //
      // При l === r выражение even
      // будет истинно, потому что
      // r − l = 0 — чётное число,
      // поэтому leftPile уже
      // установлена в piles[l].
      // Присваивание dp[r] = leftPile
      // записывает в dp результат для
      // отрезка [l..r] как количество
      // камней в единственной куче.
      // 
      //
      // Почему не используется
      // rightPile напрямую:  
      //
      // Для отрезка из одной кучи
      // leftPile и rightPile равны
      // одному и тому же значению
      // piles[l] (потому что l === r).
      // В коде используют leftPile по
      // соглашению. Это однозначно
      // отражает, что при
      // единственной куче первый
      // игрок (Alice) получает её
      // значение.
      if (l === r) {
        dp[r] = leftPile;
      } else {

        // Если длина отрезка > 1:
        // Рассматриваем два варианта
        // для первого игрока (Alice),
        // делающего текущий ход:
        // 1. Взять левую кучу:
        //    текущее dp[r] до
        //    обновления хранит
        //    оптимальный результат
        //    для подотрезка [l+1..r]
        //    при уже обработанном l+1.
        //    Этот результат
        //    соответствует тому, что
        //    останется после того,
        //    как текущий игрок возьмёт
        //    левую кучу piles[l].
        //    Поэтому вариант «взять
        //    левую кучу» оценивается
        //    как dp[r] + leftPile.
        //
        // 2. Взять правую кучу:
        //    dp[r - 1] до обновления
        //    хранит оптимальный
        //    результат для подотрезка
        //    [l..r-1] при уже
        //    обработанном r-1. Этот
        //    результат соответствует
        //    тому, что останется после
        //    того, как текущий игрок
        //    возьмёт правую кучу
        //    piles[r]. Поэтому вариант
        //    «взять правую кучу»
        //    оценивается как
        //    dp[r - 1] + rightPile.
        //
        //
        // Роль leftPile и rightPile:
        //
        // leftPile и rightPile равны
        // либо значениям
        // соответствующих краёв piles[l]
        // и piles[r], либо нулю, в
        // зависимости от того, чей ход
        // сейчас моделируется
        // (переменная even):
        // - Если сейчас ход первого
        //   игрока (Alice),
        //   соответствующее значение
        //   добавляется.
        //-  Если ход соперника,
        //   добавляется 0, потому что
        //   в этой модели мы не
        //   прибавляем очки соперника
        //   к текущему игроку.
        dp[r] = Math.max(
          dp[r] + leftPile,
          dp[r - 1] + rightPile
        );
      }
    }
  }

  // Считаем общую сумму камней во всех кучах
  // для определения очков второго игрока (Bob)
  // через total - aliceScore.
  const total = piles.reduce((a, b) => a + b, 0);

  // После заполнения dp[n - 1] хранит
  // оптимальный счёт первого игрока (Alice)
  // для полного интервала [0, n-1]
  const aliceScore = dp[n - 1];

  // Возвращаем true если Alice набирает
  // больше камней, чем Bob. То есть её счёт
  // больше половины суммарного
  return aliceScore > total - aliceScore;

  // Пример работы для piles = [5, 3, 4, 5]
  // 
  // Исходные данные  
  // - piles = [5, 3, 4, 5]  
  // - n = 4  
  // - Начальное dp = [0, 0, 0, 0]
  // 
  // ---
  // 
  // l = 3 (интервалы длины 1: [3..3])
  // - r = 3  
  //   - r − l = 0 → even = true
  //   - leftPile = piles[3] = 5,
  //     rightPile = piles[3] = 5
  //   - Базовый случай l === r
  //     → dp[3] = leftPile = 5  
  // - Состояние dp после l = 3:
  //   [0, 0, 0, 5]
  // 
  // ---
  // 
  // l = 2 (интервалы [2..2], [2..3])
  // - r = 2  
  //   - r − l = 0 → even = true
  //   - leftPile = piles[2] = 4  
  //   - l === r → dp[2] = 4  
  //   - dp (после r=2): [0, 0, 4, 5]
  // - r = 3  
  //   - r − l = 1 → even = false
  //   - leftPile = 0,
  //     rightPile = 0 (т.к. even === false)  
  //   - Используем переход:
  //     dp[3] = Math.max(
  //         dp[3] + leftPile,
  //         dp[2] + rightPile
  //     )  
  //     - старое dp[3] (до перезаписи) = 5
  //       соответствует [3..3]  
  //     - dp[2] = 4 соответствует [2..2]  
  //     - dp[3]
  //         = Math.max(5 + 0, 4 + 0)
  //         = Math.max(5, 4) = 5  
  //   - dp (после r=3): [0, 0, 4, 5]
  // 
  // Пояснение для r=3: even = false означает,
  // что на отрезке [2..3] ход делает не тот
  // игрок, чьи очки аккумулирует dp при этом l,
  // поэтому взятие краёв не добавляет напрямую
  // к leftPile/rightPile в этой формуле. Выбор
  // основывается на подзадачах.
  // 
  // ---
  // 
  // l = 1 (интервалы [1..1], [1..2], [1..3])
  // - r = 1  
  //   - r − l = 0 → even = true
  //   - leftPile = piles[1] = 3  
  //   - l === r → dp[1] = 3  
  //   - dp: [0, 3, 4, 5]
  // - r = 2  
  //   - r − l = 1 → even = false
  //   - leftPile = 0,
  //     rightPile = 0  
  //   - Переход:
  //     dp[2] = Math.max(
  //         dp[2] + leftPile,
  //         dp[1] + rightPile
  //     )  
  //     - старое dp[2] = 4 (для [2..2])  
  //     - dp[1] = 3 (для [1..1])  
  //     - dp[2] = Math.max(4 + 0, 3 + 0) = 4  
  //   - dp: [0, 3, 4, 5]
  // - r = 3  
  //   - r − l = 2 → even = true
  //   - leftPile = piles[1] = 3,
  //     rightPile = piles[3] = 5  
  //   - Переход: dp[3] = Math.max(
  //         dp[3] + leftPile,
  //         dp[2] + rightPile
  //     )  
  //     - старое dp[3] = 5 соответствует
  //      [2..3] до изменения
  //     - dp[2] = 4 соответствует [1..2]  
  //     - Вариант взять левую: 5 + 3 = 8  
  //     - Вариант взять правую: 4 + 5 = 9  
  //     - dp[3] = max(8, 9) = 9  
  //   - dp: [0, 3, 4, 9]
  // 
  // ---
  // 
  // l = 0 (интервалы
  // [0..0], [0..1], [0..2], [0..3])
  // - r = 0  
  //   - r − l = 0 → even = true
  //   - leftPile = piles[0] = 5  
  //   - l === r → dp[0] = 5  
  //   - dp: [5, 3, 4, 9]
  // - r = 1  
  //   - r − l = 1 → even = false
  //   - leftPile = 0,
  //     rightPile = 0  
  //   - dp[1]
  //       = Math.max(dp[1] + 0, dp[0] + 0)
  //       = Math.max(3, 5) = 5  
  //   - dp: [5, 5, 4, 9]
  // - r = 2  
  //   - r − l = 2 → even = true
  //   - leftPile = piles[0] = 5,
  //     rightPile = piles[2] = 4  
  //   - dp[2] = Math.max(
  //         dp[2] + leftPile,
  //         dp[1] + rightPile
  //     )  
  //     - старое dp[2] = 4 (для [1..2])  
  //     - dp[1] = 5 (для [0..1])  
  //     - левый вариант: 4 + 5 = 9  
  //     - правый вариант: 5 + 4 = 9  
  //     - dp[2] = 9  
  //   - dp: [5, 5, 9, 9]
  // - r = 3  
  //   - r − l = 3 → even = false
  //   - leftPile = 0, rightPile = 0  
  //   - dp[3]
  //       = Math.max(dp[3] + 0, dp[2] + 0)
  //       = Math.max(9, 9) = 9  
  //   - Итоговое dp: [5, 5, 9, 9]
  // 
  // ---
  // 
  // Результат и интерпретация
  // - После завершения циклов 
  //   aliceScore = dp[n - 1] = dp[3] = 9
  // - total = 5 + 3 + 4 + 5 = 17
  // - Alice получает 9, второй игрок
  //   получает 8 → функция вернёт true
  //   (Alice выигрывает).
  // 
  // ---
  // 
  // Короткая визуализация состояния dp
  // после каждого полного шага l
  // - Начало: [0, 0, 0, 0]  
  // - После l = 3: [0, 0, 0, 5]  
  // - После l = 2: [0, 0, 4, 5]  
  // - После l = 1: [0, 3, 4, 9]  
  // - После l = 0: [5, 5, 9, 9]
}
