/**
 * @param {number[][]} grid
 * @return {number}
 * 
 * Функция minPathSum вычисляет минимальную
 * суммарную стоимость пути от верхнего
 * левого угла до нижнего правого угла в
 * прямоугольной сетке чисел при условии,
 * что разрешены только два направления
 * движения: вправо и вниз. Функция
 * возвращает число — минимальную сумму
 * значений ячеек вдоль такого пути.
 * 
 * Параметры:
 * - grid — двумерный массив чисел,
 *   представляющий сетку где 
 *   grid[r][c] — стоимость посещения ячейки.
 * 
 * Возвращаемое значение:
 * - Число (number): минимальная суммарная
 *   стоимость пути от клетки (0,0) до клетки
 *   (ROWS-1, COLS-1).
 */
function minPathSum(grid) {
  const ROWS = grid.length;
  const COLS = grid[0].length;

  // Создаём одномерный массив dp длиной
  // COLS + 1, где будем хранить минимальные
  // суммы для текущей и следующих колонок
  // при проходе снизу-вверх и справа-налево
  //
  // Использование COLS + 1 позволяет
  // безопасно обращаться к dp[c + 1] без
  // отдельной проверки границы последнего
  // столбца
  //
  // Изначально заполняем массив значением
  // Infinity, обозначающим "недостижимое"
  // или "непосчитанное" состояние
  //
  // При первых вычислениях
  // Math.min(dp[c], dp[c + 1]) Infinity
  // позволит корректно вычислять минимум,
  // так как Math.min(x, Infinity) вернёт x.
  //
  // Используется при оптимизации по памяти:
  // вместо 2D dp храним только текущую
  // строку результатов.
  const dp = new Array(COLS + 1).fill(Infinity);

  // Инициализация базового состояния для
  // "практически правого" элемента:
  // dp[COLS - 1] = 0.
  //
  // Это технический трюк:
  // при обработке правой нижней ячейки
  // (последний столбец в последней строке)
  // формула
  // grid[r][c] + Math.min(dp[c], dp[c+1])
  // станет grid[last] + Math.min(
  // 0 или текущее dp[c], Infinity)
  // и гарантирует учёт только реальной
  // стоимости последней ячейки при первом
  // и последующих обновлениях.
  //
  // Пример:
  // для grid = [[1,3,1],[1,5,1],[4,2,1]]
  // Изначально
  // dp = [Infinity, Infinity, Infinity, Infinity]
  // После установки dp[COLS - 1] = 0
  // (то есть dp[2] = 0) массив выглядит так:
  // dp = [Infinity, Infinity, 0, Infinity]
  dp[COLS - 1] = 0;

  // Внешний цикл проходит по строкам снизу
  // вверх: от последней строки (ROWS - 1)
  // к первой (0).
  //
  // Проход снизу вверх нужен потому, что
  // dp[c] на момент обновления клетки (r,c)
  // хранит результат для клетки, лежащей
  // ниже (r+1,c) из предыдущей итерации
  // внешнего цикла.
  for (let r = ROWS - 1; r >= 0; r--) {

    // Внутренний цикл проходит по
    // столбцам справа налево: от
    // последнего столбца (COLS - 1)
    // к первому (0).
    //
    // Проход справа налево нужен,
    // чтобы dp[c+1] в выражении
    // dp[c] = 
    //  grid[r][c]
    //  + Math.min(dp[c], dp[c + 1])
    // уже содержал обновлённое
    // значение для правой соседней
    // клетки в той же строке r.
    for (let c = COLS - 1; c >= 0; c--) {

      // Обновляем dp[c] как сумму
      // значения текущей клетки
      // grid[r][c] и минимального
      // значения между dp[c] и dp[c + 1].
      // - dp[c] на данном шаге
      //   - минимальная стоимость пути
      //   вниз из клетки (r, c) (потому
      //   что ещё не обновленf в текущей
      //   строке),
      // - dp[c + 1] - минимальная
      //   стоимость пути вправо из
      //   клетки (r, c).
      //
      // сохраняем результат в dp[c],
      // чтобы он мог быть использован
      // в обработке ячейки слева (c-1)
      // или в следующей итерации
      // строки выше.
      //
      // После присваивания dp[c] будет
      // содержать минимальную стоимость
      // пути от клетки (r, c) до конца
      // - правой нижней клетки grid
      // (ROWS-1, COLS-1).
      dp[c] = grid[r][c] + Math.min(dp[c], dp[c + 1]);
    }
  }

  // Шаги цикла с визуализацией изменения
  // dp
  // для grid = [[1,3,1],[1,5,1],[4,2,1]]
  // 
  // Исходные параметры и инициализация:
  // - ROWS = 3, COLS = 3  
  // - dp (длина COLS + 1)
  //   = [Infinity, Infinity, Infinity, Infinity]  
  // - после установки dp[COLS - 1] = 0
  //   → dp = [Infinity, Infinity, 0, Infinity]
  // 
  // Шаг 1: r = 2, c = 2  
  // - Вычисление: 
  //   dp[2] = grid[2][2] + Math.min(dp[2], dp[3])
  //   = 1 + min(0, Infinity) = 1  
  // - dp после шага:
  //   [Infinity, Infinity, 1, Infinity]
  // 
  // Шаг 2: r = 2, c = 1  
  // - Вычисление:
  //   dp[1] = grid[2][1] + Math.min(dp[1], dp[2])
  //   = 2 + min(Infinity, 1) = 3  
  // - dp после шага:
  //   [Infinity, 3, 1, Infinity]
  // 
  // Шаг 3: r = 2, c = 0  
  // - Вычисление:
  //   dp[0] = grid[2][0] + Math.min(dp[0], dp[1])
  //   = 4 + min(Infinity, 3) = 7  
  // - dp после шага:
  //   [7, 3, 1, Infinity]
  // 
  // ---  
  // 
  // Шаг 4: r = 1, c = 2  
  // - Вычисление:
  //   dp[2] = grid[1][2] + Math.min(dp[2], dp[3])
  //   = 1 + min(1, Infinity) = 2  
  // - dp после шага:
  //   [7, 3, 2, Infinity]
  // 
  // Шаг 5: r = 1, c = 1  
  // - Вычисление:
  //   dp[1] = grid[1][1] + Math.min(dp[1], dp[2])
  //   = 5 + min(3, 2) = 7  
  // - dp после шага:
  //   [7, 7, 2, Infinity]
  // 
  // Шаг 6: r = 1, c = 0  
  // - Вычисление:
  //   dp[0] = grid[1][0] + Math.min(dp[0], dp[1])
  //   = 1 + min(7, 7) = 8  
  // - dp после шага:
  //   [8, 7, 2, Infinity]
  // 
  // ---  
  // 
  // Шаг 7: r = 0, c = 2  
  // - Вычисление:
  //   dp[2] = grid[0][2] + Math.min(dp[2], dp[3])
  //   = 1 + min(2, Infinity) = 3  
  // - dp после шага:
  //   [8, 7, 3, Infinity]
  // 
  // Шаг 8: r = 0, c = 1  
  // - Вычисление:
  //   dp[1] = grid[0][1] + Math.min(dp[1], dp[2])
  //   = 3 + min(7, 3) = 6  
  // - dp после шага:
  //   [8, 6, 3, Infinity]
  // 
  // Шаг 9: r = 0, c = 0  
  // - Вычисление:
  //   dp[0] = grid[0][0] + Math.min(dp[0], dp[1])
  //   = 1 + min(8, 6) = 7  
  // - dp после шага:
  //   [7, 6, 3, Infinity]
  // 
  // ---
  // 
  // Итог:
  // после завершения всех итераций
  // dp[0] = 7 — минимальная сумма пути.

  // После обработки всех строк и столбцов
  // dp[0] содержит минимальную сумму пути
  // от верхнего левого угла (0,0) до
  // правого нижнего (ROWS-1,COLS-1)
  // с учётом только движений вправо и вниз.
  //
  // Возвращаем это значение как результат
  // функции.
  return dp[0];
}
