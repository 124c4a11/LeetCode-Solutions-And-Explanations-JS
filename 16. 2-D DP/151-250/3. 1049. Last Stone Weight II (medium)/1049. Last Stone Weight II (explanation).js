/**
 * @param {number[]} stones
 * @return {number}
 * 
 * lastStoneWeightII решает задачу минимизации
 * разницы сумм двух групп камней, эквивалентную
 * нахождению минимально возможного остатка
 * массы после всех последовательных столкновений
 * камней. Она ищет такую разбивку множества
 * весов на две группы, чтобы абсолютная разница
 * их сумм была минимальна, и возвращает эту
 * минимальную разницу как целое число.
 * 
 * Параметры:
 * - stones — массив целых чисел, каждый элемент
 *   которого представляет вес отдельного камня.
 * 
 * Возвращаемое значение:
 *   целое число — минимально возможный итоговый
 *   оставшийся вес после всех столкновений.
 */
function lastStoneWeightII(stones) {

  // Вычисление суммарного веса всех камней:
  //
  // Для примера
  // stones = [2,7,4,1,8,1]
  // результат 23.
  const stoneSum = stones.reduce(
    (a, b) => a + b, 0
  );

  // Вычисление целевой половины от общей
  // суммы.
  //
  // Идея:
  // попытаться разделить камни на две
  // группы с как можно более равными
  // суммами, поэтому максимально
  // достижимая сумма в одной группе не
  // должна превышать stoneSum / 2.
  //
  // Для примера
  // stoneSum = 23 
  // → target = Math.floor(23/2) = 11.
  const target = Math.floor(stoneSum / 2);

  // Инициализация одномерного массива dp
  // длиной target + 1
  //
  // dp[t] будет хранить максимально достижимую
  // сумму ≤ t, используя обработанные до
  // текущего шага камни.
  //
  //
  // Почему инициализируем dp длинной target + 1
  //
  // dp хранит значения для всех возможных
  // целевых сумм от 0 до target включительно.
  // Чтобы иметь доступ к элементу с индексом
  // target, массив должен содержать target + 1
  // элементов.
  //
  //
  // Индексация и границы
  //
  // dp[t] используется для t равного
  // 0, 1, 2, …, target. Если бы массив был
  // бы длины target, индекс dp[target]
  // оказался бы вне границ и вызвал бы
  // ошибку доступа.
  //
  //
  // Логика задачи 0/1 knapsack
  //
  // Задача формулируется как поиск наилучшей
  // суммы не превосходящей target.
  // Нужен отдельный слот для каждой возможной
  // вместимости от 0 до target, поэтому длина
  // равна target + 1.
  //
  //
  // Изначально все значения равны 0:
  // dp = [0,0,0,0,0,0,0,0,0,0,0,0]
  // для target = 11.
  const dp = new Int32Array(target + 1);

  // Начинаем обработку каждого камня по одному
  // (это реализация 0/1 knapsack — каждый
  // предмет (камень) можно взять не более
  // одного раза).
  for (const stone of stones) {

    // Внутренний цикл идёт от target вниз до
    // веса текущего камня включительно.
    //
    // Проход в убывающем порядке предотвращает
    // повторное использование одного и того же
    // камня внутри одной итерации
    // (0/1 knapsack).
    //
    // Когда stone = 2, итерация t = 11..2.
    // Когда stone = 7, t = 11..7; и т.д.
    for (let t = target; t >= stone; t--) {

      // Обновление состояния dp[t]:
      // сравниваем текущее значение dp[t]
      // (сумма без использования текущего
      // камня) и сумму dp[t - stone] + stone
      // (если мы добавляем текущий камень к
      // лучшему решению для (t - stone)).
      //
      // Берём максимум — так мы поддерживаем
      // максимально возможную сумму ≤ t.
      //
      //
      // Причина использования dp[t - stone]
      // 
      // dp[t] хранит наилучшую (максимальную)
      // суммарную массу, которую можно
      // получить, не превышая вместимость t,
      // используя уже рассмотренные камни.
      // Когда мы решаем включить текущий
      // камень весом stone в суммарный вес
      // для ёмкости t, то оставшееся
      // "свободное" место в этой ёмкости
      // равно t − stone. Лучший способ
      // заполнить эту оставшееся место — это
      // именно dp[t - stone]. Поэтому при
      // включении камня итоговая сумма
      // становится dp[t - stone] + stone,
      // что гарантированно не превышает t и
      // использует оптимальный подбор для
      // остатка.
      // 
      // 
      // Формальная интуиция и корректность
      // 
      // - Допустимость:
      //   dp[t - stone] ≤ t - stone по
      //   определению, значит
      //   dp[t - stone] + stone ≤ t.
      // - Оптимальность:
      //   dp[t - stone] — это уже
      //   оптимальное (максимальное)
      //   значение для объёма t - stone
      //   с учётом только предыдущих камней.
      //   Добавляя текущий камень, мы
      //   расширяем это оптимальное решение
      //   до объёма t.
      // - Полное рассмотрение вариантов:
      //   для каждой ёмкости t мы
      //   сравниваем два независимых
      //   варианта — не брать камень (dp[t])
      //   и брать камень
      //   (dp[t - stone] + stone) — и
      //   выбираем максимум, поэтому
      //   результат остаётся оптимальным.
      // 
      // 
      // Почему нельзя просто взять dp[t]
      // или dp[t] + stone
      // 
      // - dp[t] + stone может превысить t,
      //   то есть не является допустимым
      //   решением для ёмкости t.
      // - dp[t - stone] + stone
      //   гарантированно допустим и отражает
      //   добавление именно одного экземпляра
      //   текущего камня к оптимальному
      //   решению для остатка t - stone.
      // - Использование dp[t - stone]
      //   предотвращает двойной учёт
      //   текущего камня, если цикл идёт
      //   в убывающем порядке: мы опираемся
      //   только на значения, вычисленные до
      //   обработки текущего камня.
      // 
      // 
      // Роль обратного прохода по t
      // 
      // При проходе t от большого к малому
      // мы гарантируем, что dp[t - stone]
      // в формуле — это значение, которое
      // не учитывает текущий камень. Если
      // бы мы шли вперёд, то dp[t - stone]
      // мог бы быть уже обновлён в этой же
      // итерации, и текущий камень
      // использовался бы по нескольку раз,
      // что нарушает условие 0/1 knapsack.
      // 
      // 
      // Наглядный пример с числами
      // 
      // Пусть уже обработаны некоторые
      // камни и имеем dp[5] = 5, dp[8] = 7.
      // Рассмотрим текущий камень
      // stone = 3 и ёмкость t = 8.
      // 
      // - Вариант не брать:
      //   оставляем dp[8] = 7.
      // - Вариант брать:
      //   берем dp[8 - stone] + stone
      //   = dp[8 - 3] + 3
      //   = dp[5] + 3
      //   = 5 + 3 = 8,
      //   допустимо потому что 8 ≤ t.
      // - Выбираем максимум:
      //   dp[8] = max(7, 8) = 8. Это
      //   улучшение стало возможным
      //   именно благодаря использованию
      //   dp[t - stone].
      // 
      // 
      // Краткий вывод
      // 
      // dp[t - stone] отражает лучшее,
      // что можно получить для оставшейся
      // ёмкости до добавления текущего
      // камня. Прибавление stone к этому
      // оптимуму даёт корректный и
      // потенциально лучший вариант для
      // ёмкости t, поэтому в формуле
      // сравнивают dp[t]
      // и dp[t - stone] + stone и берут
      // максимум.
      dp[t] = Math.max(
        dp[t],
        dp[t - stone] + stone
      );
    }
  }

  // Формула:
  // result = stoneSum - 2 * dp[target]
  // 
  // 
  // Алгебра
  // - Разбиение множества камней на две группы
  //   эквивалентно распределению сумм S1 и S2
  //   при условии S1 + S2 = stoneSum.
  // - Мы стремимся минимизировать абсолютную
  //   разницу |S1 - S2|.  
  // - Пусть S1 ≤ S2. Тогда |S1 - S2| = S2 - S1.
  //   Из суммы S1 + S2 = stoneSum
  //   следует S2 = stoneSum - S1.  
  // - Подставляя, получаем разницу через одну
  //   группу: 
  ///  |S1 - S2|
  //   = (stoneSum - S1) - S1
  //   = stoneSum - 2 * S1.  
  // - Поэтому минимизация |S1 - S2|
  //   равносильна максимизации S1 при
  //   ограничении S1 ≤ Math.floor(stoneSum / 2).
  // 
  // 
  // Роль dp[target]
  // - dp[t] содержит максимальную достижимую
  //   сумму не превышающую t из доступных
  //   камней.  
  // - Берём t = target = Math.floor(stoneSum / 2),
  //   потому что оптимальная меньшая группа не
  //   должна превышать половины общей суммы.  
  // - Тогда S1 = dp[target] — максимально
  //   возможная сумма меньшей группы.  
  // - Подставляем в формулу разницы и получаем
  //   stoneSum - 2 * dp[target].
  // 
  // 
  // Формальный вывод
  // - Имеем S1 + S2 = stoneSum и S1 ≤ S2.  
  // - Минимизация |S1 - S2| эквивалентна
  //   минимизации stoneSum - 2 * S1.  
  // - Так как S1 не может превышать target,
  //   оптимальный S1 равен 
  //   Math.max{s|s ≤ target, s достижима}
  //   = dp[target].  
  // - Следовательно оптимальная минимальная
  //   разница равна stoneSum - 2 * dp[target].
  // 
  // 
  // Числовой пример для stones = [2,7,4,1,8,1]
  // - stoneSum = 23  
  // - target = Math.floor(23 / 2) = 11.  
  // - После DP достигаем dp[11] = 11.  
  // - Формула даёт result = 23 - 2 * 11 = 1.  
  // - Это соответствует разбиению сумм 11 и 12
  //   и минимальной разнице 1.
  // 
  // 
  // Заметки и границы применимости
  // - Формула корректна для задачи минимизации
  //   разницы сумм при разбиении на две
  //   подгруппы.  
  // - Если stoneSum чётно и существует разбиение
  //   на две равные суммы,
  //   то dp[target] = target и результат равен
  //   нулю.  
  // - Если для некоторого набора элементов
  //   нельзя точно достичь target, dp хранит
  //   наилучшее возможное значение меньше
  //   target, и формула правильно отражает
  //   минимальную разницу.
  return stoneSum - 2 * dp[target];

  // Пример работы функции для
  // stones = [2, 7, 4, 1, 8, 1]  
  //
  // Начальные значения 
  // - stoneSum = 23  
  // - target = 11  
  // - dp = [0,0,0,0,0,0,0,0,0,0,0,0]
  //
  // ---
  //
  // Обработка stone = 2  
  // Итерации внутреннего цикла t от 11 до 2
  // (для краткости показываю только t,
  // где dp меняется):
  //
  // - t = 11: 
  //     dp[11]
  //       = max(dp[11], dp[9] + 2)
  //       = max(0, 0 + 2) = 2  
  // - t = 10: 
  //     dp[10]
  //       = max(dp[10], dp[8] + 2)
  //       = max(0, 0 + 2) = 2  
  // - t = 10: 
  // - ...  
  // - t = 2:
  //    dp[2]
  //      = max(dp[2], dp[0] + 2)
  //      = max(0, 0 + 2) = 2  
  //
  // dp после 2:  
  // index:  0  1  2  3  4  5  6  7  8  9  10 11  
  // dp:     0  0  2  2  2  2  2  2  2  2   2  2
  //
  // ---
  //
  // ### Обработка stone = 7  
  // Итерации t от 11 до 7:
  //
  // - t = 11:
  //     dp[11]
  //       = max(2, dp[4] + 7)
  //       = max(2, 2 + 7) = 9  
  // - t = 10:
  //     dp[10]
  //       = max(2, dp[3] + 7)
  //       = max(2, 2 + 7) = 9  
  // - t = 9:
  //     dp[9]
  //       = max(2, dp[2] + 7)
  //       = max(2, 2 + 7) = 9  
  // - t = 8:
  //     dp[8]
  //       = max(2, dp[1] + 7)
  //       = max(2, 0 + 7) = 7  
  // - t = 7:
  //     dp[7]
  //     = max(2, dp[0] + 7)
  //     = max(2, 0 + 7) = 7
  //
  // dp после 7:  
  // index:  0  1  2  3  4  5  6  7  8  9  10 11  
  // dp:     0  0  2  2  2  2  2  7  7  9   9  9
  //
  // ---
  //
  // Обработка stone = 4  
  // Итерации t от 11 до 4:
  //
  // - t = 11:
  //     dp[11]
  //       = max(9, dp[7] + 4)
  //       = max(9, 7 + 4) = 11  
  // - t = 10:
  //     dp[10]
  //       = max(9, dp[6] + 4)
  //       = max(9, 2 + 4) = 9 (остается 9)  
  // - t = 9:
  //     dp[9]
  //       = max(9, dp[5] + 4)
  //       = max(9, 2 + 4) = 9  
  // - t = 8:
  //     dp[8]
  //       = max(7, dp[4] + 4)
  //       = max(7, 2 + 4) = 6 (остаётся 7)
  // - t = 7:
  //     dp[7]
  //       = max(7, dp[3] + 4)
  //       = max(7, 2 + 4) = 7  
  // - t = 6:
  //     dp[6]
  //       = max(2, dp[2] + 4)
  //       = max(2, 2 + 4) = 6  
  // - t = 5:
  //     dp[5]
  //       = max(2, dp[1] + 4)
  //       = max(2, 0 + 4) = 4  
  // - t = 4:
  //     dp[4]
  //       = max(2, dp[0] + 4)
  //       = max(2, 0 + 4) = 4  
  //
  // dp после 4:  
  // index:  0  1  2  3  4  5  6  7  8  9  10 11  
  // dp:     0  0  2  2  4  4  6  7  7  9   9 11
  //
  // ---
  //
  // Обработка stone = 1 (первый 1)  
  // Итерации t от 11 до 1:
  //
  // - t = 11:
  //     dp[11]
  //       = max(11, dp[10] + 1)
  //       = max(11, 9 + 1) = 11 (остаётся 11) 
  // - t = 10:
  //     dp[10]
  //       = max(9, dp[9] + 1)
  //       = max(9, 9 + 1) = 10  
  // - t = 9:
  //     dp[9]
  //       = max(9, dp[8] + 1)
  //       = max(9, 7 + 1) = 8 (остаётся 9)
  // - t = 8:
  //     dp[8]
  //       = max(7, dp[7] + 1)
  //       = max(7, 7 + 1) = 8  
  // - t = 7:
  //     dp[7]
  //       = max(7, dp[6] + 1)
  //       = max(7, 6 + 1) = 7 (остаётся 7)  
  // - t = 6:
  //     dp[6]
  //       = max(6, dp[5] + 1)
  //       = max(6, 4 + 1) = 6  
  // - t = 5:
  //     dp[5]
  //       = max(4, dp[4] + 1)
  //       = max(4, 4 + 1) = 5  
  // - t = 4:
  //     dp[4]
  //       = max(4, dp[3] + 1)
  //       = max(4, 2 + 1) = 4  
  // - t = 3:
  //     dp[3]
  //       = max(2, dp[2] + 1)
  //       = max(2, 2 + 1) = 3  
  // - t = 2:
  //     dp[2]
  //       = max(2, dp[1] + 1)
  //       = max(2, 0 + 1) = 2  
  // - t = 1:
  //     dp[1]
  //       = max(0, dp[0] + 1)
  //       = max(0, 0 + 1) = 1
  //
  // dp после первого 1:  
  // index:  0  1  2  3  4  5  6  7  8  9  10 11  
  // dp:     0  1  2  3  4  5  6  7  8  9  10 11
  //
  // ---
  //
  // Обработка stone = 8  
  // Итерации t от 11 до 8:
  //
  // - t = 11:
  //     dp[11]
  //       = max(11, dp[3] + 8)
  //       = max(11, 3 + 8) = 11 (остается 11)
  // - t = 10:
  //     dp[10]
  //       = max(10, dp[2] + 8)
  //       = max(10, 2 + 8) = 10 (остается 10)
  // - t = 9:
  //     dp[9]
  //       = max(9, dp[1] + 8)
  //       = max(9, 1 + 8) = 9 (остается 9)
  // - t = 8:
  //     dp[8]
  //       = max(8, dp[0] + 8)
  //       = max(8, 0 + 8) = 8 (остается 8)
  //
  // dp после 8 (без изменений в значениях по
  // сравнению с предыдущим шагом):  
  // index:  0  1  2  3  4  5  6  7  8  9  10 11  
  // dp:     0  1  2  3  4  5  6  7  8  9  10 11
  //
  // ---
  //
  // Обработка stone = 1 (второй 1)  
  // Итерации t от 11 до 1:
  //
  // - Все кандидаты dp[t-1] + 1 не превосходят
  //   уже достигнутых значений, поэтому dp
  //   остаётся без изменений.
  //
  // Итоговый dp:  
  // index:  0  1  2  3  4  5  6  7  8  9  10 11  
  // dp:     0  1  2  3  4  5  6  7  8  9  10 11
  //
  // ---
  //
  // Итоговое вычисление ответа
  // - dp[target] = dp[11] = 11  
  // - Ответ
  //     = stoneSum - 2 * dp[target]
  //     = 23 - 2*11 = 1
  //
  // Функция возвращает 1.
}
