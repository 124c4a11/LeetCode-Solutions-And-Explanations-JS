/**
 * @param {number[][]} grid
 * @return {number}
 * 
 * Функция uniquePathsWithObstacles принимает
 * аргумент grid — двумерный массив чисел,
 * где 0 обозначает свободную клетку,
 * 1 — препятствие.
 * 
 * Функция вычисляет число различных путей
 * от верхнего левого угла до нижнего правого,
 * двигаясь только вправо и вниз, модифицируя
 * grid in-place.
 */
function uniquePathsWithObstacles(grid) {

  // Получаем количество строк в матрице
  // grid и сохраняем в константу ROWS
  const ROWS = grid.length;

  // Предполагаем, что grid не пустой и
  // сохраняем количество столбцов первой
  // строки в константу COLS
  const COLS = grid[0].length;

  // Проверяем сразу два базовых случая:
  if (

    // Если начальная клетка (0,0)
    // равна 1, то старт заблокирован
    grid[0][0] === 1

    // Или если конечная клетка
    // (ROWS-1,COLS-1) равна 1,
    // то финиш заблокирован
    || grid[ROWS - 1][COLS - 1] === 1

    // В обоих случаях возвращаем 0
    // — не существует ни одного пути
    // от старта до финиша 
  ) return 0;


  // Устанавливаем значение целевой
  // клетки равным 1.
  //
  // Это служит базовым случаем для
  // обратного динамического
  // программирования: считается, что
  // есть ровно 1 способ "добраться до
  // цели из самой цели".
  //
  // Важно:
  // первоначальное значение могло
  // быть 0, но здесь мы записываем 1,
  // и дальше все соседние клетки будут
  // ссылаться на это значение.
  grid[ROWS - 1][COLS - 1] = 1;

  // Внешний цикл:
  // Проходим по строкам в обратном
  // порядке (снизу вверх). Это позволяет
  // при обработке ячейки иметь готовые
  // вычисленные значения для ячеек
  // справа и снизу.
  for (let r = ROWS - 1; r >= 0; r--) {

    // Внутренний цикл:
    // Проходим по столбцам в обратном
    // порядке (справа налево) по тем
    // же причинам: чтобы при обращении
    // к ячейке справа или снизу эти
    // значения уже были вычислены.
    for (let c = COLS - 1; c >= 0; c--) {

      // Если мы находимся в клетке
      // финиша (той самой, значение
      // которой уже установили в 1),
      // пропускаем её обработку,
      // потому что её значение
      // уже корректно установлено
      // как базовый случай.
      if (
        r === ROWS - 1
        && c === COLS - 1
      ) continue;

      // Если текущая ячейка содержит
      // препятствие (1), то меняем 
      // ее значение на 0.
      //
      // Объяснение:
      // ранее 1 означало препятствие,
      // но в дальнейших вычислениях
      // мы используем численные значения
      // указывающие на количество путей.
      //
      // Преобразуем семантику:
      // здесь 0 обозначает "нет путей
      // из этой клетки", что корректно
      // для препятствия.
      if (grid[r][c] === 1) {
        grid[r][c] = 0;

        // Иначе клетка свободна,
        // считаем количество путей из
        // нее как сумма путей из
        // клетки ниже (r+1,c) и из
        // клетки справа (r,c+1)
      } else {

        // Если есть строка ниже текущей
        // (r+1 < ROWS), то значение
        // downWays берём из ячейки снизу
        // grid[r+1][c], иначе 0.
        //
        // Это количество путей из текущей
        // клетки, которые идут сначала
        // вниз.
        const downWays = r + 1 < ROWS
          ? grid[r + 1][c]
          : 0;

        // Если есть столбец справа от
        // текущего (c+1 < COLS), то
        // значение rightWays берём из
        // ячейки справа grid[r][c+1],
        // иначе 0.
        //
        // Это количество путей из
        // текущей клетки, которые идут
        // сначала вправо.
        const rightWays = c + 1 < COLS
          ? grid[r][c + 1]
          : 0;

        // Общее количество путей из
        // текущей ячейки равно сумме
        // путей, идущих вниз и вправо.
        //
        // Записываем это значение в
        // саму ячейку grid[r][c],
        // перезаписывая исходное 0
        // (или уже преобразованное
        // значение).
        //
        // Таким образом мы выполняем
        // динамическое программирование
        // in-place и экономим
        // дополнительную память.
        grid[r][c] = downWays + rightWays;
      }
    }
  }

  // Пример работы цикла
  //
  // Исходное состояние:
  //
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 0,  1,  0 ],
  //   [ 0,  0,  0 ]
  // ]
  //
  // Перед запуском цикла, согласно основной
  // логике алгоритма, мы устанавливаем:
  // grid[2][2] = 1; — нижний правый угол
  // — целевая точка
  //
  // Теперь:
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 0,  1,  0 ],
  //   [ 0,  0,  1 ]
  // ]
  //
  //
  // Шаг 1: r = 2, c = 1  
  // - grid[2][1] === 0  
  // - downWays = 0 (нет строки ниже)  
  // - rightWays = grid[2][2] = 1  
  // - grid[2][1] = 0 + 1 = 1
  //
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 0,  1,  0 ],
  //   [ 0,  1*  1 ]
  // ]
  //
  //
  // Шаг 2: r = 2, c = 0  
  // - grid[2][0] === 0  
  // - downWays = 0  
  // - rightWays = grid[2][1] = 1  
  // - grid[2][0] = 0 + 1 = 1
  //
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 0,  1,  0 ],
  //   [ 1*  1,  1 ]
  // ]
  //
  //
  // Шаг 3: r = 1, c = 2  
  // - grid[1][2] === 0  
  // - downWays = grid[2][2] = 1  
  // - rightWays = 0  
  // - grid[1][2] = 1 + 0 = 1
  //
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 0,  1,  1*],
  //   [ 1,  1,  1 ]
  // ]
  //
  //
  // Шаг 4: r = 1, c = 1  
  // - grid[1][1] === 1 → препятствие  
  // - grid[1][1] = 0
  //
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 0,  0*  1 ],
  //   [ 1,  1,  1 ]
  // ]
  //
  //
  // Шаг 5: r = 1, c = 0  
  // - grid[1][0] === 0  
  // - downWays = grid[2][0] = 1  
  // - rightWays = grid[1][1] = 0  
  // - grid[1][0] = 1 + 0 = 1
  //
  // grid = [
  //   [ 0,  0,  0 ],
  //   [ 1*  0,  1 ],
  //   [ 1,  1,  1 ]
  // ]
  //
  //
  // Шаг 6: r = 0, c = 2  
  // - grid[0][2] === 0  
  // - downWays = grid[1][2] = 1  
  // - rightWays = 0  
  // - grid[0][2] = 1 + 0 = 1
  //
  // grid = [
  //   [ 0,  0,  1*],
  //   [ 1,  0,  1 ],
  //   [ 1,  1,  1 ]
  // ]
  //
  //
  // Шаг 7: r = 0, c = 1  
  // - grid[0][1] === 0  
  // - downWays = grid[1][1] = 0  
  // - rightWays = grid[0][2] = 1  
  // - grid[0][1] = 0 + 1 = 1
  //
  // grid = [
  //   [ 0,  1*  1 ],
  //   [ 1,  0,  1 ],
  //   [ 1,  1,  1 ]
  // ]
  //
  //
  // Шаг 8: r = 0, c = 0  
  // - grid[0][0] === 0  
  // - downWays = grid[1][0] = 1  
  // - rightWays = grid[0][1] = 1  
  // - grid[0][0] = 1 + 1 = 2
  //
  // grid = [
  //   [ 2*  1,  1 ],
  //   [ 1,  0,  1 ],
  //   [ 1,  1,  1 ]
  // ]
  //
  //
  // Финальный результат:
  // grid[0][0] = 2 — это количество
  // уникальных путей от верхнего левого
  // угла до нижнего правого, обходя
  // препятствия.

  // Возвращаем значение в стартовой ячейке
  // grid[0][0], которое после выполнения
  // циклов содержит общее количество путей
  // от старта до цели.
  return grid[0][0];
}
