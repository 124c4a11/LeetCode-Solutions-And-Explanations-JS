/**
 * @param {string[]} words
 * @param {string} order
 * @return {boolean}
 * 
 * isAlienSorted принимает на вход массив
 * слов words и строку order — алфавит
 * пришельцев, который задаёт порядок букв
 * в "инопланетном" алфавите и проверяет,
 * упорядочены ли слова согласно новому
 * алфавиту.
 * 
 * Пример:
 * words = ["hello", "leetcode"],
 * order = "hlabcdefgijkmnopqrstuvwxyz"
 * 
 * Ожидаемый результат:
 * true, так как 'h' < 'l' в новом алфавите
 */
function isAlienSorted(words, order) {

  // Создаём массив длины 26
  // (число букв английского алфавита),
  // заполненный нулями, для хранения
  // позиции каждой буквы пришельцев,
  // где
  // индеск - позиция буквы в английском
  //          алфавите
  // значение - позиция буквы в
  //            инопланетном алфавите
  const orderIndex = new Int32Array(26);

  // Заполняем orderIndex:
  // для каждой буквы в order сохраняем
  // её позицию в "инопланетном" алфавите
  //
  // Вычисляем числовой код буквы
  // минус код 'a' (97), чтобы
  // получить индекс в массиве (0–25).
  //
  // Для 'h' это
  // charCodeAt = 104,
  // 104 - 97 = 7.
  // В order 'h' стоит на позиции 0,
  // поэтому orderIndex[7] = 0.
  //
  // i = 0 → буква 'h', код 104,
  //         104 − 97 = 7,
  //         orderIndex[7] = 0
  // i = 1 → буква 'l', код 108,
  //         108 − 97 = 11,
  //         orderIndex[11] = 1
  // i = 2 → буква 'a', код 97,
  //         97 − 97 = 0,
  //         orderIndex[0] = 2
  for (let i = 0; i < order.length; i++) {
    orderIndex[order.charCodeAt(i) - 97] = i;
  }

  // Проходим по парам соседних слов
  // в words, начиная со второго,
  // чтобы иметь возможность получить
  // доступ одновременно к текущему и
  // предыдущему слову уже на первом
  // шаге и убедиться, что они
  // упорядочены
  //
  // Пример:
  // для words = ["hello","leetcode"]
  // пройдём i=1 и сравним "hello" и "leetcode"
  for (let i = 1; i < words.length; i++) {

    // Предыдущее слово для сравнения
    const w1 = words[i - 1];

    // Текущее слово для сравнения
    const w2 = words[i];

    // Сравниваем посимвольно буквы
    // двух слов w1 и w2
    //
    // Для примера:
    // w1 = "hello",
    // w2 = "leetcode"
    for (let j = 0; j < w1.length; j++) {

      // Если мы дошли до конца второго
      // слова, но первое длиннее
      // — порядок нарушен, возвращаем 
      // false.
      //
      // По правилам лексикографической
      // (словарйной) сортировки более
      // короткое слово с тем же
      // префиксом должно идти раньше.
      // Если же в списке стоит длинное
      // слово, а потом слово-префикс, мы
      // сразу возвращаем false.
      //
      // Когда мы в цикле доходим до 
      // j === w2.length, а цикл всё ещё
      // не завершился по условию
      // j < w1.length - это означает что:
      //  1. У слов w1 и w2 полностью
      //     совпадает префикс длиной
      //     w2.length.
      //  2. Второе слово закончилось,
      //     а первое всё ещё длиннее.
      //
      // Пример: 
      // если
      // w1 = "apple", 
      // w2 = "app"
      // → false 
      // (должно быть "app" перед "apple"
      if (j === w2.length) return false;

      // Если символы на позиции j совпадают,
      // продолжаем сравнение дальше.
      if (w1[j] === w2[j]) continue;

      // Получаем позиции буквы w1[j] и w2[j]
      // в алфавите пришельцев
      // Если позиция буквы из w1 больше,
      // чем позиция буквы из w2,
      // значит w1[j] идёт позже, чем w2[j],
      // и порядок слов нарушен - возвращаем 
      // false.
      if (
        orderIndex[w1.charCodeAt(j) - 97]
        > orderIndex[w2.charCodeAt(j) - 97]
      ) return false;

      // Если мы дошли до первой отличающейся
      // буквы и порядок соблюдён, можно
      // прекратить сравнение этой пары слов
      // и перейти к следующей. Дальнейшие
      // символы сравнивать не нужно.
      //
      // Почему после первой отличающейся
      // буквы можно прерывать сравнение
      //
      // Первая отличающаяся буква между двумя
      // словами определяет их лексикографический
      // порядок. Как только мы выяснили,
      // что буква из первого слова стоит раньше
      // (или позже) буквы из второго в заданном
      // алфавите, никакие последующие символы не
      // могут изменить этот результат.
      //
      // Используя  break, мы говорим:
      // - Для этой пары слов всё ок, дальше
      //   сравнивать буквы не нужно, переходим
      //   к следующей паре слов.
      // - И только если вдруг найдём нарушение,
      //   при котором буква из первого слова
      //   должна идти позже буквы из второго в
      //   заданном алфавите вернем false.
      break;
    }
  }

  // Если ни в одной паре слов не обнаружено нарушение
  // порядка, возвращаем true.
  return true;
}
