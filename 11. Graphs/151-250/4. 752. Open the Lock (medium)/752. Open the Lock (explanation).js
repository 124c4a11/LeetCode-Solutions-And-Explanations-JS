/**
 * @param {string[]} deadends
 * @param {string} target
 * @return {number}
 * 
 * Функция openLock ищет минимальное
 * число ходов, чтобы открыть цифровой
 * замок с четырьмя колёсами, начиная
 * с комбинации "0000" и приходя к
 * заданной цели target, при этом избегая
 * запрещённых комбинаций из массива
 * deadends. Если достичь цели невозможно
 * или исходная позиция уже запрещена,
 * возвращает -1. Если цель совпадает с
 * начальной "0000", сразу возвращает 0. 
 * 
 * openLock принимает два параметра:
 * deadends — массив строк с
 *   «запрещёнными» комбинациями,
 * target — строка с целевой комбинацией,
 *   которую нужно открыть.
 * 
 * Например:
 * openLock(["0201","0101"], "0202")
 * результат 4
 */
function openLock(deadends, target) {

  // Если сразу задана начальная
  // комбинация «0000», замок открыт
  // без единого хода
  if (target === '0000') return 0;

  // Создаём множество посещённых комбинаций,
  // сразу добавив все «deadends».
  //
  // Это позволяет за O(1) проверять,
  // является ли комбинация посещенной
  // или запрещенной
  //
  // Пример:
  // new Set(["0201","0101"])
  // после этого visited = {"0201", "0101"}
  const visited = new Set(deadends);

  // Если начальная комбинация "0000"
  // сразу содержится в списке
  // запретов, открыть замок невозможно
  // - возвращаем -1
  if (visited.has('0000')) return -1;

  // Фронт поиска «с начала»: множество
  // текущих комбинаций на данном уровне
  // BFS.
  //
  // Сначала это только «0000».
  let begin = new Set(['0000']);

  // Встречный фронт поиска «с конца»:
  // множество кобинаций, достигнутых
  // от целевой комбинации.
  //
  // Для двунаправленного BFS стартуем
  // с target.
  //
  // Для примера end = {"0202"}
  let end = new Set([target]);

  // Счётчик сделанных шагов
  // (уровней BFS)
  let steps = 0;

  // Пока оба фронта непусты, продолжаем
  // двунаправленный поиск BFS
  while (begin.size && end.size) {

    // Оптимизация:
    // Всегда расширяем тот фронт,
    // который меньше, чтобы сократить
    // число проверок.
    //
    // Если текущий «begin» больше «end»,
    // меняем их местами.
    if (begin.size > end.size) {
      [begin, end] = [end, begin];
    }

    // Переходим на следующий уровень:
    // увеличиваем счётчик ходов.
    steps++;

    // Временное множество для накопления
    // новых кобинаций этого уровня.
    const tmp = new Set();

    // Проходим по всем комбинациям
    // текущего фронта «begin».
    for (const lock of begin) {

      // Проходим по каждой из 4 позиций
      // колёсика (цифры) в комбинации.
      for (let i = 0; i < 4; i++) {

        // Пробуем два направления
        // поворота:
        // -1 (назад) и +1 (вперёд).
        for (const j of [-1, 1]) {

          // Вычисляем новую цифру
          // с учётом цикличного
          // перехода 0↔9
          //
          // Текущая цифра lock[i]
          // как число + смещение j,
          // с учётом циклического
          // перехода по модулю 10
          // (мод 10).
          //
          // «Мод 10» (операция
          // остатка от деления на 10)
          // означает, что после суммы
          // или вычитания мы берём
          // остаток от деления
          // результата на 10, чтобы
          // получить число в диапазоне
          // от 0 до 9.
          //
          // Это обеспечивает «циклический»
          // переход: шаг за 9 вперёд
          // возвращает к 0, а шаг за 0
          // назад — к 9.
          //
          // Добавление «+10» перед взятием
          // остатка позволяет корректно
          // обрабатывать отрицательные
          // промежуточные значения
          // (например, −1 превращается в 9,
          // а не остаётся −1).
          //
          // Примеры:
          // - Если текущая цифра 9
          //   и мы добавляем 1:
          //     (9 + 1 + 10) % 10 = 20 % 10 = 0
          //     результат = 0
          // - Если текущая цифра 0
          //   и мы вычитаем 1:
          //     (0 - 1 + 10) % 10 = 9 % 10 = 9
          //      результат = 9
          //
          // Пример:
          // если lock="0000", i=0, j=-1
          // → (0−1+10)%10 = 9 → «9000».
          const digit =
            (Number(lock[i]) + j + 10) % 10;

          // Формируем новую комбинацию,
          // заменяя символ в позиции i
          // на digit
          //
          // Пример:
          // lock="0293", i=2, digit=0 → "0203"
          const nextLock =
            lock.slice(0, i)
            + digit
            + lock.slice(i + 1);

          // Если новая кобинация уже есть
          // во встречном фронте «end»,
          // значит пути встретились, и мы
          // нашли кратчайший путь длины steps
          // – возвращаем количество шагов
          //
          // Пример:
          // на шаге 4 один из фронтов найдёт
          // "0001" в противоположном
          // → return 4
          if (end.has(nextLock)) return steps;

          // Если комбинация уже посещена
          // или запрещена, пропускаем её
          if (visited.has(nextLock)) continue;


          // Иначе отмечаем комбинацию как
          // посещённую, чтобы не
          // обрабатывать её повторно
          visited.add(nextLock);

          // И сохраняем ее во временном
          // множестве для следующего уровня
          tmp.add(nextLock);
        }
      }
    }

    // Готовимся к следующему уровню
    // - обновляем begin:
    //
    // Пример: 
    // tmp после шага 1:
    //   {"1000","9000","0100","0900",
    //    "0010","0090","0001","0009"}
    // tmp после шага 2:
    //   {"1202","3202","0102","0302",
    //    "0292","0212","0203","9202"}
    begin = tmp;
  }

  // Если оба фронта исчерпались
  // и не встретились, решения нет.
  return -1;
}
