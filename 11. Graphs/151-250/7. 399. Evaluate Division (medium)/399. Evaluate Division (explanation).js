/**
 * @param {string[][]} equations
 * @param {number[]} values
 * @param {string[][]} queries
 * @return {number[]}
 * 
 * 
 * calcEquation решает задачу вычисления значений
 * дробных отношений между переменными
 * на основе заданных уравнений и значений.  
 * 
 * Она принимает три аргумента:  
 * - equations — список пар переменных, задающих
 *     уравнения вида a / b.  
 * - values — числовые результаты этих уравнений.  
 * - queries — список запросов, где нужно найти
 *     значение отношения src / target.  
 * 
 * На выходе функция возвращает массив чисел,
 * где каждый элемент — это ответ на
 * соответствующий запрос: либо вычисленное
 * значение, либо -1, если деление невозможно. 
 * 
 * Пример:
 *  Для:
 *    equations = [["a","b"], ["b","c"]],
 *    values = [2.0, 3.0],
 *    queries = [
 *      ["a","c"], ["b","a"], ["a","e"],
 *      ["a","a"], ["x","x"]
 *    ]
 * 
 *  Результат:
 *    [
 *      6.00000, 0.50000, -1.00000,
 *      1.00000, -1.00000
 *    ]
 * 
 *    queries = [
 *      ["a","c"] →  6.0,
 *      ["b","a"] →  0.5,
 *      ["a","e"] → -1 (узла e нет),
 *      ["a","a"] →  1 (одинаковые переменные),
 *      ["x","x"] → -1 (узла x нет)
 *    ]
 */
function calcEquation(equations, values, queries) {

  // Создаём пустой Map для хранения списка
  // смежности графа
  //
  // Будет содержать для каждого узла массив
  // пар [сосед, вес ребра]
  const adj = new Map();

  // Итерируемся по каждому уравнению
  // и соответствующему значению
  //
  // Для примера:
  // equations = [["a","b"], ["b","c"]]
  // values = [2.0, 3.0]
  for (let i = 0; i < equations.length; i++) {

    // Деструктурируем текущее уравнение
    // в переменные a и b
    //
    // Пример:
    // на первом i = 0: [a, b];
    // на втором i = 1: [b, c]
    const [a, b] = equations[i];

    // Если в графе еще нет узла a, добавляем
    // его с пустым списком смежности (соседей)
    //
    // После первой итерации adj будет:
    // { "a": [] }
    if (!adj.has(a)) adj.set(a, []);


    // Если в графе еще нет узла b, добавляем
    // его с пустым списком смежности (соседей)
    //
    // После первой итерации adj будет:
    // { "a": [], "b": [] }
    if (!adj.has(b)) adj.set(b, []);

    // Добавляем ребро a → b
    // с весом values[i]
    //
    // Пример 1-я итерация:
    // adj.get("a").push(["b", 2.0])
    adj.get(a).push([b, values[i]]);

    // Добавляем обратное ребро b → a
    // с весом 1/values[i]
    //
    // Это нужно, чтобы можно было двигаться
    // по графу в обоих направлениях
    //
    // Пример 1-я итерация:
    // adj.get("b").push(["a", 1/2])
    adj.get(b).push([a, 1 / values[i]]);

    // После цикла для:
    // equations = [["a","b"], ["b","c"]]
    // values = [2.0, 3.0]
    // 
    // Граф выглядит так:
    // adj = {
    //   "a": [["b", 2.0]],
    //   "b": [["a", 0.5], ["c", 3.0]],
    //   "c": [["b", 1/3]]
    // }
  }

  // Рекурсивная функция DFS для поиска пути
  // src → target и поиска коэффициента
  // деления src/target
  //
  // visited — множество уже посещенных узлов,
  // чтобы избежать циклов
  function dfs(src, target, visited) {

    // Если один из узлов отсутствует,
    // результат неопределен (-1)
    //
    // Например, для query ["a","e"]:
    // adj.has("e") === false → return -1
    if (
      !adj.has(src)
      || !adj.has(target)
    ) return -1;

    // Если src и target совпадают,
    // возвращаем 1 (деление само на себя)
    //
    // Пример:
    // запрос ["a","a"] вернет 1
    if (src === target) return 1;

    // Помечаем текущий узел src как
    // посещенный, чтобы не зациклиться
    visited.add(src);

    // Перебираем всех соседей текущего узла src
    for (const [nei, weight] of adj.get(src)) {

      // Пропускаем уже посещенные узлы,
      // чтобы избежать зацикливания
      if (visited.has(nei)) continue;

      // Рекурсивно пытаемся найти путь
      // и коэффициент отношения
      // от nei к target
      const result = dfs(nei, target, visited);

      // Если путь найден (result != -1),
      // умножаем вес текущего ребра на result
      //
      // Пример для ["a","c"]: 
      //  dfs("a","c") -> переберет nei="b",
      //                  weight=2.0
      //    dfs("b","c") вернет 3.0,
      //        значит итог = 2.0 * 3.0 = 6.0
      if (result !== -1) {
        return weight * result;
      }
    }

    // Если ни один путь не привел
    // к цели — возвращаем -1
    return -1;
  };

  // Обрабатываем каждый запрос и запускаем dfs
  // с пустым множеством visited
  //
  // Для:
  // equations = [["a","b"],["b","c"]],
  // values = [2.0,3.0],
  // queries = [
  //   ["a","c"],["b","a"],["a","e"],
  //   ["a","a"],["x","x"]
  // ]
  //
  // queries = [
  //   ["a","c"] →  6.0,
  //   ["b","a"] →  0.5,
  //   ["a","e"] → -1 (узла e нет),
  //   ["a","a"] →  1 (одинаковые переменные),
  //   ["x","x"] → -1 (узла x нет)
  // ]
  return queries.map(
    ([src, target]) => dfs(src, target, new Set())
  );
}
