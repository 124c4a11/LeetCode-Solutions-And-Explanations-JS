/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 * 
 * findMinHeightTrees ищет все возможные корни
 * (центры) дерева с минимальной высотой (MHT)
 * в неориентированном графе и возвращает
 * массив их индексов
 * 
 * В любом неориентированном дереве число
 * центров равняется либо 1, либо 2.
 * - Если диаметр дерева (длина самого длинного
 *   пути) чётный, центр один.
 * - Если диаметр нечётный, центров два
 *   (два соседних узла).
 *
 * Таким образом, максимальное количество
 * центров не превышает двух.
 * 
 * Параметры:
 *
 *  n
 *   - Целое число, задающее количество узлов
 *     в дереве.  
 *   - Узлы пронумерованы от 0 до n−1.
 *
 *  edges
 *   - Массив ребер длины n−1, где каждое ребро
 *     представлено двоичным массивом [a, b].  
 *   - Пара [a, b] означает, что существует
 *     неориентированное соединение между узлами
 *     a и b.
 * 
 * Пример:
 *   Для:
 *     n = 4
 *     edges = [[1,0],[1,2],[1,3]]
 * 
 *   Результат:
 *     [1]
 */
function findMinHeightTrees(n, edges) {

  // Если в графе один узел, он автоматически
  // является центром дерева минимальной
  // высоты
  //
  // Пример:
  // если n = 1, edges = [] → возвращаем [0]
  if (n === 1) return [0];

  // Создаем список смежности: массив длины n,
  // в котором для каждой вершины изначально
  // пустой список соседей
  //
  // Для примера:
  // n = 4 → adj = [[], [], [], []]
  const adj = Array.from({ length: n }, () => []);

  // Заполняем список смежности на основе
  // каждого ребра [a, b]
  // После обработки edges = [[1,0],[1,2],[1,3]]
  //
  // Шаг 1:
  //   adj[1].push(0)
  //   adj[0].push(1)
  //   → adj = [[1], [0], [], []]
  //
  // Шаг 2:
  //   adj[1].push(2)
  //   adj[2].push(1)
  //   → adj = [[1], [0,2], [1], []]
  //
  // Шаг 3:
  //   adj[1].push(3)
  //   adj[3].push(1)
  //   → adj = [[1], [0,2,3], [1], [1]]
  //
  // Полученный граф из adj где:
  //   i - узел 
  //   adj[i] - соседи узла i
  //   Например 
  //   для узла i=1 → соседи [0,2,3]
  //
  //      0
  //      |
  //      1*
  //     / \
  //    2   3
  //
  for (const [a, b] of edges) {
    adj[a].push(b);
    adj[b].push(a);
  }

  // Создаем массив edgeCnt, чтобы хранить
  // текущую степень (число смежных узлов
  // (соседей)) для каждого узла
  //
  // Для примера после инициализации
  // (цикла) степени будут:
  // edgeCnt = [1, 3, 1, 1]
  const edgeCnt = new Int32Array(n);

  // Инициализируем очередь leaves для
  // хранения листовых вершин, у которых
  // степень (количество соседей) = 1
  //
  // Изначально leaves пустая.
  //
  // Для примера после инициализации
  // (цикла) очередь будет:
  // leaves = [0, 2, 3]
  const leaves = new Queue();
  for (let i = 0; i < n; i++) {

    // Сохраняем количество соседей
    // в edgeCnt[i]
    edgeCnt[i] = adj[i].length;

    // Если узел i — лист
    // (имеет ровно одного соседа),
    // добавляем его в очередь
    //
    // Для примера leaves = [0, 2, 3]
    if (adj[i].length === 1) {
      leaves.push(i);
    }
  }

  // Итеративно «срезаем» листья, сужая граф,
  // пока не останутся тлько центры (≤ 2 узлов)
  while (!leaves.isEmpty()) {

    // Как только общее число узлов
    // сократилось до двух или менее — это
    // наши центры
    //
    // В нашем примере после снятия первого
    // слоя n станет 1,
    // а leaves.toArray() = [1]
    //
    // Визуализация:
    // У графа удаляем листы [0, 2, 3]
    //
    //      0*
    //      |
    //      1
    //     / \
    //    2*  3*
    //
    // Остается только центральный узел - 1
    //
    //      1
    //
    if (n <= 2) return leaves.toArray();

    // Определяем число листьев в текущем
    // слое
    const size = leaves.size();

    // Удаляем каждый лист этого слоя
    // и обновляем степень его соседей
    for (let i = 0; i < size; i++) {

      // Извлекаем лист из очереди
      const node = leaves.pop();

      // Удаляем его из графа:
      // уменьшаем общее число узлов
      n--;

      // Для каждого соседа удаленного
      // узла удаляем связь, уменьшая
      // его степень на 1
      for (const nei of adj[node]) {

        // удаляем связь, уменьшая степень
        // текущего соседа
        edgeCnt[nei]--;

        // Если после уменьшения степени
        // сосед стал листом (степень = 1),
        // помещаем его в очередь
        if (edgeCnt[nei] === 1) {
          leaves.push(nei);
        }

        // Пошаговый пример удаления:
        // Начало:
        // n=4,
        // leaves=[0,2,3],
        // edgeCnt=[1,3,1,1]
        //
        // Шаг 1:
        //   Удаляем 0 → n=3,
        //   уменьшаем edgeCnt[1] до 2
        //   → leaves=[2,3]
        //
        // Шаг 2:
        //   Удаляем 2 → n=2,
        //   уменьшаем edgeCnt[1] до 1,
        //   1 стал листом - добавляем
        //   его в очередь
        //   → leaves=[3,1]
        //
        // Шаг 3:
        //   Удаляем 3 → n=1,
        //   уменьшаем edgeCnt[1] до 0
        //   → leaves=[1]
        //
        // Теперь n <= 2, возвращаем [1]
      }
    }
  }

  // Если по каким-то причинам мы не вышли
  // из цикла раньше — возвращаем пустой массив
  //
  // (в связном дереве этот return недостижим)
  return [];
}
