// Назначение структуры данных DSU
//
// Структура данных DSU (Disjoint Set Union),
// или «система непересекающихся множеств»,
// предназначена для эффективного управления
// множествами элементов при их динамическом
// объединении и проверке взаимосвязей.
//
//
// Основные задачи DSU
//
// - Отслеживание принадлежности элемента к
//   определённому множеству.
// - Быстрое объединение двух множеств в одно.
// - Проверка, находятся ли два элемента
//   в одном множестве.
//
// Благодаря техникам «объединения по рангу»
// и «сжатия путей» операции find и union
// выполняются практически за амортизированное
// константное время.
//
//
// Типичные сценарии применения
//
// 1. Алгоритм Краскала (минимальное остовное дерево)
//    - Каждое ребро сортируется по весу,
//      затем по возрастанию добавляется в дерево,
//      если его концы принадлежат разным множествам.
//    - DSU гарантирует, что добавление не создаст цикл,
//      и быстро объединяет компоненты.
//
// 2. Объединение аккаунтов по общим email
//    - Как в вашем примере: каждый email связывается
//      с индексом аккаунта, а одинаковые email
//      вызывают union, что группирует все связанные
//      аккаунты вместе.
//
// 3. Задачи динамической связи (dynamic connectivity)
//    - Поддержка запросов «соединить два узла»
//      и «проверить, связаны ли узлы» в сетях и графах.
//
// 4. Объединение областей в алгоритмах обработки
//    изображений
//    - Например, при сегментации пикселей по цвету или
//      яркости соседние пиксели объединяются в компоненты.
//
// 5. Поиск компонент связанности в неориентированных
//    графах
//    - Быстрый подсчёт числа связных компонент
//      или проверка связи двух вершин.
//
//
// Преимущества DSU
//
// - Амортизированная сложность операций практически O(1)
//   для каждого find/union.
// - Простота реализации и небольшие накладные расходы
//   по памяти.
// - Универсальность: DSU легко адаптируется к различным
//   задачам и типам данных.
class DSU {

  // Конструктор DSU принимает количество элементов n
  // и инициализирует две структуры:
  // parent — массив, где parent[i] = i означает,
  //   что каждый элемент изначально — корень
  //   собственного дерева и указывает сам на себя
  // rank — массив, в котором каждый элемент
  //   представляет  «вес» компоненты (количество узлов)
  //   в компоненте rank[i], где i — корень.
  //   Начальное значение для всех элементов 1,
  //   потому что каждое множество в начале содержит
  //   ровно 1 элемент, и мы храним «размер» или «вес»
  //   этого множества для оптимального объединения.
  //
  // Пример для n = 5:
  // parent = [0,1,2,3,4],
  // rank = [1,1,1,1,1]
  constructor(n) {

    // Пример изменения parent для сценария:
    // parent = [0, 1, 2, 3, 4]: 
    // 1. Выполнили union(1, 0) → parent = [0, 0, 2, 3, 4]
    // 2. Выполнили union(2, 1) → parent = [0, 0, 0, 3, 4]
    //
    // 1. Исходное состояние  
    // parent = [0, 1, 2, 3, 4]
    //
    // Здесь для любого i:  
    // - parent[i] = i → каждый элемент сам себе родитель,
    //   значит у нас 5 отдельных деревьев:
    //
    // 0  1  2  3  4
    // 
    //
    // 2. После union(1, 0) → parent = [0, 0, 2, 3, 4]
    //
    // - parent[1] = 0 означает: в компоненте узел 1
    //   теперь «принадлежит» корню 0.  
    // - Остальные parent[2]=2, parent[3]=3, parent[4]=4
    //   не меняются, их деревья по-прежнему отдельные.
    //
    // Деревья визуально:
    //
    //    0
    //   /
    //  1
    //
    // 2  3  4
    // 
    //
    // 3. После union(2, 1) → parent = [0, 0, 0, 3, 4]
    //
    // - Сначала find(2) дал корень 2,
    //   find(1) дал корень 0, корни разные,
    //   значит привязываем 2 к 0:  
    //   parent[2] = 0  
    // - parent[0]=0, parent[1]=0 уже было.
    //
    // Итоговая структура:
    //
    //     0
    //    / \
    //   1   2
    //
    // 3  4
    //
    //   
    // Таким образом, массив parent хранит
    // для каждого индекса i ссылку на его
    // «родителя» в дереве.
    //
    // Если parent[i] = i, i — корень своего
    // дерева.
    //
    // После операций связывания (union) мы
    // меняем значение parent у корней меньших
    // деревьев, прикрепляя их к новым корням.
    this.parent = Array.from({ length: n }, (_, i) => i);

    // rank хранит размер (число узлов) в
    // дереве, корнем которого является данный
    // элемент.
    //
    //
    // 1. Исходное состояние  
    // parent = [0, 1, 2, 3, 4]  
    // rank   = [1, 1, 1, 1, 1]  
    //
    // - Каждый узел сам себе корень, потому
    //   размер каждого «дерева» равен 1.  
    // - Визуализация:
    // 
    //   0(1)  1(1)  2(1)  3(1)  4(1)
    // 
    //   Здесь в скобках указано значение rank.
    //
    //
    // 2. После union(1, 0)  
    // parent = [0, 0, 2, 3, 4]  
    // rank   = [2, 1, 1, 1, 1]  
    //
    // - Корни до объединения:
    //   find(1)=1, find(0)=0.  
    // - Поскольку оба дерева одинакового размера,
    //   мы присоединяем дерево с корнем 1
    //   к дереву с корнем 0.  
    // - Новый размер дерева с корнем 0 = 1 + 1 = 2,
    //   поэтому rank[0]=2.  
    //
    // Дерево:  
    //
    //    0(2)
    //   /
    //  1(1)
    //
    // 2(1)  3(1)  4(1)
    //
    //
    // 3. После union(2, 1)  
    // parent = [0, 0, 0, 3, 4]  
    // rank   = [3, 1, 1, 1, 1]  
    //
    // - Корни до объединения:
    //   find(2)=2, find(1)=0.  
    // - Дерево с корнем 2 (size=1) присоединяем
    //   к более крупному - корню 0 (size=2).  
    // - Новый размер дерева с корнем 0 = 2 + 1 = 3,
    //   поэтому rank[0]=3.  
    //
    // Дерево:  
    //
    //      0(3)
    //     / \
    //  1(1)  2(1)
    //
    // 3(1)  4(1)
    //
    //
    // Вывод  
    // - rank[i] показывает количество узлов
    //   в компоненте, где i — корень.  
    // - После каждого объединения размер (rank)
    //   у корня увеличивается на размер
    //   присоединяемого поддерева.  
    // - Не-корневые элементы сохраняют своё
    //   старое значение rank, но оно больше не
    //   учитывается при сравнении.
    this.rank = new Int32Array(n).fill(1);
  }

  // Метод find находит «корень» (представителя)
  // множества, в которое входит заданный элемент,
  // и одновременно выполняет сжатие пути, чтобы
  // ускорить последующие операции.
  //
  //
  // Как работает find
  //
  // - Начинаем с переданного узла node.
  // - Пока node не является своим же родителем
  //   (parent[node] !== node), повторяем
  //   два шага:
  //   - Перенаправляем parent[node]
  //     на «дедушку»:
  //       this.parent[node] =
  //         this.parent[this.parent[node]];
  //     это уменьшает высоту дерева.
  //   - Сдвигаем node вверх по дереву:
  //       node = this.parent[node];
  //
  // - В конце цикла node указывает на корень
  //   своего множества.
  // - Возвращаем этот корневой индекс.
  //
  //
  // Почему path compression важен
  //
  // - Без сжатия пути дерево может вырасти в
  //   список, и поиск займет O(n).
  // - Сжатие пути делает деревья почти «плоскими»,
  //   что уменьшает амортизированную сложность
  //   операций find и union до почти константного
  //   уровня α(n) (обратная функция Аккермана).
  //
  //
  // Дополнительное применение
  //
  // - Метод find используется для проверки,
  //   принадлежат ли два элемента одному множеству:
  //   if (dsu.find(u) === dsu.find(v)) {
  //     // u и v уже соединены
  //   }
  //
  // - В комбинации с union позволяет решать задачи
  //   на компоненты связности, проверку циклов в
  //   графе, кластеризацию и многое другое.
  //
  //
  // Детальный пример работы метода find
  // с визуализацией деревьев
  //
  // 1. Исходное состояние  
  //    parent = [0, 1, 2, 3, 4]  
  //
  // Каждый узел сам себе родитель.  
  // Визуализация (каждый столбец — отдельное дерево):  
  // 
  // 0  1  2  3  4
  //
  //
  // 2. После union(1, 0)  
  // - Выполняем find(1) → 1, find(0) → 0  
  // - Поскольку ранги равны, делаем parent[1] = 0  
  // - Новое состояние: parent = [0, 0, 2, 3, 4]  
  //
  // Дерево компоненты {0,1}:
  //
  //    0
  //   /
  //  1
  //
  // Компоненты 2, 3, 4 остаются отдельными:
  // 
  // 2  3  4
  //
  //
  // 3. После union(2, 1) 
  // - find(2) → 2, find(1) →  
  //   - parent[1] = 0 → не корень
  //     → поднимаемся к parent[0] = 0  
  //   - возвращаем 0  
  // - Корни 2 и 0 различны → делаем parent[2] = 0  
  // - Новое состояние: parent = [0, 0, 0, 3, 4]  
  //
  // Дерево компоненты {0,1,2}:  
  // 
  //     0
  //    / \
  //   1   2
  //  
  // Отдельные компоненты:  
  // 
  // 3  4
  //
  //
  // 4. Первый вызов find(2)  
  // 1. Инициализируем node = 2  
  // 2. Проверяем parent[2] = 0 (не равен 2)
  //    → нужно подниматься выше  
  // 3. Выполняем path compression:  
  //    parent[2] = parent[parent[2]] = parent[0] = 0
  //      
  // 4. Переходим к node = 0  
  // 5. Теперь parent[0] = 0
  //    → останавливаемся и возвращаем 0  
  //
  // Во время этого прохода реальная структура
  // не изменилась (parent[2] уже был 0),
  // но гарантируется, что путь от 2 до корня
  // максимально краток.
  //
  //
  // 5. Последующий вызов find(2)  
  // - Сразу видим parent[2] = 0, поднимаемся
  //   к 0 и возвращаем его.  
  // - Одна итерация без сжатия пути - максимально
  //   быстрый сценарий.
  //
  //
  // Итог  
  // - После двух union-операций все узлы 1 и 2
  //   «подвесились» к корню 0.  
  // - Первый find(2) прошёл по пути 2 → 0,
  //   выполнил сжатие пути.  
  // - Следующий find(2) сразу возвращает 0 за
  //   одну проверку.
  find(node) {

    // Пока node не указывает на самого себя,
    // есть куда «взбираться» вверх по дереву
    while (this.parent[node] !== node) {

      // Сжатие пути: переподвешиваем node
      // к прародителю
      this.parent[node] = this.parent[this.parent[node]];

      // Переходим на уровень выше
      node = this.parent[node];
    }

    // Возвращаем полученный корень
    return node;
  }

  // Метод union(u, v) в структуре DSU выполняет
  // объединение двух множеств, которым
  // принадлежат элементы u и v. 
  //
  // Основная задача - связать эти два множества
  // так, чтобы все узлы из них оказались в одной
  // компоненте с общим корнем, и одновременно
  // выполняет сжатие пути, чтобы сохранить
  // деревья «плоскими» (за счёт рангов)
  // и минимизировать высоту получаемых деревьев
  // для ускорения последующих операций.
  //
  // Сжатие пути делает деревья почти «плоскими»,
  // что уменьшает амортизированную сложность
  // операций find и union до почти константного
  // уровня α(n) (обратная функция Аккермана)
  //
  // В результате метод union не только объединяет
  // два множества, но и поддерживает их
  // оптимальную структуру, сводящую высоту
  // деревьев к минимуму, что критично для быстрого
  // выполнения последующих find и union.
  union(u, v) {

    // Нахождение корней:
    // - Вызываем find(u) и find(v), чтобы
    //   определить корневые представители
    //   множеств — pu и pv.  
    // - В процессе поиска применяется
    //   сжатие пути: каждый посещённый узел
    //   сразу «переподвешивается» к корню.
    let pu = this.find(u);
    let pv = this.find(v);

    // Проверка на уже объединённость:
    // - Если корни совпадают (pu === pv), значит
    //   u и v уже в одном множестве, объединение
    //   не нужно.
    // - Попытка добавить ребро (u, v) создаст цикл.
    // - В этих случаях метод возвращает false и не
    //   выполняет дальнейших действий.
    // - Вы можете трактовать return false как
    //   сигнал «цикл найден».
    //
    // В общем случае это просто защита от лишнего
    // объединения, но в задаче поиска цикла - это
    // проверка на его появление.
    if (pu === pv) return false;

    // Выбор корня для присоединения:
    // - Сравниваем rank[pu] и rank[pv], то есть
    //   оценки «веса» или «высоты» двух деревьев
    // - Если дерево pv «тяжелее»
    //   (rank[pv] > rank[pu]), меняем их местами,
    //   чтобы гарантировать, что pu - всегда
    //   является коренем более «тяжёлого»
    //   множества.
    //
    //
    // Этот фрагмент - это оптимизация, которую
    // называют «union by size»
    // (или «union by rank», когда rank хранит
    // размер).
    // Его роль проста:
    //
    // Если дерево pv больше дерева pu, меняем их
    // местами
    //
    // 1. Это гарантирет, что
    //    - pu указывает на корень большего
    //      (тяжёлого) множества,
    //    - pv - на корень меньшего.
    //
    // 2. А дальше достаточно одной операции
    //    объединения:
    //
    //      parent[pv] = pu;
    //      rank[pu] += rank[pv];
    //
    // - и никакой дополнительной логики 
    //   и проверок «кто меньше, кто больше»
    //   уже не нужно.
    //
    // Без этого обмена пришлось бы либо
    // дублировать код:
    //
    //      if (rank[pv] > rank[pu]) {
    //        parent[pu] = pv;
    //        rank[pv] += rank[pu];
    //      } else {
    //        parent[pv] = pu;
    //        rank[pu] += rank[pv];
    //      }
    //
    // либо вводить дополнительные переменные
    // и ветвления. А так - единая, лаконичная
    // схема:
    // - один раз сравнили,
    // - при необходимости переприсвоили
    //   pu и pv,
    // - далее всегда «меньшее к большему».
    //
    // Это позволяет писать код короче,
    // и поддерживать деревья максимально
    // «плоскими», что критично для высокой
    // производительности DSU.
    if (this.rank[pv] > this.rank[pu]) {
      [pu, pv] = [pv, pu];
    }

    // Объединение деревьев:
    // - Делаем pu родителем pv:  
    //      this.parent[pv] = pu;  
    // - Увеличиваем ранг (или размер) корня
    //   pu на величину ранга pv, поскольку
    //   к множеству pu присоединяется всё
    //   дерево с корнем pv:
    //      this.rank[pu] += this.rank[pv];
    this.parent[pv] = pu;
    this.rank[pu] += this.rank[pv];

    // Возврат результата:
    // - Если объединение прошло успешно,
    //   возвращаем true
    return true;
  }
}


/**
 * @param {string[][]} accounts
 * @return {string[][]}
 *
 * Функция accountsMerge берёт на вход
 * список «аккаунтов», 
 * где каждый аккаунт — это массив строк:
 *   первый элемент — имя владельца, 
 *   а последующие — адреса электронной
 *     почты. 
 * 
 * Она находит все аккаунты, принадлежащие
 * одному и тому же человеку
 * (те у которых есть хотя бы один общий email)
 * и объединяет их в один аккаунт.
 *
 * Пример:
 *
 *  Вход:
 *   [
 *     [
 *       "John",
 *       "johnsmith@mail.com",
 *       "john_newyork@mail.com"
 *     ],
 *     [
 *       "John",
 *       "johnsmith@mail.com",
 *       "john00@mail.com"
 *     ],
 *     [
 *       "Mary",
 *       "mary@mail.com"
 *     ],
 *     [
 *       "John",
 *       "johnnybravo@mail.com"
 *     ]
 *   ]
 *
 *  Выход:
 *   [
 *     [
 *       "John",
 *       "john00@mail.com",
 *       "john_newyork@mail.com",
 *       "johnsmith@mail.com"
 *     ],
 *     [
 *       "Mary",
 *       "mary@mail.com"
 *     ],
 *     [
 *       "John",
 *       "johnnybravo@mail.com"
 *     ]
 *   ]
 */
function accountsMerge(accounts) {

  // Количество входных аккаунтов
  // (в примере 4)
  const n = accounts.length;

  // Создаем DSU для n аккаунтов,
  // чтобы объединять аккаунты
  // с пересекающимися email.
  //
  // Пример для 4 аккаунтов:
  // parent=[0,1,2,3]
  // rank=[1,1,1,1]
  const dsu = new DSU(n);

  // Map для связи
  // email → индекс первого аккаунта,
  // где он встретился
  //
  // Пример после прохода:
  // {
  //   "johnsmith@mail.com" → 0,
  //   "john_newyork@mail.com" → 0,
  //   "john00@mail.com" → 1,
  //   "mary@mail.com" → 2,
  //   "johnnybravo@mail.com" → 3
  // }
  const emailToAcc = new Map();

  // Проходим по всем аккаунтам и их email-адресам
  // для построения связей между аккаунтами,
  // у которых встречаются одинаковые email-адреса
  for (let i = 0; i < n; i++) {

    // Проходим по email со второго элемента.
    // Начинаем с j = 1,
    // т.к. accounts[i][0] - имя пользователя
    for (let j = 1; j < accounts[i].length; j++) {

      // Текущий email,
      // например "johnsmith@mail.com"
      const email = accounts[i][j];

      if (emailToAcc.has(email)) {

        // Если email уже встречался,
        // объединяем текущий аккаунт
        // i с тем, где он впервые
        // появился
        //
        // Например, для "johnsmith@mail.com":
        // в i=0 мы сохранили
        //   emailToAcc.set("johnsmith@mail.com", 0)
        // в i=1 получаем индекс аккаунта,
        //   в котором впервые появился текущий
        //   email (emailToAcc.get(email))
        //   и выполняем union(1,0) - объединяем
        //   аккаунты 1 и 0
        dsu.union(i, emailToAcc.get(email));
      } else {

        // Иначе email встречается впервые, поэтому
        // закрепляем его за текущим аккаунтом i
        //
        // Например:
        // "john_newyork@mail.com" → 0
        emailToAcc.set(email, i);
      }
    }
  }

  // Группируем email-адреса по корням множеств DSU
  // (корневому представителю аккаунта)
  //
  // emailGroup: Map<индекс_корня, массив email>
  //
  // Пример:
  //  {
  //    0 → [
  //          "johnsmith@mail.com",
  //          "john_newyork@mail.com",
  //          "john00@mail.com"
  //        ],
  //    2 → ["mary@mail.com"],
  //    3 → ["johnnybravo@mail.com"]
  //  }
  const emailGroup = new Map();
  for (const [email, accId] of emailToAcc) {

    // Находим корень для accId
    const leader = dsu.find(accId);

    // Если для корня ещё нет массива,
    // создаём его
    if (!emailGroup.has(leader)) {
      emailGroup.set(leader, []);
    }

    // Добавляем email в группу этого
    // корня
    emailGroup.get(leader).push(email);
  }

  // формируем окончательный список
  // объединенных аккаунтов
  const result = [];
  for (const [accId, emails] of emailGroup) {

    // Сортируем адреса по алфавиту,
    // как требует условие
    emails.sort();

    // Формируем запись:
    // имя пользователя + все его уникальные
    // отсортированные email-адреса
    // accounts[accId][0] — имя, найденное
    //   по аккаунту, в котором изначально
    //   встречаются email-адреса
    //   например "John" или "Mary"
    // emails - все его уникальные
    //   отсортированные email-адреса
    //
    // Пример для accId = 0:
    //   merged = [
    //     "John",
    //     "john00@mail.com",
    //     "john_newyork@mail.com",
    //     "johnsmith@mail.com"
    //   ]
    const merged = [accounts[accId][0], ...emails];

    // Добавляем сформированную запись
    // в результат
    result.push(merged);
  }

  // Возвращаем массив объединенных аккаунтов
  //
  // Для нашего примера функция вернет:
  // [
  //   [
  //     "John",
  //     "john00@mail.com",
  //     "john_newyork@mail.com",
  //     "johnsmith@mail.com"
  //   ],
  //   ["Mary", "mary@mail.com"],
  //   ["John", "johnnybravo@mail.com"]
  // ] 
  return result;
}
