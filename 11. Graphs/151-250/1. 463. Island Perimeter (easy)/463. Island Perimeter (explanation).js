/**
 * @param {number[][]} grid
 * @return {number}
 * 
 * islandPerimeter принимает на вход двумерный
 * массив grid, где 0 обозначает воду, а 1 — землю
 * и возвращает целое число, равное общей длине
 * периметра острова (или островов), образованного
 * этими единицами.
 * 
 * Периметр считается как сумма всех сторон клеток
 * земли, которые граничат с водой или с границей
 * массива.
 */
function islandPerimeter(grid) {

  // Получаем количество строк в grid
  const ROWS = grid.length;

  // Получаем количество столбцов в grid,
  // исходя из длины первой строки
  const COLS = grid[0].length;

  // Инициализируем аккумулятор для периметра
  // острова.
  //
  // Начальное значение 0, будем изменять при
  // обходе каждой клетки.
  let perimeter = 0;

  // Проходим по каждой строке сетки
  for (let r = 0; r < ROWS; r++) {

    // Проходим по каждому столбцу в
    // текущей строке
    for (let c = 0; c < COLS; c++) {

      // Если текущая ячейка — вода (0),
      // пропускаем её
      if (grid[r][c] === 0) continue;

      // Для каждой клетки земли (1)
      // добавляем 4 потенциальные стороны.
      //
      // Считаем её как отдельный квадрат
      // без учёта соседей.
      //
      // Каждая отдельная клетка может иметь
      // до 4 сторон на периметре
      perimeter += 4

      // Смотрим на соседнюю клетку справа:
      // если она существует внутри границ
      // grid и также является землей (1),
      // значит одна сторона между ними не
      // входит во внешний периметр.
      //
      // Вычитаем 2, так как граница
      // для двух клеток общая, то есть у
      // левой клетки убираем правую
      // границу (-1), так как она граничит
      // с правой клеткой, а у правой клетки
      // левую (-1), так как она граничит с
      // левой клеткой 
      //
      // Разбор условия по частям
      //
      // 1. c + 1 < COLS  
      //    - Гарантирует, что мы не выходим
      //      за правую границу grid, и что
      //      справа от текущей колонки "c"
      //      есть колонка "c + 1".  
      //
      // 2. grid[r][c + 1] === 1  
      //    - Проверяет, что соседняя 
      //      клетка справа тоже земля.  
      if (
        c + 1 < COLS
        && grid[r][c + 1] === 1
      ) perimeter -= 2;

      // Смотрим на соседнюю клетку снизу:
      // аналогично правому соседу, общая
      // грань не учитывается в периметре,
      // поэтому вычитаем 2.
      //
      // Вычитаем 2, так как граница
      // для двух клеток общая, то есть у
      // верхней клетки убираем нижнюю
      // границу (-1), так как она граничит
      // с нижней клеткой, а у нижней клетки
      // верхнюю (-1), так как она граничит с
      // верхней клеткой 
      //
      // Разбор условия по частям
      //
      // 1. r + 1 < ROWS  
      //    - Гарантирует, что мы не выходим
      //      за нижнюю границу grid, и что
      //      снизу от текущей строки "r"
      //      есть строка "r + 1".  
      //
      // 2. grid[r + 1][c] === 1  
      //    - Проверяет, что соседняя
      //      клетка снизу тоже земля.  
      if (
        r + 1 < ROWS
        && grid[r + 1][c] === 1
      ) perimeter -= 2;
    }
  }

  // После полного обхода возвращаем
  // итоговую длину периметра острова.
  return perimeter;
}
