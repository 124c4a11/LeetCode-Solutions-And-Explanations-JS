/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */

/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 * 
 * mergeTwoLists(l1, l2) объединяет
 * два уже отсортированных односвязных
 * списка в один новый отсортированный
 * список.
 * 
 * Пример входа: 
 *   l1: 1 → 3 → 5
 *   l2: 2 → 4 → 6
 * 
 * Результатом будет новый список:
 *   1 → 2 → 3 → 4 → 5 → 6 
 */
function mergeTwoLists(l1, l2) {

  // Создаём фиктивный узел dummy без
  // значения, чтобы легко возвращать
  // начало итогового списка  
  //
  // После создания: dummy → null  
  //
  // В результате dummy.next будет
  // указывать на первый реальный
  // узел (head) объединённого списка.
  // Поскольку dummy создан без значения
  // и служит только отправной точкой,
  // весь построенный список идёт сразу
  // после него.
  const dummy = new ListNode();

  // Устанавливаем указатель curr на dummy,
  // чтобы curr.next указывал на первый
  // элемент результата при первом
  // добавлении.
  //
  // curr будет двигаться и строить
  // новый список  
  //
  // Сейчас curr и dummy указывают на
  // «пустой» стартовый узел. 
  let curr = dummy;

  // Запускаем цикл объединения,
  // пока оба списка ещё не закончились  
  // Цикл сравнивает первые доступные
  // элементы l1 и l2 и добавляет меньший
  // в итоговый список  
  while (l1 && l2) {

    // Если значение в текущем узле l1.val
    // меньше или равно значению в l2.val 
    // выбираем узел из l1 и присоединяем
    // его к итоговому списку 
    //
    // Пример: 
    // 1 <= 2, поэтому первой придет 1
    if (l1.val <= l2.val) {

      // Присоединяем текущий узел
      // из l1 к следующему узлу в curr  
      //
      // Теперь итоговый список: 
      // dummy → 1
      curr.next = l1;

      // Передвигаем l1 на следующий
      // узел исходного списка  
      // Теперь l1 указывает на узел
      // со значением 3 (из примера 1 → 3 → 5)  
      l1 = l1.next;
    } else {

      // Иначе присоединяем узел из l2:
      // curr.next → l2 (узел со значением 2)
      //
      // Теперь итоговый список: 
      // dummy → 1 → 2
      curr.next = l2;

      // Передвигаем l2 на следующий
      // узел списка l2  
      //
      // Теперь l2 указывает на узел
      // со значением 4 (из примера 2 → 4 → 6)  
      l2 = l2.next;
    }

    // Перемещаем curr к добавленному узлу,
    // чтобы на следующем шаге присоединять
    // новые узлы после него.
    //
    // После первой итерации curr указывает
    // на узел со значением 1.
    //
    // dummy → 1
    curr = curr.next;
  }

  // Если один из списков закончился, остаток
  // второго списка уже отсортирован.
  // Просто присоединяем оставшиеся узлы
  // к итоговому списку
  curr.next = l1 ? l1 : l2;

  // Возвращаем начало итогового объединённого
  // списка, пропуская фиктивный узел dummy  
  //
  // dummy.next указывает на первый реальный узел
  // итогового списка
  return dummy.next
}
