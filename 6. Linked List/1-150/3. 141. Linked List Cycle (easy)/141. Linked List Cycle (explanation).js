/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 * 
 * hasCycle проверяет, содержит ли
 * односвязный список цикл.
 * Пример без цикла:
 *   1 → 2 → 3 → 4 → null
 *   hasCycle(head) вернёт false.
 * Пример с циклом:
 *   1 → 2 → 3 → 4
 *         ↑     ↓
 *          ←–––––
 *   hasCycle(head) вернёт true.
 */
function hasCycle(head) {

  // Здесь применяется алгоритм Флойда,
  // известный как «черепаха и заяц».
  //
  // Алгоритм работает так:
  // – Два указателя (pointer) движутся
  //   по списку с разной скоростью:
  //   «черепаха» (slow) на 1 шаг за итерацию,
  //   «заяц» (fast) на 2 шага.
  // – Если в списке есть цикл,
  //   быстрый указатель рано или поздно
  //   догонит медленный внутри этого цикла.
  // – Если цикл отсутствует,
  //   «заяц» выйдет за конец списка
  //   (fast или fast.next станет null),
  //   и мы безопасно вернём false.
  //
  // Временная и пространственная сложность:
  // - Время: O(n) в худшем случае 
  //   (где n — количество узлов до
  //   момента встречи или до конца списка).
  // - Память: O(1), потому что храним лишь два
  //   указателя, без дополнительной структуры.
  //
  // Варианты и нюансы применения:
  // - Важно инициализировать fast на head.next,
  //   чтобы корректно отловить даже самый
  //   короткий цикл из двух узлов.
  // - Если бы мы стартовали оба указателя с head,
  //   первое совпадение всегда гарантировано
  //   на head при любом цикле — придётся добавить
  //   дополнительную проверку.
  //
  // Дополнительные сведения, которые вам могут
  // пригодиться:
  // – Есть ещё алгоритм Брента, где «заяц» тоже
  //   идёт быстрее, но шаги меняются динамически,
  //   что порой даёт чуть меньшую константу в
  //   проверках.
  // – Аналогичные приёмы применяют для поиска цикла
  //   в последовательностях генераторов
  //   псевдослучайных чисел.
  // – В криптографии и теории чисел цикл-детекция
  //   помогает находить минимальный полином
  //   или длину периода в линейных конгруэнтных
  //   генераторах.

  // Инициализируем медленный указатель
  // на первый узел списка.
  // slow будет продвигаться по одному узлу
  // за итерацию.
  let slow = head;

  // Инициализируем быстрый указатель
  // на второй узел списка (head.next).
  // fast будет продвигаться по два узла
  // за итерацию.
  let fast = head.next;

  // Запускаем цикл, который будет
  // выполняться до тех пор, пока fast
  // и следующий за ним узел существуют
  // (fast не null и fast.next не null)
  //
  // Пошаговый пример для списка с циклом
  // 1 → 2 → 3 → 4 → 5 → 3:
  // Итерация 1: slow=2, fast=3
  // Итерация 2: slow=3, fast=5
  // Итерация 3: slow=4, fast=4
  //             → slow === fast
  //             → возвращаем true.
  while (fast?.next) {
    // Сдвигаем slow на один узел вперёд.
    slow = slow.next;

    // Сдвигаем fast на два узла вперёд.
    fast = fast.next.next;

    // Если в какой-то момент slow и fast
    // встретятся — цикл найден.
    if (slow === fast) return true;
  }

  // fast достиг конца списка (null)
  // — цикл отсутствует.
  return false;
}
