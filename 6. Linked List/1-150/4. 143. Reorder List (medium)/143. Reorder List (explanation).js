/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */

/**
 * @param {ListNode} head
 * @return {void}
 * 
 * Функция reorderList перестраивает
 * односвязный список L0→L1→…→Ln-1→Ln 
 * в L0→Ln→L1→Ln-1→L2→Ln-2→…  
 * 
 * Переупорядочивание происходит in-place
 * за O(n) времени и 
 * O(1) дополнительной памяти.  
 * 
 * Пример: для списка 1→2→3→4→5 
 * результат будет 1→5→2→4→3
 */
function reorderList(head) {
  // Если список пуст или содержит
  // один узел, нечего менять,
  // возвращаем null  
  //
  // Примеры: 
  // head = null → null,
  // head = [1] → null
  if (!head?.next) return null;

  // Инициализируем медленный указатель
  // в начале списка (для поиска середины)  
  // 
  // Пример: 
  // slow указывает на узел со значением 1
  let slow = head;

  // Инициализируем быстрый указатель
  // на второй узел 
  // (для прохода в два раза быстрее)  
  //
  // Пример: 
  // fast указывает на узел со значением 2
  let fast = head.next;

  // Двигаем slow на 1 шаг
  // и fast на 2 до тех пор, пока fast
  // может продвинуться дальше  
  //
  // Для списка 1→2→3→4→5 
  // slow остановится на 3,
  // fast — на null
  while (fast?.next) {

    // Шаг slow: 1→2→3
    slow = slow.next;

    // Два шага fast: 2→4→null
    fast = fast.next.next;
  }

  // Теперь slow указывает 
  // на узел в середине списка 
  // (или левее середины при чётном
  // количестве узлов)
  // 
  // Определяем начало второй половины списка
  // second указывает на первый узел
  // второй половины (узел после slow)  
  // slow=3 → second=4
  // (начало второй половины [4→5])
  let second = slow.next;

  // Отрываем первую половину от второй,
  // присваивая slow.next = null
  // И одновременно инициализируем prev
  // как null для последующего реверса
  //
  // первая половина оканчивается на slow,
  // вторая начинается с second  
  //
  // Первая половина: [1→2→3→null],
  // prev = null
  //
  // prev будет служить началом
  // перевёрнутого списка.
  let prev = (slow.next = null);

  // Переворачиваем вторую половину
  // списка  
  //
  // Изначально: second = [4→5];
  // после: prev = [5→4→null]
  //
  // Зачем переворачивать вторую
  // половину списка
  //
  // Переворот второй половины необходим,
  // чтобы затем поочерёдно чередовать
  // начальные и конечные узлы исходного
  // списка.
  // Без переворота нам пришлось бы каждый
  // раз находить последний узел второй
  // половины, что привело бы к
  // квадратичной сложности.
  //
  // Пример для списка 1→2→3→4→5
  //
  // 1. Находим середину:
  //      первая часть 1→2→3,
  //      вторая часть 4→5
  // 2. Переворачиваем вторую часть:
  //      из 4→5 получается 5→4
  // 3. Чередуем узлы:
  //    - Берём 1 (из первой)
  //    - Берём 5 (из перевёрнутой второй)
  //    - Берём 2 (из первой)
  //    - Берём 4 (из перевёрнутой второй)
  //    - Оставшийся 3
  //
  // В результате получаем 1→5→2→4→3 за
  // линейное время и без дополнительной
  // памяти.
  while (second) {

    // Сохраняем следующий узел 
    //
    // 1-й проход: tmp = 5
    // 2-й проход: tmp = null
    const tmp = second.next;

    // Разворачиваем ссылку:
    // текущий узел указывает на prev  
    //
    // 1-й проход: 4.next = null  
    // 2-й проход: 5.next = 4
    second.next = prev;

    // Перемещаем prev на текущий узел  
    //
    // 1-й проход: prev = 4
    // 2-й проход: prev = 5
    prev = second;

    // Переходим к следующему узлу
    // второй половины
    second = tmp;
  }

  // Готовимся к объединению двух половин.
  // first указывает на начало
  // первой половины: [1→2→3→null].
  let first = head;

  // second перенаправляем на prev,
  // то есть на голову перевёрнутой
  // половины: [5→4→null].
  second = prev;

  // Объединяем списки,
  // чередуя узлы первой и
  // перевёрнутой второй половин  
  //
  // Для [1→2→3] и [5→4] получим 1→5→2→4→3
  while (second) {

    // Сохраняем следующий узел 
    // первой половины 
    // 
    // 1-й проход: tmp1 = 2
    // 2-й: tmp1 = 3
    const tmp1 = first.next;

    // Сохраняем следующий узел
    // второй половины
    // 
    // 1-й проход: tmp2 = 4
    // 2-й: tmp2 = null
    const tmp2 = second.next;

    // Вставляем узел
    // второй половины (second)
    // после узла first  
    //
    // 1-й проход: 1.next = 5 (1→5)
    // 2-й: 2.next = 4 (2→4)
    first.next = second;

    // Соединяем вставленный узел
    // с оставшейся частью первой половины
    //
    // 1-й проход: 5.next = 2 (5→2)
    // 2-й: 4.next = 3 (4→3)
    second.next = tmp1;

    // Двигаем first к следующему узлу
    // первой половины
    //
    // 1-й проход: first=2
    // 2-й: first=3  
    first = tmp1;

    // Двигаем second к следующему
    // узлу второй половины
    //
    // 1-й проход: second=4
    // 2-й: second=null  
    second = tmp2;
  }
  
  // В результате список становится 1→5→2→4→3.
}
