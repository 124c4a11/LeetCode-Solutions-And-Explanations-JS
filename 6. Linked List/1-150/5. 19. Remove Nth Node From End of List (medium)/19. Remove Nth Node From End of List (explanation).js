/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 * 
 * Функция removeNthFromEnd удаляет 
 * n-й узел с конца 
 * односвязного списка
 * 
 * Параметры:
 * head — указатель на первый узел
 *        исходного списка
 * n — позиция узла с конца 
 *     (1 означает последний узел)
 * 
 * Возвращает новую голову списка
 * без удалённого узла
 * 
 * Например, 
 * для списка [1, 2, 3, 4, 5] и n = 2 
 * результат будет [1, 2, 3, 5]
 */
function removeNthFromEnd(head, n) {

  // Создаём фиктивный (dummy) узел
  // со значением 0, указывающий на
  // голову списка (head)
  // Это упрощает удаление первого узла,
  // если n = длина списка
  //
  // После создания:
  // dummy → 1 → 2 → 3 → 4 → 5
  const dummy = new ListNode(0, head);

  // Устанавливаем указатель r (правый)
  // на первый реальный узел списка
  // r будет смещён вперёд на n шагов,
  // после чего между l и r 
  // оказывается ровно n узлов
  //
  // Изначально: r указывает на
  // head - узел со значением 1
  let r = head;

  // Сдвигаем r вперёд на n узлов
  // На каждом шаге уменьшаем
  // счётчик n до тех пор,
  // пока его значение не станет
  // равно нулю, 
  // после чего между l и r 
  // оказывается ровно n узлов
  //
  // Пример: 
  // если n = 2,
  // то r пройдёт 1 → 2 → 3
  // и остановится на узле
  // со значением 3
  while (n) {
    r = r.next;
    n--;
  }

  // Устанавливаем указатель
  // l (левый) на dummy
  // После сдвига r на n узлов,
  // между l и r ровно n узлов разницы
  //
  // Изначально l указывает на
  // dummy (значение 0) и находится за
  // пределами списка,
  // что дает возможность удаления 
  // первого узла списка (head)
  // в случае необходимости
  //
  // l инициализируется узлом dummy
  // для упрощения удаления любого узла,
  // включая голову списка (head). 
  // dummy выступает фиктивным
  // «предыдущим» элементом,
  // поэтому мы всегда можем выполнить
  // l.next = l.next.next без
  // дополнительных проверок.
  //
  // Преимущества использования dummy
  // и инициализации l именно с него:
  //  • Универсальность: удаление
  //    любого узла, включая первый,
  //    одним кодом
  //  • Простота: нет условий для
  //    особой обработки головы списка
  //  • Безопасность: всегда есть
  //    «предыдущий» элемент, на который
  //    можно опереться
  let l = dummy;

  // Продвигаем оба указателя, пока r
  // не достигнет конца списка (null).
  //
  // После завершения цикла 
  // r окажется за пределами списка,
  // что дает возможность для удаления
  // последнего узла в случае необходимости
  //
  // На каждом шаге двигаем
  // l и r на один узел вперёд
  //
  // Одновременное перемещение l и r 
  // гарантирует, что l остановится ровно
  // перед удаляемым узлом.
  //
  // Шаги для примера [1,2,3,4,5], n=2:
  //   Шаг 1: l → 1, r → 4
  //   Шаг 2: l → 2, r → 5
  //   Шаг 3: l → 3, r → null (цикл завершается)
  while (r) {
    l = l.next;
    r = r.next;
  }

  // Теперь l стоит непосредственно перед
  // удаляемым узлом
  // l.next указывает на целевой узел.
  // Пропускаем его, перенаправляя ссылку:
  //
  // Из примера: 
  // узел 3 (l) поменяет
  // ссылку 3.next с 4 → 5, то есть удалит 4
  // для списка [1, 2, 3, 4, 5] 
  // результат будет [1, 2, 3, 5]
  l.next = l.next.next;

  // Возвращаем новую голову списка
  // — первый реальный узел после dummy.
  // Если удаляли голову, dummy.next изменится,
  // и мы вернём следующий реальный узел 
  // на который указывает dummy.next.
  //
  // Для примера dummy.next указывает на 1,
  // а список стал [1, 2, 3, 5]
  return dummy.next;
}
