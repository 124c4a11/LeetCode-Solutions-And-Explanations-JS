/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 * 
 * Функция reverseList принимает
 * на вход head — ссылку на первый
 * узел односвязного списка
 * и возвращает новую голову
 * перевёрнутого списка. 
 * 
 * Пример входа:  1 → 2 → 3 → null
 * Пример выхода: 3 → 2 → 1 → null
 */
function reverseList(head) {
  // prev будет хранить уже
  // перевёрнутую часть списка.
  // Изначально она пуста (null).
  //
  // Состояние перед началом работы:
  // head: 1 → 2 → 3 → null
  // prev: null
  let prev = null;

  // curr указывает на текущий
  // обрабатываемый узел в оригинальном
  // списке.
  //
  // На старте curr = head
  // (узел со значением 1).
  let curr = head;

  // Пока есть узел для обработки,
  // на каждой итерации цикла
  // разрываем связь с оставшейся
  // частью списка
  // и разворачиваем указатель
  // curr.next на prev.
  // После чего сдвигаем указатели
  // prev на curr, а curr на curr.next
  //
  // - prev всегда указывает на голову
  //   уже перевёрнутой части списка.
  // - curr всегда указывает на голову
  //   оставшейся (ещё не обработанной)
  //   части списка.
  //
  // Пример:
  //   null ← 1       2 → 3 → null  
  //          ^prev   ^curr
  // 
  //   Шаг 1: null ← 1   2 → 3   →   null
  //   Шаг 2: null ← 1 ← 2   3   →   null
  //   Шаг 3: null ← 1 ← 2 ← 3       null
  //                         ^prev   ^curr
  //
  // Цикл завершён, и prev указывает на 3,
  // что является началом перевернутого
  // списка
  while (curr) {

    // Сохраняем ссылку на следующий
    // узел в tmp, чтобы в будущем
    // переместить на него curr
    //
    // Пример для 1 → 2 → 3 → null: 
    // Если curr → узел со значением 1,
    // то tmp → узел со значением 2
    //
    // null  →  1   →   2 → 3 → null
    // ^prev    ^curr   ^tmp
    const tmp = curr.next;

    // Разрываем связь с основным списком
    // и разворачивает указатель текущего
    // узла curr.next на prev
    //
    // Пример для curr=1 и prev=null
    // в списке 1 → 2 → 3 → null:
    //
    // null  ←  1      2 → 3 → null  
    // ^prev    ^curr  ^tmp
    curr.next = prev;

    // Сдвигаем границу перевёрнутой
    // части списка вперёд:
    // prev теперь указывает на
    // только что обработанный узел.
    //
    // После первой итерации
    // prev указывает на 1:
    //
    // null ← 1      2 → 3 → null  
    //        ^prev  ^tmp
    prev = curr;

    // Продвигаемся по оригинальному
    // списку: 
    // curr = tmp (узел со значением 2)
    // Следующая итерация начнётся
    // с обработки узла 2, на который
    // указывае curr.
    //
    // null ← 1      2 → 3 → null  
    //        ^prev  ^curr
    curr = tmp;
  }

  // Когда curr становится null,
  // все связи перевёрнуты.
  // prev указывает на новую голову
  // перевёрнутого списка.
  //
  // Для примера выше prev будет узел(3),
  // и весь список примет вид: 3 → 2 → 1 → null
  //
  // null ← 1 ← 2 ← 3       null
  //                ^prev   ^curr
  return prev;
}
