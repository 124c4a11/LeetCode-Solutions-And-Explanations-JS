/**
 * Definition for singly-linked list.
 * class ListNode {
 *     constructor(val = 0, next = null) {
 *         this.val = val;
 *         this.next = next;
 *     }
 * }
 */


/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 * 
 * Функция reverseBetween меняет порядок 
 * элементов между позициями left и right
 * в односвязном списке.
 * 
 * Параметры:
 *  head  — ссылка на первый узел списка.
 *  left  — позиция начала сегмента для реверса,
 *  right — позиция конца сегмента для реверса.
 * 
 * Пример:
 *  для списка 1→2→3→4→5 с left=2 и right=4
 *  результат будет 1→4→3→2→5.
 */
function reverseBetween(head, left, right) {

  // Создаем вспомогательный узел dummy
  // со значением 0, чтобы упростить работу
  // с краевыми случаями
  // (например, когда left = 1).
  // dummy.next указывает на originalHead
  // списка.
  //
  // Пример: 
  // для списка 1→2→3→4→5 
  // получаем   dummy→1→2→3→4→5
  const dummy = new ListNode(0, head);

  // После цикла leftPrev остановится
  // на узле перед началом переворота
  // и будет указывать на узел 
  // перед первым реверсируемым, то есть
  // непосредственно перед позицией left.
  //
  // Инициализируем значением dummy
  // для случая, когда переворот
  // начинается с самого
  // первого узла, то есть left указывает
  // на originalHead списка
  // в примере 1→2→3→4→5 left = 1
  let leftPrev = dummy;

  // curr — указатель для прохода к той
  // позиции, с которой начнём переворот 
  // 
  // Изначально curr = head (1)  
  //
  // После цикла curr остановится
  // на первом реверсируемом узле,
  // то есть на узле на позиции left
  let curr = head;

  // Перемещаем leftPrev и curr так, чтобы
  // curr оказался на позиции left,
  // а leftPrev — на предыдущей позиции.
  //
  // ---
  //
  // Цикл выполняется left-1 раз.
  //
  // Зачем нужен цикл из left − 1 итераций
  // 
  // Чтобы перевернуть фрагмент списка
  // именно с позиции left, сначала нужно
  // подвести два указателя:
  // 
  // - curr должен указывать на узел
  //   в позиции left  
  // - leftPrev — на узел непосредственно
  //   перед этой позицией
  // 
  // Поскольку исходно  
  // - curr стоит на head списка (позиция 1)  
  // - leftPrev — на фиктивном узле
  //   dummy (позиция 0)
  // 
  // надо сделать ровно left − 1 шага вперёд,
  // чтобы:  
  // - curr сместился из позиции 1
  //   в позицию left  
  // - leftPrev из позиции 0
  //   в позицию left − 1
  //
  // То есть Цикл выполняется left − 1 раз,
  // чтобы точно позиционировать curr
  // на начало переворачиваемого фрагмента
  // и leftPrev — на узел перед ним, вне
  // зависимости от того, начинается ли
  // алгоритм с головы списка или дальше
  // внутри него. 
  //
  // ---
  //
  // Пример:
  // Если left = 2, то после цикла указатели
  // займут следующие позиции:
  // leftPref = 1, left = 2
  // 
  // dummy → 1         → 2 → 3 → 4 → 5
  //         ^leftPrev   ^left
  //                     ^curr
  for (let i = 0; i < left - 1; i++) {
    leftPrev = curr;
    curr = curr.next;
  }

  // prev будет «хвостом» перевёрнутого
  // фрагмента; пока ничего не перевёрнуто  
  // prev = null 
  let prev = null;

  // Цикл реверсирует указатели next для
  // узлов от left до right включительно.
  //
  // Количество
  // узлов в сегменте = right - left + 1.
  for (let i = 0; i < right - left + 1; i++) {

    // Сохраняем ссылку на следующий узел
    // оригинального списка,
    // чтобы не потерять его хвост и 
    // в дальнейшем переместить на него 
    // указатель curr
    //
    // Если curr = 2:
    //
    // dummy → 1 → 2    → 3 → 4 → 5
    //             ^curr  ^tmp
    const tmp = curr.next;

    // Перенаправляем curr.next на prev,
    // тем самым разворачивая связь
    // одного узла.
    //
    // Пример
    // Если curr = 2 и prev = null:
    //
    // До:
    //  dummy → 1 → 2    → 3 → 4 → 5
    //              ^curr  ^tmp
    //
    // После:
    //  null ←  2      3 → 4 → 5
    //  ^prev   ^curr  ^tmp
    curr.next = prev;

    // Передвигаем prev на curr.
    // prev теперь — последний узел
    // в новой (перевернутой) части.
    //
    // Пример:
    //  null ← 2      3 → 4 → 5
    //         ^prev  ^tmp
    prev = curr;

    // Возвращаем curr на начало хвоста
    // оригинального списка, который сохранен
    // в переменную tmp.
    //
    // Пример:
    //  null ← 2      3 → 4 → 5
    //         ^prev  ^curr
    curr = tmp;

    // Пример:
    //  Шаг 1: null ← 2   3 → 4   → 5
    //  Шаг 2: null ← 2 ← 3   4   → 5
    //  Шаг 3: null ← 2 ← 3 ← 4     5
    //                        ^prev ^curr
    //
    // В итоге перевернутая часть 
    // выгляди следующим образом:
    //  4 → 3 → 2 → null
    //  ^prev
  }

  // После переворота сегмента leftPrev.next
  // — это конец перевернутой части (узел 2).
  //
  // leftPrev.next в левой части
  // оригинального списка:
  //  dummy → 1         → 2 
  //          ^leftPrev   ^leftPrev.next
  //
  // leftPrev.next в перевернутой части
  // списка:
  //  4 → 3 → 2 → null
  //  ^prev   ^leftPrev.next
  //
  // Соединяем этот конец с узлом curr (узел 5),
  // который стоит сразу после сегмента.
  //
  // Пример: 
  // узел 2.next = 5,
  // получаем 4 → 3 → 2 → 5
  //
  //  4 → 3 → 2             → 5
  //  ^prev   ^leftPrev.next  ^curr
  leftPrev.next.next = curr;

  // Соединяем сегмент оканчивающийся на leftPrev
  // (в примере 1): 
  //  dummy → 1
  //          ^leftPrev
  //
  // с началом перевернутого сегмента prev
  // (в примере 4):
  //  4 → 3 → 2 → 5
  //  ^prev
  //
  // Получаем:
  //  dummy → 1        → 4 → 3 → 2 → 5
  //          ^leftPrev  ^prev
  leftPrev.next = prev;

  // Возвращаем head итогового списка,
  // пропуская фиктивный узел.
  // В примере dummy.next указывает на 1: 
  //  dummy → 1 → 4 → 3 → 2 → 5
  //          ^head
  //          ^dummy.next
  //
  // итоговый список: 1 → 4 → 3 → 2 → 5  
  return dummy.next;
}
