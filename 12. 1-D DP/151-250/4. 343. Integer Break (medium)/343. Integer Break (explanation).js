/**
 * @param {number} n
 * @return {number}
 * 
 * integerBreak принимает параметр
 * n — целое положительное число, для которого
 * вычисляет максимальное произведение, которое
 * можно получить, разбив целое число n на
 * сумму положительных целых слагаемых
 * (с условием, что число n должно быть разбито
 * хотя бы на два слагаемых)
 * 
 * Пример:
 *  Для:
 *    n = 5
 *  Возвращает:
 *    6
 *  Пояснение:
 *    оптимальное разбиение 5 = 2 + 3,
 *    произведение 2 * 3 = 6.
 */
function integerBreak(n) {

  // Создаём массив dp длины n + 1 для
  // хранения максимальных произведений
  // для всех значений от 0 до n
  // включительно.
  //
  // Так как индексы массива
  // соответствуют числам от 0 до n
  // включительно, требуется место для
  // каждого такого индекса, то есть
  // n + 1 элементов.
  //
  // Все элементы по умолчанию равны 0.
  //
  // dp[0] не используется и остаётся
  // равным 0 по умолчанию, но её
  // наличие делает индексацию
  // безопасной и прямой (без сдвигов 
  // и дополнительных вычислений).
  //
  // индекс: i — число, которое мы
  // рассматриваем как одну из частей
  // или как объект разбиения.
  //
  // dp[i] — максимальное произведение,
  // которое можно получить, разбив
  // число i на положительные целые
  // слагаемые
  const dp = new Int32Array(n + 1);

  // Устанавливаем базовый случай
  // dp[1] = 1; здесь мы принимаем,
  // что для подзадачи 1 оптимальное
  // значение (используемое при
  // вычислениях) равно 1, чтобы
  // умножения с этим значением
  // работали корректно.
  dp[1] = 1;

  // Внешний цикл:
  // вычисляем dp[num] для каждого числа
  // num от 2 до n включительно.
  // 
  // Идея:
  // для каждого num перебрать возможные
  // разбиения num = i + (num - i) и взять
  // максимум.
  //
  // Почему цикл начинается с num = 2
  // - Самое маленькое число, которое
  //   можно разбить на два положительных
  //   слагаемых — это 2 (2 = 1 + 1),
  //   поэтому только при num ≥ 2 имеет
  //   смысл искать произведение от
  //   разбиений.  
  // - Значение dp[1] уже задано заранее
  //   и требуется как опора для вычисления
  //   более крупных значений; для
  //   num = 2 нужны dp[1] и dp[1],
  //   так что цикл начинается именно с 2.  
  // - Для num = 0 и num = 1 не существует
  //   ненулевого разбиения на два
  //   положительных числа, выполнение
  //   итераций для них было бы либо
  //   бессмысленным, либо потребовало бы
  //   дополнительной проверочной логики.  
  // - Запуск с 2 гарантирует, что при
  //   расчёте dp[num] все меньшие dp[i]
  //   уже вычислены, что обеспечивает
  //   корректность перехода динамического
  //   программирования.
  for (let num = 2; num <= n; num++) {

    // - Если num === n, ставим 0, потому
    //   что для исходного n мы обязаны
    //   сделать как минимум одно разбиение,
    //   и значение "неразбиение"
    //   (num само по себе) не должно
    //   автоматически считаться допустимым
    //   вариантом.
    // - Иначе ставим num — начальное
    //   предположение максимума (на случай,
    //   если не разбивать дальше выгоднее).
    //   Для промежуточных num < n допустимо
    //   рассматривать само число num как
    //   кандидат (это упрощает сравнения
    //   с dp[i]*dp[num-i]),
    dp[num] = num === n ? 0 : num;

    // Это внутренний цикл:
    // перебираем все возможные разбиения
    // числа num на две положительные части
    // в форме num = i + (num - i).  
    // - На каждой итерации переменная 
    //   i — первое слагаемое разбиения,
    //   а 'num - i' — второе.  
    // - Для каждого i вычисляется
    //   произведение dp[i] * dp[num - i],
    //   где dp[...] уже содержит оптимальные
    //   значения для меньших чисел, и это
    //   произведение соответствует
    //   наилучшему варианту получить
    //   множители из частей i и num - i.  
    // - Строка в теле цикла обновляет
    //   текущее значение dp[num] как
    //   максимум между прежним значением и
    //   найденным произведением, то есть
    //   выбирает лучшее из всех разбиений
    //   на две части.  
    // - Перебор от 1 до num-1 гарантирует,
    //   что учитываются все возможные
    //   двучленные разбиения; благодаря тому,
    //   что dp заполняется по возрастанию num,
    //   для каждого i оба множителя уже
    //   оптимизированы.
    for (let i = 1; i < num; i++) {

      // Для каждой позиции i вычисляем
      // потенциальное произведение как
      // dp[i] * dp[num - i].
      //
      // dp[i] — максимальное произведение
      // для левой части i,
      //
      // dp[num - i] — максимальное
      // произведение для правой части
      // (num - i).
      //
      // Затем обновляем dp[num] значением
      // максимума между текущим dp[num] и
      // найденным произведением.
      //
      // Это обеспечивает сохранение
      // наилучшего возможного произведения
      // для числа num.
      dp[num] = Math.max(
        dp[num],
        dp[i] * dp[num - i]
      );
    }

    // Пример:
    // для n = 5 
    // Начальное состояние dp до входа в цикл:
    // dp = [0, 1, 0, 0, 0, 0]
    // 
    // 
    // num = 2
    // 
    // - Инициализация dp[2]:
    //   - Выражение: dp[2] = (2 === 5) ? 0 : 2.
    //   - Результат: dp[2] = 2.
    //   - Состояние dp: [0, 1, 2, 0, 0, 0]
    // 
    // - Внутренний цикл: i = 1
    //   - Вычисляем кандидат:
    //     dp[1] * dp[1] = 1 * 1 = 1.
    //   - Обновление: dp[2] = max(2, 1) = 2.
    //   - Состояние dp после i=1: [0, 1, 2, 0, 0, 0]
    // 
    // Завершение шага num=2: dp[2] окончательно = 2.
    // 
    // 
    // num = 3
    // 
    // - Инициализация dp[3]:
    //   - Выражение: dp[3] = (3 === 5) ? 0 : 3.
    //   - Результат: dp[3] = 3.
    //   - Состояние dp: [0, 1, 2, 3, 0, 0]
    // 
    // - Внутренний цикл: i = 1
    //   - Кандидат: dp[1] * dp[2] = 1 * 2 = 2.
    //   - Обновление: dp[3] = max(3, 2) = 3.
    //   - Состояние dp после i=1: [0, 1, 2, 3, 0, 0]
    // 
    // - Внутренний цикл: i = 2
    //   - Кандидат: dp[2] * dp[1] = 2 * 1 = 2.
    //   - Обновление: dp[3] = max(3, 2) = 3.
    //   - Состояние dp после i=2: [0, 1, 2, 3, 0, 0]
    // 
    // Завершение шага num=3: dp[3] окончательно = 3.
    // 
    // 
    // num = 4
    // 
    // - Инициализация dp[4]:
    //   - Выражение: dp[4] = (4 === 5) ? 0 : 4.
    //   - Результат: dp[4] = 4.
    //   - Состояние dp: [0, 1, 2, 3, 4, 0]
    // 
    // - Внутренний цикл: i = 1
    //   - Кандидат: dp[1] * dp[3] = 1 * 3 = 3.
    //   - Обновление: dp[4] = max(4, 3) = 4.
    //   - Состояние dp после i=1: [0, 1, 2, 3, 4, 0]
    // 
    // - Внутренний цикл: i = 2
    //   - Кандидат: dp[2] * dp[2] = 2 * 2 = 4.
    //   - Обновление: dp[4] = max(4, 4) = 4.
    //   - Состояние dp после i=2: [0, 1, 2, 3, 4, 0]
    // 
    // - Внутренний цикл: i = 3
    //   - Кандидат: dp[3] * dp[1] = 3 * 1 = 3.
    //   - Обновление: dp[4] = max(4, 3) = 4.
    //   - Состояние dp после i=3: [0, 1, 2, 3, 4, 0]
    // 
    // Завершение шага num=4: dp[4] окончательно = 4.
    // 
    // 
    // num = 5
    // 
    // - Инициализация dp[5]:
    //   - Выражение: dp[5] = (5 === 5) ? 0 : 5.
    //   - Результат: dp[5] = 0 
    //     (исключаем тривиальное "не-разбиение" для
    //     итогового n).
    //   - Состояние dp: [0, 1, 2, 3, 4, 0]
    // 
    // - Внутренний цикл: i = 1
    //   - Кандидат: dp[1] * dp[4] = 1 * 4 = 4.
    //   - Обновление: dp[5] = max(0, 4) = 4.
    //   - Состояние dp после i=1: [0, 1, 2, 3, 4, 4]
    // 
    // - Внутренний цикл: i = 2
    //   - Кандидат: dp[2] * dp[3] = 2 * 3 = 6.
    //   - Обновление: dp[5] = max(4, 6) = 6.
    //   - Состояние dp после i=2: [0, 1, 2, 3, 4, 6]
    // 
    // - Внутренний цикл: i = 3
    //   - Кандидат: dp[3] * dp[2] = 3 * 2 = 6.
    //   - Обновление: dp[5] = max(6, 6) = 6.
    //   - Состояние dp после i=3: [0, 1, 2, 3, 4, 6]
    // 
    // - Внутренний цикл: i = 4
    //   - Кандидат: dp[4] * dp[1] = 4 * 1 = 4.
    //   - Обновление: dp[5] = max(6, 4) = 6.
    //   - Состояние dp после i=4: [0, 1, 2, 3, 4, 6]
    // 
    // Завершение шага num=5: dp[5] окончательно = 6.
    // 
    // 
    // Итог
    // 
    // - Финальное состояние dp после полного
    //   выполнения внешнего цикла:
    //   dp = [0, 1, 2, 3, 4, 6].
    // - Возвращаемое значение функции
    //   integerBreak(5) = dp[5] = 6,
    //   достигается разбиением
    //   5 = 2 + 3 (или 3 + 2)
    //   Пояснение:
    //     оптимальное разбиение 5 = 2 + 3,
    //     произведение 2 * 3 = 6.
  }

  // Возвращаем dp[n] - максимальное
  // произведение, достигаемое разбиением n
  // на сумму положительных целых чисел,
  // с условием, что n разбивается на хотя
  // бы два слагаемых.
  return dp[n];
}
