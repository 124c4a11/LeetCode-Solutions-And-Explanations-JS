/**
 * @param {number} n
 * @return {number}
 * 
 * tribonacci принимает один аргумент n
 * и возвращает n-е число трибоначчи.
 * 
 * В трибоначчи первые три числа заданы
 * как 0, 1 и 1, а каждое последующее
 * — сумма трёх предыдущих.
 * 
 * Пример:
 *   для n = 4
 *   результат 4
 *   (последовательность: 0, 1, 1, 2, 4).
 */
function tribonacci(n) {

  // Базовые случаи:
  // если n меньше 3, возвращаем заранее
  // известные значения
  //   n = 0 → 0
  //   n = 1 или 2 → 1
  if (n < 3) return !n ? 0 : 1;

  // Создаём кольцевой буфер dp длины 3
  // для хранения трёх последних значений:
  //   dp[0] = T0 = 0
  //   dp[1] = T1 = 1
  //   dp[2] = T2 = 1
  //
  // Пример:
  //   при любом n начальное
  //   состояние dp = [0, 1, 1]
  const dp = [0, 1, 1];

  // Итеративный расчёт для i от 3 до n
  // включительно.
  //
  // На каждой итерации обновляем один из
  // трёх слотов dp по кругу,
  // чтобы не расширять массив dp
  for (let i = 3; i <= n; i++) {

    // Вычисляем T(i) как сумму трёх
    // предыдущих значений:
    // dp[0] + dp[1] + dp[2].
    //
    // Сохраняем результат в ячейку с
    // индексом i % 3 для «кругового»
    // перезаписывания значений буфера,
    // чтобы не расширять массив dp.
    //
    // Пример пошагово выполнения для n = 4:
    //   i = 3 → индекс в буфере 3 % 3 = 0
    //     dp[0] = dp[0] + dp[1] + dp[2] = 0 + 1 + 1 = 2
    //     буфер становится [2, 1, 1]
    //   i = 4 → индекс в буфере 4 % 3 = 1
    //     dp[1] = dp[0] + dp[1] + dp[2] = 2 + 1 + 1 = 4
    //     буфер становится [2, 4, 1]
    dp[i % 3] = dp[0] + dp[1] + dp[2];
  }

  // По завершении цикла в dp останется
  // три последних числа; нужное нам T­n
  // лежит в ячейке n % 3.
  //
  // Пример:
  // после цикла буфер становится [2, 4, 1]
  // для n = 4 → i = 4 % 3 = 1,
  // значит возвращаем dp[1] = 4.
  return dp[n % 3];
}
