/**
 * @param {number[]} stoneValue
 * @return {string}
 * 
 * stoneGameIII принимает массив целых
 * чисел stoneValue, где каждый элемент
 * — очки за соответствующий камень в ряду
 * и решает задачу двух игроков, которые
 * по очереди берут из начала ряда
 * 1, 2 или 3 камня с целями максимизировать
 * собственное суммарное значение взятых камней.
 * Функция вычисляет оптимальную разницу
 * в очках между игроком, который ходит
 * первым (Alice), и вторым (Bob),
 * и возвращает строку с результатом: 
 * "Alice", "Bob" или "Tie".
 * 
 * Правила игры и цель алгоритма
 *
 * - Игроки берут только с начала оставшейся
 *   части массива stoneValue; на ход разрешено
 *   взять 1, 2 или 3 элемента.  
 * - Каждый игрок стремится максимизировать
 *   свою суммарную сумму значений взятых камней.  
 * - Алгоритм возвращает победителя по
 *   оптимальной игре: если разница сумм
 *   (Alice − Bob) положительна, побеждает Alice;
 *   отрицательна — Bob;
 *   ноль — ничья.  
 * 
 * Пример:
 *   Для: 
 *     stoneValue = [1,2,3,-9]
 *   Результат:
 *     "Alice"
 */
function stoneGameIII(stoneValue) {
  const n = stoneValue.length;

  // Создаём массив dp длины 4 и заполняем
  // нулями
  //
  // Используем циклическую индексацию по
  // модулю 4 чтобы хранить только
  // 4 последних состояния динамики, экономя
  // память по сравнению с массивом длины n
  //
  // Что означает значение dp[i]
  // Значение в dp[i] — это максимальная
  // разница очков
  // (текущий игрок минус соперник), которую
  // текущий игрок может обеспечить, начиная
  // с той позиции i, для которой k = i % 4.
  //
  // Положительное значение означает
  // преимущество текущего игрока при
  // оптимальной игре;
  // отрицательное означает преимущество
  // соперника;
  // ноль — ничья.
  const dp = new Array(4).fill(0);

  // Цикл перебирает все стартовые позиции
  // массива stoneValue в обратном порядке,
  // начиная с последнего индекса n - 1
  // и заканчивая нулём.
  //
  // Обход в обратном порядке необходим
  // для динамического программирования:
  // значение dp[i] вычисляется через уже
  // рассчитанные значения dp для позиций
  // с индексами > i.
  // 
  // На каждой итерации i устанавливаются
  // локальные переменные для расчёта
  // оптимальной разницы очков, затем
  // внутренний цикл рассматривает варианты
  // взять 1, 2 или 3 камня начиная
  // с позиции i и по этим вариантам
  // обновляет dp[i % 4].
  for (let i = n - 1; i >= 0; i--) {

    // Локальная переменная total
    // накапливает сумму значений камней,
    // которые текущий игрок может взять,
    // начиная с позиции i и расширяя
    // выбор до i..j включительно
    // (максимум 3).
    let total = 0;

    // Устанавливаем dp для текущего
    // индекса i (хранимого в ячейке i % 4)
    // в -Infinity, чтобы при первом вызове
    // Math.max корректно выбрать реальное
    // значение (а не оставлять 0).
    dp[i % 4] = -Infinity;

    // Рассматриваем все варианты взять
    // 1, 2 или 3 камня
    //
    // j пробегает от i до min(i+2, n-1)
    // включительно но не выходит
    // за пределы массива (min(i+3, n))
    for (let j = i; j < Math.min(i + 3, n); j++) {

      // Накапливаем сумму взятых камней
      // от i до j включительно
      total += stoneValue[j];

      // Назначение в одном предложении
      // Эта строка обновляет текущее
      // оптимальное значение для позиции i,
      // выбирая между уже найденным лучшим
      // вариантом и результатом варианта,
      // в котором текущий игрок берёт камни
      // i..j, а затем оба играют оптимально
      // дальше.
      // 
      // 
      //  Компоненты выражения
      // 
      // - dp[i % 4] (левая часть и первый
      //   аргумент Math.max)  
      //   Хранит текущий лучший найденный
      //   результат (максимальную разницу
      //   очков) для начала хода с позиции
      //   i в циклическом буфере длины 4.  
      // 
      // - total  
      //   Сумма значений камней, взятых
      //   текущим игроком в рассматриваемом
      //   варианте (камни i..j включительно).
      // 
      // - dp[(j + 1) % 4]
      //   Оптимальная разница очков
      //   (следующий игрок минус его
      //   соперник) при начале хода
      //   с позиции j+1; это оценка того,
      //   насколько выгодно будет играть
      //   сопернику после вашего хода.
      // 
      // - total - dp[(j + 1) % 4] (второй
      //   аргумент Math.max)
      //   Итоговая разница очков для
      //   текущего игрока, если он возьмёт
      //   камни i..j, потому что он получает
      //   total сейчас, а затем его
      //   выгодность уменьшается на
      //   оптимальную разницу соперника
      //   из позиции j+1.
      // 
      // - Math.max
      //   Выбирает лучший вариант между
      //   уже найденным и новым вариантом
      //   total - dp[(j + 1) % 4].
      // 
      // 
      // Почему вычитается dp[(j + 1) % 4]
      //
      // dp[(j + 1) % 4] — это разница очков
      // для игрока, который ходит следующим.
      // Если после вашего хода противник
      // в среднем "получает" X очков больше,
      // чем вы в оставшейся части игры,
      // то ваша итоговая разница уменьшается
      // на X. Поэтому ваша выгода от взятия
      // total равна total − X, что записано
      // как total - dp[(j + 1) % 4].
      // 
      // 
      // Зачем используется модуль 4
      //
      // Переходы в рекурренте зависят
      // только от позиций i+1, i+2, i+3.
      // Хранение всех dp[0..n-1] не требуется,
      // достаточно четырёх ячеек, поэтому
      // индексация по i % 4 и (j+1) % 4
      // реализует циклический буфер,
      // переиспользуя места по мере
      // продвижения назад по массиву.
      dp[i % 4] = Math.max(
        dp[i % 4],
        total - dp[(j + 1) % 4]
      );

      // Пример:
      //
      // Входные данные и начальная
      // инициализация
      //
      // const stoneValue = [1, 2, 3, -9];
      // const n = stoneValue.length; 
      //       n = 4
      // const dp = new Array(4).fill(0); 
      //       dp = [0, 0, 0, 0]
      //
      // 
      // Обозначения в визуализации
      // 
      // - i — текущая внешняя позиция
      //   (проходим с i = 3 до i = 0).  
      // - j — индекс последнего взятого
      //   камня в варианте хода
      //   (перебор j от i до min(i+2, n-1)).  
      // - total — сумма
      //   stoneValue[i]..stoneValue[j]
      //   для текущего j.  
      // - candidate — значение
      //   total - dp[(j + 1) % 4].  
      // - Показан полный массив dp после
      //   завершения обработки каждой
      //   позиции i; также показано
      //   обновление dp[i % 4] внутри
      //   внутреннего цикла.
      // 
      // 
      // i = 3 (позиция с камнем -9)
      // 
      // Исходный dp перед итерацией: [0, 0, 0, 0]  
      // Устанавливаем dp[3 % 4] = dp[3] = -Infinity
      // 
      // Внутренний цикл j проходит
      // от 3 до min(5,3)=3 — только j = 3:
      // - j = 3:
      //   - total = stoneValue[3] = -9
      //   - candidate = total - dp[(3 + 1) % 4]
      //     = -9 - dp[0] = -9 - 0 = -9
      //   - dp[3] = max(-Infinity, -9) = -9
      // 
      // dp после i = 3: [0, 0, 0, -9]
      // 
      // 
      // i = 2 (позиция с камнем 3)
      // 
      // Исходный dp перед итерацией: [0, 0, 0, -9]  
      // Устанавливаем dp[2 % 4] = dp[2] = -Infinity
      // 
      // Внутренний цикл j
      // от 2 до min(4,3)=3 — j = 2 и j = 3:
      // 
      // - j = 2:
      //   - total = stoneValue[2] = 3
      //   - candidate = total - dp[(2 + 1) % 4]
      //     = 3 - dp[3] = 3 - (-9) = 12
      //   - dp[2] = max(-Infinity, 12) = 12
      //   - dp теперь: [0, 0, 12, -9]
      // 
      // - j = 3:
      //   - total = previous total + stoneValue[3]
      //     = 3 + (-9) = -6
      //   - candidate = total - dp[(3 + 1) % 4]
      //     = -6 - dp[0] = -6 - 0 = -6
      //   - dp[2] = max(12, -6) = 12 (остается 12)
      //   - dp после этого шага: [0, 0, 12, -9]
      // 
      // dp после i = 2: [0, 0, 12, -9]
      // 
      // 
      // i = 1 (позиция с камнем 2)
      // 
      // Исходный dp перед итерацией: [0, 0, 12, -9]  
      // Устанавливаем dp[1 % 4] = dp[1] = -Infinity
      // 
      // Внутренний цикл j
      // от 1 до min(3,3)=3 — j = 1, 2, 3:
      // 
      // - j = 1:
      //   - total = stoneValue[1] = 2
      //   - candidate = total - dp[(1 + 1) % 4]
      //     = 2 - dp[2] = 2 - 12 = -10
      //   - dp[1] = max(-Infinity, -10) = -10
      //   - dp теперь: [0, -10, 12, -9]
      // 
      // - j = 2:
      //   - total = previous total + stoneValue[2]
      //     = 2 + 3 = 5
      //   - candidate = total - dp[(2 + 1) % 4]
      //     = 5 - dp[3] = 5 - (-9) = 14
      //   - dp[1] = max(-10, 14) = 14
      //   - dp теперь: [0, 14, 12, -9]
      // 
      // - j = 3:
      //   - total = previous total + stoneValue[3]
      //     = 5 + (-9) = -4
      //   - candidate = total - dp[(3 + 1) % 4]
      //     = -4 - dp[0] = -4 - 0 = -4
      //   - dp[1] = max(14, -4) = 14 (остается 14)
      //   - dp после шага: [0, 14, 12, -9]
      // 
      // dp после i = 1: [0, 14, 12, -9]
      // 
      // 
      // i = 0 (позиция с камнем 1)
      // 
      // Исходный dp перед итерацией: [0, 14, 12, -9]  
      // Устанавливаем dp[0 % 4] = dp[0] = -Infinity
      // 
      // Внутренний цикл j от 0 до min(2,3)=2 — j = 0, 1, 2:
      // 
      // - j = 0:
      //   - total = stoneValue[0] = 1
      //   - candidate = total - dp[(0 + 1) % 4]
      //     = 1 - dp[1] = 1 - 14 = -13
      //   - dp[0] = max(-Infinity, -13) = -13
      //   - dp теперь: [-13, 14, 12, -9]
      // 
      // - j = 1:
      //   - total = previous total + stoneValue[1]
      //     = 1 + 2 = 3
      //   - candidate = total - dp[(1 + 1) % 4]
      //     = 3 - dp[2] = 3 - 12 = -9
      //   - dp[0] = max(-13, -9) = -9
      //   - dp теперь: [-9, 14, 12, -9]
      // 
      // - j = 2:
      //   - total = previous total + stoneValue[2]
      //     = 3 + 3 = 6
      //   - candidate = total - dp[(2 + 1) % 4]
      //     = 6 - dp[3] = 6 - (-9) = 15
      //   - dp[0] = max(-9, 15) = 15
      //   - dp после шага: [15, 14, 12, -9]
      // 
      // dp после i = 0: [15, 14, 12, -9]
      // 
      // 
      // Итог и интерпретация
      // 
      // - После завершения основного цикла
      //   dp[0] = 15 — это оптимальная разница
      //   (Alice − Bob) при старте с позиции 0.  
      // - Поскольку dp[0] > 0, при оптимальной
      //   игре выигрывает Alice.
    }
  }

  // После заполнения циклического буфера dp
  // значение для начальной позиции 0 находится
  // в dp[0 % 4] = dp[0].
  // Это оптимальная разница очков
  // (Alice минус Bob) при оптимальной игре обоих.
  //
  // Если разница равна нулю — результат ничья.
  if (dp[0] === 0) return 'Tie';

  // Если разница положительная — Alice получает
  // больше очков и выигрывает, иначе выигрывает
  // Bob.
  return dp[0] > 0 ? 'Alice' : 'Bob';
}
