/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 * 
 * combinationSum4, принимает два параметра:
 * nums — массив положительных целых чисел,
 *   каждое число можно взять неограниченное
 *   количество раз.
 * target — неотрицательное целое число, для
 *    которого считаем количество упорядоченных
 *    комбинаций.
 * 
 * Функция возвращает количество различных
 * упорядоченных последовательностей элементов
 * из nums, сумма которых равна target.
 * Порядок элементов в комбинации важен.
 * 
 * Пример:
 *   Для: nums = [1,2,3], target = 4
 *   Возвращает: 7
 * 
 * Примеры всех 7 упорядоченных комбинаций
 * для суммы 4 (перечислены явно)
 *   1.  1 + 1 + 1 + 1  
 *   2.  1 + 1 + 2  
 *   3.  1 + 2 + 1  
 *   4.  2 + 1 + 1  
 *   5.  2 + 2  
 *   6.  1 + 3  
 *   7.  3 + 1
 */
function combinationSum4(nums, target) {

  // Создаём массив dp длиной target + 1
  // типа Int32Array.
  //
  // dp[i] будет означать число
  // упорядоченных способов получить
  // сумму i, используя числа из nums.
  //
  // Причина длины target + 1:
  // Индекс массива напрямую соответствует
  // сумме, для которой хранится число
  // способов.
  //
  // Чтобы иметь ячейки для всех сумм
  // от 0 до target включительно, нужен
  // массив с индексами 0..target,
  // то есть длина target + 1.
  const dp = new Int32Array(target + 1);

  // Базовый случай:
  // ровно один способ
  // получить сумму 0 - выбрать пустую
  // последовательность.
  //
  // Это опорное значение, от которого
  // строятся все остальные значения dp[i].
  dp[0] = 1;

  // Внешний цикл:
  // Для каждой суммы i от 1 до target
  // мы считаем, сколько упорядоченных
  // последовательностей дают именно эту
  // сумму.
  //
  // Начинаем с i = 1, так как dp[0] уже
  // известно и выставлено как базовый
  // случай (dp[0] = 1), поэтому нет
  // необходимости пересчитывать i = 0;
  //
  // dp[1], dp[2], ..., dp[target].
  //
  // После завершения итерации для i
  // значение dp[i] окончательно и больше
  // не меняется.
  for (let i = 1; i <= target; i++) {

    // Внутренний цикл:
    // для каждого числа num из входного
    // массива nums проверяем, можно ли
    // добавить это число в конец уже
    // построенных последовательностей,
    // которые дают сумму i - num. Каждое
    // такое добавление порождает новые
    // последовательности, суммарно дающие i.
    // Перебор num в исходном порядке
    // влияет только на порядок итераций,
    // но не на корректность формулы;
    // итоговый результат учитывает все
    // способы построения последовательностей,
    // которые дают сумму i - num.
    for (const num of nums) {

      // Если num не превышает текущую
      // целевую сумму i, то все
      // последовательности, которые дают
      // сумму i - num, можно расширить
      // добавлением num в конец, получив
      // последовательности, дающие i.
      // Поэтому увеличиваем
      // dp[i] на dp[i - num].
      if (i >= num) dp[i] += dp[i - num];
    }

    // Пример для:
    // nums = [1,2,3], target = 4
    // 
    // i = 1
    // - Перед обработкой i:
    //     dp = [1, 0, 0, 0, 0]
    // 
    //   num = 1:
    //   - Условие i >= num выполнено (1 ≥ 1).
    //   - dp[1] += dp[1 - 1]
    //     → dp[1] += dp[0]
    //     → 0 + 1 = 1.
    //   - dp после этой итерации:
    //     [1, 1, 0, 0, 0]
    // 
    //   num = 2:
    //   - Условие 1 ≥ 2 ложно, пропускаем.  
    //   - dp остаётся:
    //     [1, 1, 0, 0, 0]
    // 
    //   num = 3:
    //   - Условие 1 ≥ 3 ложно, пропускаем.  
    //   - Итог после i = 1:
    //     dp = [1, 1, 0, 0, 0]
    // 
    // i = 2
    // - Перед обработкой i:
    //   dp = [1, 1, 0, 0, 0]
    // 
    //   num = 1:
    //   - 2 ≥ 1
    //     → dp[2] += dp[1]
    //     → 0 + 1 = 1.
    //   - dp: [1, 1, 1, 0, 0]
    // 
    //   num = 2:
    //   - 2 ≥ 2
    //     → dp[2] += dp[0]
    //     → 1 + 1 = 2.
    //   - dp: [1, 1, 2, 0, 0]
    // 
    //   num = 3:
    //   - 2 ≥ 3 ложно, пропускаем.
    //   - Итог после i = 2:
    //     dp = [1, 1, 2, 0, 0]
    // 
    // i = 3
    // - Перед обработкой i:
    //   dp = [1, 1, 2, 0, 0]
    //
    //   num = 1:
    //   - 3 ≥ 1
    //     → dp[3] += dp[2]
    //     → 0 + 2 = 2.
    //   - dp: [1, 1, 2, 2, 0]
    // 
    //   num = 2:
    //   - 3 ≥ 2
    //     → dp[3] += dp[1]
    //     → 2 + 1 = 3.
    //   - dp: [1, 1, 2, 3, 0]
    // 
    //   num = 3:
    //   - 3 ≥ 3
    //     → dp[3] += dp[0]
    //     → 3 + 1 = 4.
    //   - dp: [1, 1, 2, 4, 0]
    // 
    //   - Итог после i = 3:
    //     dp = [1, 1, 2, 4, 0]
    // 
    // i = 4
    // - Перед обработкой i:
    //   dp = [1, 1, 2, 4, 0]
    // 
    //   num = 1:
    //   - 4 ≥ 1
    //     → dp[4] += dp[3]
    //     → 0 + 4 = 4.
    //   - dp: [1, 1, 2, 4, 4]
    // 
    //   num = 2:
    //   - 4 ≥ 2
    //     → dp[4] += dp[2]
    //     → 4 + 2 = 6.
    //   - dp: [1, 1, 2, 4, 6]
    // 
    //   num = 3:
    //   - 4 ≥ 3
    //     → dp[4] += dp[1]
    //     → 6 + 1 = 7.
    //   - dp: [1, 1, 2, 4, 7]
    // 
    //   - Итог после i = 4:
    //     dp = [1, 1, 2, 4, 7]
    // 
    // Финальное значение возвращаемое
    // функцией:
    // - dp[4] = 7 — это количество
    //   упорядоченных комбинаций из [1,2,3],
    //   сумма которых равна 4.
    // 
    // 
    // Примеры всех 7 упорядоченных комбинаций
    // для суммы 4 (перечислены явно)
    //  1.  1 + 1 + 1 + 1  
    //  2.  1 + 1 + 2  
    //  3.  1 + 2 + 1  
    //  4.  2 + 1 + 1  
    //  5.  2 + 2  
    //  6.  1 + 3  
    //  7.  3 + 1
  }

  // После заполнения dp возвращаем количество
  // упорядоченных комбинаций, дающих сумму
  // target.
  return dp[target];
}
