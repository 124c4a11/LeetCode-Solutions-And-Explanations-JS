/**
 * @param {number} n
 * @return {number}
 * 
 * numSquares, принимает один аргумент
 * n — целевое натуральное число,
 * для которого возвращает минимальное
 * количество квадратов целых чисел,
 * сумма которых равна n
 * 
 * Пример:
 *  Для 
 *    n = 6 
 *  Возвращает: 
 *    3 (6 = 4 + 1 + 1)
 */
function numSquares(n) {

  // Создаём массив dp длиной n + 1,
  // каждый элемент хранит минимальное
  // количество квадратов, необходимое
  // чтобы получить индекс этого элемента;
  // изначально заполняем значением n,
  // поскольку в худшем случае можно
  // представить любое число как сумма
  // единиц (n = 1+1+...+1)
  //
  // Пример: 
  // при n = 6 после dp[0] = 0:
  // dp = [0, 6, 6, 6, 6, 6, 6]
  const dp = new Int32Array(n + 1).fill(n);

  // Инициализация базового случая:
  // для суммы 0 требуется 0 слагаемых,
  // поэтому dp[0] = 0
  dp[0] = 0;

  // Внешний цикл:
  // последовательно вычисляем оптимальные
  // значения dp[target] для всех
  // промежуточных целей от 1 до n
  // включительно
  //
  // Цикл начинается с target = 1,
  // потому что значение для суммы 0 уже
  // известно и обработано отдельно:
  // dp[0] = 0.
  //
  // Такой порядок гарантирует,
  // что при вычислении dp[target]
  // все dp[<target] уже известны
  for (let target = 1; target <= n; target++) {

    // Внутренний цикл:
    // перебираем все возможные целые
    // s такие, что s*s не превышает
    // текущую цель.
    //
    // Это эквивалентно перебору всех
    // возможных квадратов, которые
    // можно использовать для
    // представления target
    for (let s = 1; s * s <= target; s++) {

      // Рассматриваем вариант,
      // в котором первый элемент
      // суммы - s*s.
      //
      // Тогда остаётся покрыть остаток
      // target - s*s, для которого уже
      // известно оптимальное значение
      // dp[target - s*s].
      //
      // Общее число квадратов в этом
      // варианте равно
      // 1 (текущий s*s) + dp[target - s*s].
      //
      // Взяв минимум с текущим dp[target],
      // мы сохраняем лучшее (минимальное)
      // найденное разбиение для target.
      dp[target] = Math.min(
        dp[target],
        1 + dp[target - s * s]
      );
    }

    // Пример при n = 6:
    //
    // Исходная инициализация:
    // - n = 6
    // - Создаём dp длины 7 и заполняем значением 6,
    //   затем dp[0] = 0.
    // - Начальное состояние:
    //   dp = [0, 6, 6, 6, 6, 6, 6]
    //
    //
    // target = 1
    // - s = 1 (1*1 ≤ 1)
    //   - Вычисляем кандидат:
    //     1 + dp[1 - 1*1] = 1 + dp[0] = 1
    //   - Обновляем dp[1] = min(6, 1) = 1
    //   - Состояние после шага:
    //     dp = [0, 1, 6, 6, 6, 6, 6]
    //
    //
    // target = 2
    // - s = 1 (1*1 ≤ 2)
    //   - Кандидат:
    //     1 + dp[2 - 1] = 1 + dp[1] = 2
    //   - Обновляем dp[2] = min(6, 2) = 2
    //   - Состояние:
    //     dp = [0, 1, 2, 6, 6, 6, 6]
    //
    //
    // target = 3
    // - s = 1 (1*1 ≤ 3)
    //   - Кандидат:
    //     1 + dp[3 - 1] = 1 + dp[2] = 3
    //   - Обновляем dp[3] = min(6, 3) = 3
    //   - Состояние:
    //     dp = [0, 1, 2, 3, 6, 6, 6]
    //
    //
    // target = 4
    // - s = 1 (1*1 ≤ 4)
    //   - Кандидат:
    //     1 + dp[4 - 1] = 1 + dp[3] = 4
    //   - Временное состояние: dp[4] = 4 (пока)
    //   - dp = [0, 1, 2, 3, 4, 6, 6]
    // - s = 2 (2*2 = 4 ≤ 4)
    //   - Кандидат:
    //     1 + dp[4 - 4] = 1 + dp[0] = 1
    //   - Обновляем dp[4] = min(4, 1) = 1
    //   - Состояние после всех s:
    //     dp = [0, 1, 2, 3, 1, 6, 6]
    //
    //
    // target = 5
    // - s = 1 (1*1 ≤ 5)
    //   - Кандидат:
    //     1 + dp[5 - 1] = 1 + dp[4] = 2
    //   - Временное состояние: dp[5] = 2
    //   - dp = [0, 1, 2, 3, 1, 2, 6]
    // - s = 2 (2*2 = 4 ≤ 5)
    //   - Кандидат:
    //     1 + dp[5 - 4] = 1 + dp[1] = 2
    //   - dp[5] = min(2, 2) = 2 (без изменений)
    //   - Состояние после всех s:
    //     dp = [0, 1, 2, 3, 1, 2, 6]
    //
    //
    // target = 6
    // - s = 1 (1*1 ≤ 6)
    //   - Кандидат:
    //     1 + dp[6 - 1] = 1 + dp[5] = 3
    //   - Временное состояние: dp[6] = 3
    //   - dp = [0, 1, 2, 3, 1, 2, 3]
    // - s = 2 (2*2 = 4 ≤ 6)
    //   - Кандидат:
    //     1 + dp[6 - 4] = 1 + dp[2] = 3
    //   - dp[6] = min(3, 3) = 3 (без изменений)
    //   - Состояние после всех s:
    //     dp = [0, 1, 2, 3, 1, 2, 3]
    //
    //
    // Итог:
    // после завершения циклов
    // dp = [0, 1, 2, 3, 1, 2, 3],
    // функция вернёт dp[6] = 3.
    //
    // Разложение для 6 с минимальным
    // количеством  квадратов: 6 = 4 + 1 + 1.
  }

  // Возвращаем минимальное количество квадратов
  // для исходной цели n, вычисленное в dp[n]
  return dp[n];
}
