/**
 * @param {number[][]} trips
 * @param {number} capacity
 * @return {boolean}
 * 
 * Функция carPooling проверяет, можно ли выполнить
 * все поездки без превышения вместимости автомобиля.
 * 
 * Параметры:
 *  trips    — массив поездок, каждая поездка
 *             задаётся как 
 *             [numPassengers, from, to], где:
 *             numPassengers — количество пассажиров,
 *             from — километр, где они садятся,
 *             to — километр, где они выходят.
 *              
 *  capacity — максимальное число пассажиров,
 *             которое может одновременно находиться
 *             в автомобиле
 * 
 * Пример: 
 * для trips = [[2,1,5],[3,3,7]], capacity = 5
 * результат: true
 */
function carPooling(trips, capacity) {

  // Создаем типизированный массив длиной 1001,
  // где каждый индекс представляет километр
  // маршрута.
  //
  // Значения в массиве будут отражать изменение
  // количества пассажиров на этом километре:
  // положительное — посадка,
  // отрицательное — высадка.
  let passengerDeltaByKm = new Int32Array(1001);

  // Проходим по каждому запросу на поездку из
  // массива trips.
  // Каждый элемент — это массив
  // [numPassengers, from, to], где:
  //   numPassengers — количество пассажиров,
  //   from — километр, где они садятся,
  //   to — километр, где они выходят.
  //
  // ---
  //
  // Этот цикл — это оптимизированный способ
  // учесть все поездки без необходимости
  // отслеживать каждую точку маршрута вручную. 
  // Он использует технику, известную как 
  // разностный массив (difference array),
  // которая позволяет эффективно моделировать
  // изменения во времени или пространстве.
  //
  // ---
  //
  // Что делает этот цикл?
  //
  // Он не моделирует каждую поездку напрямую,
  // а вместо этого:
  // - фиксирует точку посадки пассажиров (from)
  //   как увеличение количества,
  // - и точку высадки (to) как уменьшение
  //   количества.
  //
  // Таким образом, мы не записываем,
  // что пассажиры находятся в машине между
  // from и to, а просто указываем, где они
  // вошли и вышли. 
  // Это позволяет позже, в одном проходе,
  // восстановить реальное количество пассажиров
  // на каждом километре маршрута.
  //
  // ---
  //
  // Почему это эффективно?
  //
  // Представь, что у нас есть поездка:  
  // [3, 2, 5] - 3 пассажира сели на 2 км
  // и вышли на 5 км
  //
  // Вместо того чтобы вручную увеличивать
  // количество пассажиров на 2-м,
  // 3-м и 4-м километре, мы делаем:
  // passengerDeltaByKm[2] += 3; // посадка
  // passengerDeltaByKm[5] -= 3; // высадка
  //
  // А затем, когда мы идём по маршруту
  // и суммируем эти изменения, мы получаем:
  // - на 2 км: +3 → стало 3
  // - на 3 км: +0 → осталось 3
  // - на 4 км: +0 → осталось 3
  // - на 5 км: –3 → стало 0
  //
  // То есть эффект поездки распространяется
  // автоматически, без явного перебора всех
  // промежуточных точек.
  //
  // ---
  //
  // Почему это важно?
  //
  // - Скорость: вместо O(n × d),
  //   где d — длина поездки, мы получаем O(n)
  //   для подготовки и O(m) для анализа
  //   маршрута.
  // - Память: мы не храним состояние на каждом
  //   километре для каждой поездки — только
  //   итоговое изменение.
  // - Простота: логика становится линейной и
  //   легко масштабируется.
  //
  // ---
  //
  // Итог
  //
  // Этот цикл — это подготовительный этап,
  // который превращает список поездок в компактное
  // представление изменений пассажиров по маршруту. 
  // Он закладывает основу для следующего цикла,
  // который уже проверяет, не превышена ли
  // вместимость автомобиля в какой-либо точке.
  for (const [numPassengers, from, to] of trips) {

    // Помечаем посадку: на километре from
    // добавляем numPassengers
    //
    // для trips = [[2,1,5],[3,3,7]]:
    // После первой поездки: passengerDeltaByKm[1] == 2
    // После второй поездки: passengerDeltaByKm[3] == 3
    passengerDeltaByKm[from] += numPassengers;

    // Помечаем высадку: на километре to
    // вычитаем numPassengers
    //
    // для trips = [[2,1,5],[3,3,7]]:
    // После первой поездки: passengerDeltaByKm[5] == -2
    // После второй поездки: passengerDeltaByKm[7] == -3
    passengerDeltaByKm[to] -= numPassengers;

    // passengerDeltaByKm после заполнения
    // для trips = [[2,1,5],[3,3,7]]:
    //
    // const passengerDeltaByKm = [
    //   0,   // km 0
    //   2,   // km 1: +2 от [2,1,5]
    //   0,   // km 2
    //   3,   // km 3: +3 от [3,3,7]
    //   0,   // km 4
    //  -2,   // km 5: -2 от [2,1,5]
    //   0,   // km 6
    //  -3,   // km 7: -3 от [3,3,7]
    //   // km 8–1000: нет изменений, все нули
    //   ...Array(1001 - 8).fill(0)
    // ];
  }

  // Инициализируем счётчик текущего числа пассажиров
  // в автомобиле
  let currCapacity = 0;

  // Проходим по всем километрам маршрута от 0 до 1000
  // включительно
  //
  // ---
  //
  // Что делает этот цикл?
  //
  // Он эмулирует движение автомобиля по маршруту,
  // проходя по каждой точке (километру) от 0 до 1000
  // включительно, и накапливает изменения количества
  // пассажиров, чтобы проверить, не превышает ли
  // текущая загрузка автомобиля его вместимость.
  //
  // ---
  //
  // Почему нужен currCapacity?
  //
  // Переменная currCapacity отслеживает текущее
  // количество пассажиров в машине на каждом километре
  // пути.  
  // Массив passengerDeltaByKm хранит дельты — то есть,
  // сколько пассажиров добавляется или убавляется
  // на конкретном километре.
  //
  // ---
  //
  // Почему это эффективно?
  //
  // - Вместо того чтобы проверять каждую поездку
  //   по отдельности, мы используем разностный
  //   массив и один проход по маршруту.
  // - Это даёт линейную сложность O(n + m), где
  //   n — количество поездок,
  //   m — длина маршрута (1001), что очень быстро.
  //
  // ---
  //
  // Итог
  //
  // Этот цикл — это симуляция движения автомобиля,
  // где мы отслеживаем, сколько пассажиров в нём
  // в каждый момент времени (или точке маршрута), 
  // и проверяем, не перегружен ли он.  
  // Без него мы не смогли бы понять, как пересекаются
  // поездки и влияют друг на друга.
  for (let i = 0; i < 1001; i++) {

    // Добавляем дельту пассажиров на текущем
    // километре к общему числу
    // Таким образом получаем число людей в салоне
    // на этом километре
    //
    // На примере trips = [[2,1,5],[3,3,7]]:
    // i=0 → currCapacity = 0 + 0 = 0
    // i=1 → currCapacity = 0 + 2 = 2  (посадили 2)
    // i=2 → currCapacity = 2 + 0 = 2
    // i=3 → currCapacity = 2 + 3 = 5  (посадили ещё 3)
    // i=4 → currCapacity = 5 + 0 = 5
    // i=5 → currCapacity = 5 - 2 = 3  (высадили 2)
    // i=6 → currCapacity = 3 + 0 = 3
    // i=7 → currCapacity = 3 - 3 = 0  (высадили 3)
    // Дальше currCapacity остаётся 0
    currCapacity += passengerDeltaByKm[i];

    // Если в любой момент число пассажиров стало
    // больше capacity (5), возвращаем false
    //
    // В примере
    // для trips = [[2,1,5],[3,3,7]], capacity = 5
    // currCapacity никогда не превысит 5, так что
    // этот if не сработает
    if (currCapacity > capacity) return false;
  }

  // Если ни в одной точке маршрута вместимость
  // не была превышена, возвращаем true
  //
  // Пример: 
  // для trips = [[2,1,5],[3,3,7]], capacity = 5
  // результат: true
  return true;
}
