/**
 * @param {number} k
 * @param {number} w
 * @param {number[]} profits
 * @param {number[]} capital
 * @return {number}
 * 
 * findMaximizedCapital выбирает не более k проектов
 * для максимизации капитала с параметрами:
 *   k — максимальное количество проектов, которые
 *       можно выбрать
 *   w — начальный капитал
 *   profits — массив прибылей от проектов
 *   capital — массив необходимого капитала для старта
 *             каждого проекта
 * 
 * Пример для: 
 * k = 2  
 * w = 0  
 * profits = [1, 2, 3]
 * capital = [0, 1, 1]
 * Результат w = 4.
 */
function findMaximizedCapital(k, w, profits, capital) {

  // Получаем общее число проектов.
  //
  // В примере: 
  // n = profits.length = 3.
  const n = profits.length;

  // Создаем массив индексов проектов [0, 1, 2].
  // Это позволит сортировать не сами прибыли,
  // а индексы по требуемому капиталу.
  const indices = Array.from({ length: n }, (_, i) => i);

  // Сортируем массив индексов по возрастанию
  // требуемого капитала для каждого проекта.
  //
  // Пример:
  // Смотрим capital: [0, 1, 1].
  // После сортировки indices = [0, 1, 2].
  indices.sort((a, b) => capital[a] - capital[b]);

  // Инициализируем max-кучу (приоритетную очередь)
  // для прибылей доступных проектов.
  // Это позволит быстро извлекать самый прибыльный
  // проект из доступных
  const maxProfit = new MaxPriorityQueue();

  // Указатель i пробегает по отсортированным
  // проектам.
  let i = 0;

  // Основной цикл: выполняем не более k итераций
  // (запускаем до k проектов).
  //
  // В примере k = 2.
  for (let j = 0; j < k; j++) {

    // Добавляем в очередь все проекты, доступные
    // при текущем капитале w, то есть требуемый
    // капитал которых не превышает текущего w.
    //
    // Первая итерация (j=0, w=0):
    //   indices[0] = 0 → capital[0] = 0 ≤ w
    //     → enqueue profit 1
    //   indices[1] = 1 → capital[1] = 1 > w
    //     → останавливаем добавление
    while (
      i < n
      && capital[indices[i]] <= w
    ) {
      maxProfit.enqueue(profits[indices[i]]);
      i++;
    }

    // Если очередь пуста, значит нет ни одного
    // проекта, который можно запустить
    // при текущем w, выходим из цикла досрочно.
    if (maxProfit.isEmpty()) break;

    // Извлекаем максимальную прибыль и добавляем
    // к текущему капиталу w, что позволит
    // на следующийх итерациях запускать проеты,
    // для которых нужен больший капитал.
    //
    // Повышая w на каждом шаге, мы обеспечиваем
    // жадный выбор наиболее прибыльных проектов и,
    // как следствие, максимально быстрый рост
    // капитала.
    //
    // Пример:
    // - j = 0: 
    //     dequeue() = 1 → w = 0 + 1 = 1.
    // - j = 1: 
    //     перед dequeue в куче [2, 3],
    //     dequeue() = 3 → w = 1 + 3 = 4.
    w += maxProfit.dequeue();

    // Пример работы цикла:
    //
    // Шаг 1 (j = 0):
    //   Начало: w = 0, i = 0
    //   Внутренний цикл:
    //     capital[indices[0]] = 
    //        capital[0] = 0 ≤ w(0)
    //        → enqueue(profits[0] = 1), i = 1
    //     capital[indices[1]] =
    //        capital[1] = 1 > w(0)
    //        → выходим из while
    //   maxProfit = [1]  // единственный элемент в очереди
    //   Очередь не пуста → dequeue() = 1 → w = 0 + 1 = 1
    //   После выполнения: w = 1, maxProfit = []
    //
    // Шаг 2 (j = 1):
    //   Начало: w = 1, i = 1
    //   Внутренний цикл:
    //     capital[indices[1]] =
    //       capital[1] = 1 ≤ w(1)
    //       → enqueue(profits[1] = 2), i = 2
    //     capital[indices[2]] =
    //       capital[2] = 1 ≤ w(1)
    //       → enqueue(profits[2] = 3), i = 3
    //     i = n → выходим из while
    //   maxProfit = [3, 2]  // очередь упорядочена
    //   по убыванию прибыли
    //   Очередь не пуста → dequeue() = 3 → w = 1 + 3 = 4
    //   После выполнения: w = 4, maxProfit = [2]
  }

  // Возвращаем итоговый капитал после выполнения
  // до k проектов
  //
  // В примере результат w = 4
  return w;
}
