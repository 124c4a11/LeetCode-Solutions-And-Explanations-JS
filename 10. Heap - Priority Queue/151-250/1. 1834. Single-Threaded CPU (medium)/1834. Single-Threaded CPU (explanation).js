/**
 * @param {number[][]} tasks
 * @return {number[]}
 * 
 * getOrder принимает на вход массив задач
 * tasks и решает задачу планирования
 * выполнения набора задач с учётом времени
 * их появления и длительности. Каждая
 * задача становится доступной в указанное
 * время startTime и требует duration
 * единиц времени на исполнение. CPU всегда
 * берёт задачу с наименьшей оставшейся
 * длительностью; если длительности равны,
 * выбирается задача с меньшим исходным
 * индексом. Такая стратегия гарантирует
 * минимизацию простоев процессора при
 * учёте времени доступности задач.
 * 
 * Функция вернёт массив порядковых индексов
 * задач в том порядке, в котором CPU их
 * выполнит.
 * 
 * Пример вызова:
 * getOrder([[1, 2], [2, 4], [3, 2]]);
 * вернет [0, 2, 1]
 * то есть сначала выполняется задача с
 * исходным индексом 0, потом 2, а затем 1
 */
function getOrder(tasks) {

  // Проверяем, что tasks существует и
  // содержит хотя бы один элемент, иначе
  // возвращаем пустой массив
  if (!tasks?.length) return [];

  // Сохраняем количество задач
  // в переменную n для дальнейшего
  // использования
  const n = tasks.length;

  // Преобразуем каждый вложенный массив
  // [startTime, duration] в объект
  // с читаемыми ключами и оригинальным
  // индексом задачи.
  //
  // Индекс нужен, чтобы востановить
  // исходный порядок выполнения
  //
  // Преобразование для примера:
  // [1,2] → { startTime: 1, duration: 2, index: 0 }
  // [2,4] → { startTime: 2, duration: 4, index: 1 }
  // [3,2] → { startTime: 3, duration: 2, index: 2 }
  //
  // Затем сортируем по времени запуска
  // - от самой ранней задачи к более
  // поздним
  //
  // Для примера получится:
  // [
  //   { startTime: 1, duration: 2, index: 0 },
  //   { startTime: 2, duration: 4, index: 1 },
  //   { startTime: 3, duration: 2, index: 2 }
  // ]
  const sortedTasks = tasks
    .map((task, i) => ({

      // время, когда задача
      // становится доступной
      startTime: task[0],

      // сколько времени
      // требуется на выполнение
      duration: task[1],

      // оригинальная позиция задачи
      // в входном массиве
      index: i
    }))
    .sort((a, b) => a.startTime - b.startTime);

  // Создаём мин-кучу (приоритетную очередь),
  // которая будет выбирать задачу
  // с наименьшей duration
  // (временем выполнения),
  // а при равенстве duration — с меньшим
  // index, так как задачи с меньшим
  // временем выполнения и меньшим исходным
  // индексом имеют более высокий приоритет
  const minQueue = new PriorityQueue((a, b) => {
    if (a.duration === b.duration) {
      return a.index - b.index;
    } else {
      return a.duration - b.duration;
    }
  })

  // Инициализируем массив result для
  // хранения порядка выполнения задач
  // (исходные индексы задач)
  const result = [];

  // Текущее время процессора (момент,
  // когда он свободен для новой задачи)
  let cpuStartTime = 0;

  // Счётчик для обхода sortedTasks
  // i указывает на следующую ещё не
  // добавленную в очередь задачу
  let i = 0;

  // Основной цикл:
  // пока очередь не пуста, либо есть
  // не обработанные задачи
  while (!minQueue.isEmpty() || i < n) {

    // Если очередь пуста и текущее
    // время CPU меньше времени
    // начала следующей задачи,
    // перемещаем время CPU к моменту
    // старта этой следующей задачи
    //
    // На первом шаге cpuStartTime=0,
    // а sortedTasks[0].startTime=1, 
    // поэтому cpuStartTime
    // установливаем в 1
    if (
      minQueue.isEmpty()
      && cpuStartTime < sortedTasks[i].startTime
    ) cpuStartTime = sortedTasks[i].startTime;

    // Добавляем в очередь все задачи,
    // у которых время начала меньше
    // или равно текущему времени CPU
    //
    // Для cpuStartTime=1 добавится
    // только задача {1,2,0}
    while (
      i < n
      && cpuStartTime >= sortedTasks[i].startTime
    ) {

      // Помещаем задачу
      // sortedTasks[i] в очередь
      minQueue.enqueue(sortedTasks[i]);

      // Переходим к следующей
      // задаче в sortedTasks
      i++;
    }

    // Извлекаем из очереди задачу
    // с наивысшим приоритетом
    // (минимальной duration или
    // минимальным index при равных
    // duration)
    //
    // Пример:
    // Шаг 1: Объект { startTime: 1, duration: 2, index: 0 }
    // Шаг 2: Объект { startTime: 3, duration: 2, index: 2 }
    // Шаг 3: Объект { startTime: 2, duration: 4, index: 1 }
    const nextTask = minQueue.dequeue();

    // "Выполняем" задачу, сдвигая
    // cpuStartTime на её длительность
    //
    // Пример:
    // cpuStartTime = 1, duration = 2
    // → cpuStartTime = 3
    //
    // cpuStartTime = 1 + 2 = 3
    cpuStartTime += nextTask.duration;

    // Записываем в result оригинальный
    // индекс выполненной задачи
    result.push(nextTask.index);

    // Пошаговый разбор работы
    // getOrder([[1, 2], [2, 4], [3, 2]])
    //
    // Исходные данные перед началом
    // - Отсортированный список задач
    //   по времени старта:
    //
    //   sortedTasks = [
    //     { startTime: 1, duration: 2, index: 0 },
    //     { startTime: 2, duration: 4, index: 1 },
    //     { startTime: 3, duration: 2, index: 2 }
    //   ]
    //
    // - cpuStartTime = 0  
    // - minQueue = []  
    // - result = []  
    //
    // ---
    //
    // Шаг 1
    // - cpuStartTime до добавления: 0  
    // - Так как очередь пуста и первая
    //   задача становится доступной в 1,
    //   устанавливаем для cpuStartTime 
    //   значение 1  
    // - В очередь добавляется  
    //   - Task0 
    //     { startTime: 1, duration: 2, index: 0 },
    // - Состояние minQueue:
    //   - [
    //       { startTime: 1, duration: 2, index: 0 },
    //    ]  
    // - Извлекается nextTask = Task0 (index 0)  
    // - cpuStartTime после выполнения: 1 + 2 = 3  
    // - result = [0]  
    //
    // ---
    //
    // Шаг 2
    // - cpuStartTime до добавления: 3  
    //   (расчитан на предыдущем шаге)
    // - Добавляем в очередь все задачи
    //   с startTime ≤ 3:  
    //   - Task1
    //       { startTime: 2, duration: 4, index: 1 },
    //   - Task2 
    //       { startTime: 3, duration: 2, index: 2 }
    // - Состояние minQueue,
    //    отсортированное по приоритету:  
    //   - [
    //       { startTime: 3, duration: 2, index: 2 },
    //       { startTime: 2, duration: 4, index: 1 }
    //     ] ← Task2 первее, так как duration=2 < 4  
    // - Извлекается nextTask = Task2 (index 2)  
    //       { startTime: 3, duration: 2, index: 2 },
    // - cpuStartTime после выполнения: 3 + 2 = 5  
    // - result = [0, 2]  
    //
    // ---
    //
    // Шаг 3
    // - cpuStartTime до добавления: 5  
    //   (расчитан на предыдущем шаге)
    // - Никаких новых задач для добавления (i = n)  
    // - Состояние minQueue:
    //   - [
    //       { startTime: 2, duration: 4, index: 1 }
    //     ]
    // - Извлекается nextTask = Task1 (index 1)  
    //       { startTime: 2, duration: 4, index: 1 }
    // - cpuStartTime после выполнения: 5 + 4 = 9  
    // - result = [0, 2, 1]  
    //
    // ---
    //
    // В итоге функция возвращает [0, 2, 1],
    // что означает:  
    // 1) сначала выполняется задача 0,  
    // 2) затем задача 2,  
    // 3) и последней — задача 1. 
  }

  // Возвращаем итоговый массив исходных индексов
  // задач в том порядке, в каком они были выполнены
  //
  // Пример:
  // для tasks = [[1, 2], [2, 4], [3, 2]];
  // результат [0, 2, 1]
  return result;
}
