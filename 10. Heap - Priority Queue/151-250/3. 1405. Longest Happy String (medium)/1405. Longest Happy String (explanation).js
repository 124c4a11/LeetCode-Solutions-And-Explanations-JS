/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {string}
 * 
 * longestDiverseString принимает три числа,
 * которые представляют частоты букв 
 *  'a', 'b' и 'c' и строит максимальную
 * по длине строку из этих букв не допуская
 * трёх одинаковых символов подряд.
 *
 * Пример:
 * Для a=1, b=1, c=7
 * Результат: "ccaccbcc"
 */
function longestDiverseString(a, b, c) {

  // Инициализируем массив частот для символов:
  //
  // индекс - Unicode символт текущей буквы
  // за вычетом кода 'a' ('a'.charCodeAt(0) → 97)
  // для 'a' индекс = 97 - 97 = 0
  // для 'b' индекс = 98 - 97 = 1
  // для 'c' индекс = 99 - 97 = 2
  //
  // значение - частота входения буквы
  //
  // Для a=1, b=1, c=7:
  // 'a' → charFreq[0] = 1
  // 'b' → charFreq[1] = 1
  // 'c' → charFreq[2] = 7
  const charFreq = [a, b, c];

  // Вспомогательная функция: возвращает индекс
  // буквы с наибольшей частотой, кроме
  // заблокированного blockedNdx.
  //
  // Если ничего не подходит, вернёт -1.
  function getMaxNdx(blockedNdx) {

    // maxFreq — текущая наибольшая
    // встреченная частота (изначально 0)
    let maxFreq = 0;

    // i — индекс символа с этой частотой
    // или -1, если подходящих нет
    let i = -1;

    // Проходим по всем трем буквам
    for (let j = 0; j < 3; j++) {

      // Пропускаем, если j совпадает с
      // заблокированным blockedNdx
      // или частота charFreq[j] не
      // превышает уже найденную maxFreq
      //
      // Например, при первом вызове
      // blockedNdx = -1, maxFreq = 0:
      // j=0 → charFreq[0]=1 > 0 → maxFreq=1, i=0
      // j=1 → charFreq[1]=1 <= 1 → пропуск
      // j=2 → charFreq[2]=7 > 1 → maxFreq=7, i=2
      if (
        j === blockedNdx
        || charFreq[j] <= maxFreq
      ) continue;

      // Иначе фиксируем новую
      // максимальную частоту и её индекс
      maxFreq = charFreq[j];
      i = j;
    }

    // Возвращаем индекс символа с наибольшей
    // частотой или -1, если все символы
    // заблокированы или исчерпаны
    return i;
  };

  // Массив для накопления символов результирующей
  // строки
  const result = [];

  // blockedNdx — индекс символа, который нельзя
  // брать на следующем шаге, чтобы не получить
  // три одинаковых символа подряд.
  //
  // -1 означает отсутствие заблокированных
  // индексов
  let blockedNdx = -1;

  // Запускаем цикл, который прерывается,
  // когда больше нет доступных символов
  while (true) {

    // Ищем индекс следующего символа с
    // максимальной частотой, исключая blockedNdx
    const maxNdx = getMaxNdx(blockedNdx);

    // Если getMaxNdx вернул -1, больше добавить
    // нечего — выходим из цикла
    if (maxNdx === -1) break;

    // Конвертируем индекс в символ,
    // добавляя к нему код символа 'a' (97)
    // 0→'a',1→'b',2→'c' и добавляем его
    // к результату
    //
    // Первый шаг для (1,1,7): добавляем 'c'
    result.push(String.fromCharCode(maxNdx + 97));

    // Уменьшаем в charFreq количество взятого
    // символа
    //
    // Теперь для charFreq = [1, 1, 7]
    // после первого добавления 'c':
    // charFreq = [1, 1, 6]
    charFreq[maxNdx]--;

    // Если последние два добавленных символа
    // одинаковы, блокируем этот индекс,
    // чтобы не получить три одинаковых
    // символа подряд.
    //
    // После второго 'c' подряд
    // (result = ['c','c']) blockedNdx станет 2.
    if (
      result.length > 1
      && result.at(-1) === result.at(-2)
    ) {
      blockedNdx = maxNdx;
    } else {

      // Иначе снимаем блокировку — можно
      // снова выбирать самый частый
      blockedNdx = -1;
    }

    // Пример работы функции для a=1, b=1, c=7:
    //
    // Инициализация:
    //   charFreq = [1, 1, 7],
    //   blockedNdx = -1
    //
    // Шаг 1: 
    //   getMaxNdx(-1) → 2 ('c')
    //   result = ['c']
    //   charFreq = [1, 1, 6]
    //   blockedNdx = -1
    //
    // Шаг 2:
    //   getMaxNdx(-1) → 2 ('c')
    //   result = ['c','c']
    //   charFreq = [1, 1, 5]
    //   blockedNdx = 2
    //
    // Шаг 3:
    //   getMaxNdx(2) → 0 ('a')
    //   result = ['c','c','a']
    //   charFreq = [0, 1, 5]
    //   blockedNdx = -1
    //
    // Шаг 4:
    //   getMaxNdx(-1) → 2 ('c')
    //   result = ['c','c','a','c']
    //   charFreq = [0, 1, 4]
    //   blockedNdx = -1
    //
    // Шаг 5:
    //   getMaxNdx(-1) → 2 ('c')
    //   result = ['c','c','a','c','c']
    //   charFreq = [0, 1, 3]
    //   blockedNdx = 2
    //
    // Шаг 6:
    //   getMaxNdx(2) → 1 ('b')
    //   result = ['c','c','a','c','c','b']
    //   charFreq = [0, 0, 3]
    //   blockedNdx = -1
    //
    // Шаг 7:
    //   getMaxNdx(-1) → 2 ('c')
    //   result = ['c','c','a','c','c','b','c']
    //   charFreq = [0, 0, 2]
    //   blockedNdx = -1
    //
    // Шаг 8:
    //   getMaxNdx(-1) → 2 ('c')
    //   result = ['c','c','a','c','c','b','c','c']
    //   charFreq = [0, 0, 1]
    //   blockedNdx = 2
    //
    // Шаг 9:
    //   getMaxNdx(2) → -1 → выходим из цикла
    //
    // Итоговая строка: "ccaccbcc"
  }

  // Объединяем массив символов в единую строку
  // и возвращаем ее
  //
  // Пример:
  // Для  a=1, b=1, c=7
  // Результат "ccaccbcc"
  return result.join('');
}
