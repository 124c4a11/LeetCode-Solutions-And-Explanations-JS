/**
 * @param {string} s
 * @return {string}
 * 
 * reorganizeString принимает строку s
 * и возвращает новую строку в которой
 * два одинаковых символа не стоят рядом.
 * 
 * Пример:
 * для s = 'aaabc'
 * результат 'abaca'
 */
function reorganizeString(s) {
  // Получаем длину входной строки и
  // сохраняем в n.
  const n = s.length;

  // Создаём массив длины 26 для
  // подсчёта частоты каждой буквы в
  // диапазоне 'a'–'z'.
  //
  // Все элементы изначально равны 0.
  const charFreq = new Int32Array(26);

  // Подсчитываем вхождения каждой буквы
  // в строке s.
  for (const char of s) {
    // Преобразуем символ в индекс 0–25:
    // берём его Unicode и вычитаем код
    // 'a' ('a'.charCodeAt(0) → 97),
    // чтобы получить индекс 0–25.
    // Поэтому для 'a' 
    // индекс = 97 − 97 = 0,
    // для 'b' 
    // индекс = 98 - 97 = 1 и т.д.
    // Увеличиваем счётчик в
    // соответствующей
    // ячейке charFreq.
    //
    // Для s = 'aaabc':
    // 'a' → charFreq[0] = 1
    // 'a' → charFreq[0] = 2
    // 'a' → charFreq[0] = 3
    // 'b' → charFreq[1] = 1
    // 'c' → charFreq[2] = 1
    //
    // После цикла для 'aaabc'
    // charFreq = [3,1,1,0,…,0].
    charFreq[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
  }

  // Инициализируем переменную maxNdx,
  // где будем хранить индекс буквы
  // с наибольшей частотой
  //
  // Инициализируем maxNdx = 0
  // (предполагаем, что наиболее
  // частая буква — 'a').
  let maxNdx = 0;

  // Ищем индекс буквы с наибольшей
  // частотой в массиве charFreq.
  //
  // Цикл стартует с i=1 так как
  // индекс 0 уже учтен в переменной
  // maxNdx при инициализации, и если
  // стартануть цикл с i=0, то придется
  // сравнивать charFreq[0] саму с собой
  for (let i = 1; i < 26; i++) {

    // Если текущий счётчик charFreq[i]
    // больше ранее найденного максимума,
    // запоминаем новый индекс наиболее
    // частого символа.
    //
    // В примере maxNdx останется 0,
    // потому что charFreq[0] = 3 —
    // самое большое значение.
    if (charFreq[i] > charFreq[maxNdx]) {
      maxNdx = i;
    }
  }

  // Сохраняем число вхождений самой
  // частой буквы.
  //
  // Пример:
  // для s = 'aaabc'
  // maxFreq = charFreq[0] = 3
  const maxFreq = charFreq[maxNdx];

  // Проверяем, не слишком ли часто
  // встречается одна буква.
  //
  // Пояснение формулы
  // Math.ceil(n / 2)
  //
  // Эта формула вычисляет максимально
  // возможное число "слотов" для
  // размещения самого частого символа так,
  // чтобы между его вхождениями всегда
  // оставалось место для других букв. Иными
  // словами, это максимальное количество
  // нечётных или чётных позиций в строке
  // длины "n", куда можно вставлять
  // один и тот же символ без соседства двух
  // одинаковых.
  //
  // Таким образом Math.ceil(n / 2)
  // показывает, сколько раз можно безопасно
  // вставить один и тот же символ, чередуя
  // его через одну позицию. Если самый
  // частый символ встречается больше этого
  // числа, гарантированно найдутся два
  // соседних вхождения, и переставить
  // строку без одинаковых рядом не получится.
  //
  // Если условие не соблюдается, значит буква
  // встречается слишком часто, и корректная
  // перестановка невозможна - возвращаем
  // пустую стоку
  if (maxFreq > Math.ceil(n / 2)) {
    return '';
  }

  // Преобразуем индекс наиболее частой буквы
  // обратно в символ.
  //
  // Пример:
  // Для maxNdx = 0 получаем 'a'.
  const maxChar = String.fromCharCode(maxNdx + 'a'.charCodeAt(0));

  // Создаём пустой массив длиной n для заполнения
  // переставленными символами.
  //
  // Пример: 
  // для n = 5
  // result = [ , , , , ]
  const result = new Array(n);

  // Инициализируем указатель i для заполнения
  // чётных позиций.
  //
  // Начинаем с нулевого индекса (чётный шаг),
  // чтобы размещать наиболее частую букву
  // через один, уменьшая шанс соседства
  // одинаковых символов.
  let i = 0;

  // Сначала размещаем все экземпляры наиболее
  // частой буквы maxChar на чётных позициях
  // и уменьшаем частоту вхождения этой буквы.
  //
  // Пример:
  // для maxChar = 'a'
  // после этого цикла
  // result = ['a', , 'a', , 'a']
  // и charFreq[0] = 0.
  while (charFreq[maxNdx]) {

    // Вставляем maxChar в текущую позицию.
    result[i] = maxChar;

    // Уменьшаем частоту вхождения этой буквы.
    charFreq[maxNdx]--;

    // Переходим к следующей чётной позиции.
    i += 2;
  }

  // Затем проходим по всем остальным буквам
  // и заполняем ими оставшиеся позиции
  for (let j = 0; j < 26; j++) {

    // Пока есть экземпляры буквы с индексом j,
    // размещаем их в свободных позициях.
    while (charFreq[j]) {

      // Если вышли за границы массива
      // (i >= n), переключаемся на первую
      // нечётную позицию (1) и продолжаем
      // заполнять нечетные позиции.
      //
      // В нашем примере i в конце цикла
      // заполнения 'a' равно 6 ≥ 5, 
      // значит i = 1, и мы начнём
      // заполнять позиции 1, 3, 5... 
      if (i >= n) i = 1;

      // Преобразуем j обратно в символ и
      // ставим в result[i].
      //
      // Пример:
      // При j = 1: 1 → 'b' result[1] = 'b'
      // при j = 2: 3 → 'c' result[3] = 'c'
      result[i] = String.fromCharCode(j + 'a'.charCodeAt(0));

      // Уменьшаем частоту вхождения этой буквы.
      charFreq[j]--;

      // Переходим через одну позицию,
      //
      // Пример:
      // 6 → 1 → 3 → 5
      i += 2;

      // Пример:
      //
      // В начале цикла:
      // result = ['a', , 'a', , 'a']
      //
      // Шаг 1: result = [ 'a', 'b', 'a',  , 'a' ]
      // (поместили 'b' в ячейку 1, i перешли с 6→1→3)
      //
      // Шаг 2: result = [ 'a', 'b', 'a', 'c', 'a' ]
      // (поместили 'c' в ячейку 3, i стало 3→5)
    }
  }

  // Соединяем элементы массива в строку
  // и возвращаем результат.
  //
  // Пример:
  // для result = ['a','b','a','c','a']
  // получаем и возвращаем строку 'abaca'
  return result.join('');
}
