/**
 * @param {number} n
 * @param {number} x
 * @return {number}
 * 
 * minEnd принимает два числовых параметра
 * и возвращает число. Она дополняет младшие
 * нулевые биты числа x единицами в тех
 * позициях, где в числе (n - 1) стоят
 * единицы, причём эти единицы из (n - 1)
 * сопоставляются последовательно только с
 * теми позициями в x, которые изначально
 * равны нулю.
 * 
 * Возвращаемое значение — обычный Number,
 * полученный из внутреннего BigInt
 * результата.
 * 
 * Параметры:
 * - n — целое число. Во внутренней логике
 *   используется значение n - 1 и приводится
 *   к BigInt для побитовой обработки.
 * - x — целое число. Приводится к BigInt и
 *   служит исходным битовым набором, в
 *   который могут быть установлены
 *   дополнительные биты.
 */
function minEnd(n, x) {

  // Уменьшаем n на 1 и приводим результат
  // к BigInt.
  //
  // Причины:
  // исходная логика ориентирована на
  // проверку битов числа n-1. BigInt нужен
  // для корректной побитовой арифметики
  // при больших значениях и для
  // согласованности с дальнейшими BigInt
  // операциями.
  //
  // Пример:
  // если n = 3, то n - 1 = 2,
  // и после этой строки n = 2n (BigInt).
  n = BigInt(n - 1);

  // Инициализируем переменную result как
  // BigInt от x.
  //
  // Это рабочая копия x, в которой мы
  // будем устанавливать (включать)
  // дополнительные биты через побитовые
  // операции.
  //
  // Это нужно, чтобы побитовые операции
  // (AND, OR, сдвиги) выполнялись в типе
  // BigInt.
  //
  // Пример:
  // если x = 4,
  // то result = 4n
  // (т.е. битовое представление 100).
  let result = BigInt(x);

  // Маска i_x = 1n.
  //
  // Будет использоваться для тестирования
  // конкретного бита в result и для
  // установки этого бита через OR.
  //
  // Маска проходит по битовым позициям
  // результата слева направо по
  // возрастанию значимости
  // (младший бит сначала).
  //
  // i_x указывает на позицию, которую мы
  // сейчас рассматриваем в result.
  let i_x = 1n;

  // Маска i_n = 1n.
  //
  // Будет использоваться для перебора
  // битов (n) синхронно со смещением i_x,
  // но сдвигается только тогда, когда мы
  // встретили в result нулевой бит.
  //
  // i_n указывает на позицию, которую мы
  // сейчас рассматриваем в (n - 1).
  let i_n = 1n;

  // Главный цикл: выполняем пока i_n <= n.
  //
  // Поскольку n уже уменьшено на 1 ранее,
  // условие соответствует перебору первых
  // n бит (оригинального значения). 
  //
  // Важно:
  // Условие сравнивается в BigInt, поэтому
  // цикл корректно ограничен битовой
  // длиной n.
  while (i_n <= n) {

    // Проверяем, установлен ли текущий
    // бит в result:
    //
    // (i_x & result) === 0n означает,
    // что в result на позиции
    // i_x стоит 0.
    //
    // Выражение (i_x & result) даёт 0n,
    // если соответствующий бит
    // результата не установлен.
    //
    // Если бит в result уже равен 1, то
    // нам не нужно смотреть на
    // соответствующий бит в n, мы просто
    // продвигаем i_x.
    if ((i_x & result) === 0n) {

      // Если текущий бит в result
      // равен 0, проверяем
      // соответствующий бит в n
      // (n = n-1 после приведения выше).
      //
      // Условие (i_n & n) !== 0n
      // истинно тогда, когда в n на
      // позиции i_n стоит 1.
      //
      // Логика:
      // только если n в этой позиции
      // имеет 1, мы разрешаем
      // установить этот бит в result.
      if ((i_n & n) !== 0n) {

        // Устанавливаем бит в result
        // через побитовое ИЛИ с
        // маской i_x.
        //
        // Это превращает нулевой бит
        // в result в единицу на
        // текущей позиции i_x.
        result = result | i_x;
      }

      // Сдвигаем маску i_n влево,
      // чтобы перейти к следующему биту
      // в n.
      //
      // Сдвиг происходит только когда
      // мы встретили нулевой бит в
      // result, поэтому проход по битам
      // n синхронизирован с
      // рассмотрением нулевых битов
      // result.
      i_n = i_n << 1n;
    }

    // Всегда сдвигаем маску i_x влево,
    // чтобы перейти к следующему биту
    // в result.
    //
    // Таким образом i_x проходит
    // последовательно по всем битовым
    // позициям (младший → старшие).
    i_x = i_x << 1n;
  }

  // Пример работы цикла для n = 3, x = 4:
  // 
  // ---
  //
  // Исходные преобразования перед циклом:
  //
  // - n = BigInt(3 - 1) = 2n.
  // - result = BigInt(4) = 4n. (двоичный вид 100)
  // - i_x = 1n. (двоичный вид 001)
  // - i_n = 1n. (двоичный вид 001)
  // 
  // ---
  //
  // Шаг 1 — вход в while (i_n <= n):
  // 1n <= 2n → true  
  //
  // - Текущее состояние:
  //   - result = 4n (100)
  //   - i_x = 1n (001)
  //   - i_n = 1n (001)
  // - Выражение (i_x & result) === 0n:
  //   - 001 & 100 = 000 → условие true
  //     (бит в result на позиции i_x равен 0)
  // - Вложенное условие (i_n & n) !== 0n:
  //   - 001 & 010 = 000 → условие false
  //     (в n на позиции i_n стоит 0)
  // - Действия внутри ветки:
  //   - Так как (i_n & n) === 0n,
  //     result не меняется.
  //   - Выполняется i_n = i_n << 1n
  //     → i_n становится 2n (010).
  // - Действие после ветки:
  //   - Выполняется i_x = i_x << 1n
  //     → i_x становится 2n (010).
  // - Итог после шага 1:
  //   - result = 4n (100)
  //   - i_x = 2n (010)
  //   - i_n = 2n (010)
  // 
  // ---
  //
  // Шаг 2 — проверка while:
  // 2n <= 2n → true  
  //
  // - Текущее состояние:
  //   - result = 4n (100)
  //   - i_x = 2n (010)
  //   - i_n = 2n (010)
  // - Выражение (i_x & result) === 0n:
  //   - 010 & 100 = 000 → условие true
  //     (бит в result на позиции i_x равен 0)
  // - Вложенное условие (i_n & n) !== 0n:
  //   - 010 & 010 = 010 → условие true
  //     (в n на позиции i_n стоит 1)
  // - Действия внутри ветки:
  //   - Выполняется
  //     result = result | i_x → 100 | 010 = 110
  //     → result = 6n.
  //   - Выполняется i_n = i_n << 1n
  //     → i_n становится 4n (100).
  // - Действие после ветки:
  //   - Выполняется i_x = i_x << 1n
  //     → i_x становится 4n (100).
  // - Итог после шага 2:
  //   - result = 6n (110)
  //   - i_x = 4n (100)
  //   - i_n = 4n (100)
  // 
  // ---
  //
  // Шаг 3 — проверка while:
  // 4n <= 2n → false → цикл завершается
  // 
  // ---
  //
  // Финал:
  // - result = 6n (110)
  //   → возвращается Number(result) = 6

  // Преобразуем итоговый BigInt result
  // обратно в Number и возвращаем.
  //
  // Замечание:
  // Если result превышает допустимый
  // диапазон Number (более 2^53-1),
  // преобразование может потерять
  // точность.
  //
  // В исходной логике ожидается работа
  // в пределах безопасного диапазона
  // Number либо явное использование
  // BigInt во внешнем коде.
  return Number(result);
}
