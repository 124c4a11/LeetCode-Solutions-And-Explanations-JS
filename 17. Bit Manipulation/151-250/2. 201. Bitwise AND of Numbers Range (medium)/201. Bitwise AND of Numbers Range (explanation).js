/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 * 
 * Функция вычисляет побитовое И всех целых чисел
 * в диапазоне от left до right включительно и
 * возвращает этот результат.
 * 
 * Параметры
 * - left — целое число, нижняя граница диапазона.  
 * - right — целое число, верхняя граница диапазона.
 */
function rangeBitwiseAnd(left, right) {

  // Запускаем цикл while, который выполняется
  // до тех пор, пока значение left строго меньше
  // right.
  //
  // Цель цикла — последовательно убирать
  // единичные биты из right, пока left и right не
  // станут равны.
  //
  // Когда left >= right, найден общий битовый
  // префикс всех чисел в интервале и можно
  // вернуть результат.
  while (left < right) {

    // Операция right - 1 уменьшает right на 1.
    //
    // Выражение right & (right - 1) очищает
    // самый младший установленный бит в
    // бинарном представлении right.
    //
    // Присваивание right &= right - 1
    // эквивалентно right = right & (right - 1).
    //
    // Идея:
    // Последовательно удаляя младшие единичные
    // биты у right, мы сдвигаем его к общему
    // префиксу с left. В какой-то момент right
    // станет равен left или меньше, и цикл
    // остановится.
    //
    // Это быстрее, чем поэлементный подсчёт AND
    // для каждого числа в диапазоне, особенно
    // при больших промежутках.
    right &= right - 1;
  }

  // Пример работы цикла для left = 5, right = 7
  // 
  //
  // Исходные значения
  //
  // - left = 5 → двоично 101 
  // - right = 7 → двоично 111
  // 
  // --- 
  // 
  // Итерация 1
  //
  // - Условие цикла: 5 < 7 — true.  
  // - Вычисляем right - 1: 
  //     7 - 1 = 6 → двоично 110
  // - Выполняем right &= right - 1:
  //     111 & 110 = 110 
  // - Новый right = 6 → двоично 110
  // 
  // ---
  //
  // Итерация 2
  //
  // - Условие цикла: 5 < 6 — true.  
  // - Вычисляем right - 1:
  //     6 - 1 = 5 → двоично 101
  // - Выполняем right &= right - 1:
  //     110 & 101 = 100
  // - Новый right = 4 → двоично 100
  // 
  // ---
  //
  // Итерация 3
  //
  // - Условие цикла: 5 < 4 — false.  
  // - Цикл завершается,
  //   итоговое right = 4 → двоично 100
  // 
  // ---
  // 
  // Итог:
  //
  // В каждой итерации операция
  // right &= right - 1 сбрасывает
  // наименее значимый единичный бит right.
  //
  // Последовательность значений right:
  // 7 (111) → 6 (110) → 4 (100)
  //
  // Финальный результат функции для
  // диапазона [5,7] равен 4.

  // Возвращаем текущее значение right.
  // 
  // После завершения цикла right содержит
  // битовый AND всех чисел в исходном
  // диапазоне [left, right], так как все
  // различия в младших битах были удалены.
  //
  // Если left и right изначально равны,
  // цикл не выполняется и возвращается
  // исходное значение.
  return right;
}
