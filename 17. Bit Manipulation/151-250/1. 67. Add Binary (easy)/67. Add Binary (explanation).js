/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 * 
 * addBinary складывает два двоичных числа,
 * представленных строками, и возвращает их
 * сумму в виде двоичной строки.
 * 
 * Параметры:
 * - a — строка, содержащая двоичное число
 *   (набор символов '0' и '1').
 * - b — строка, содержащая двоичное число
 *   (набор символов '0' и '1').
 *
 * Пример для:
 *   a = '11'
 *   b = '11'
 * Результат:
 *   '110'    
 */
function addBinary(a, b) {

  // Создаём строку с префиксом 0b из
  // значения a и передаём её в конструктор
  // BigInt для получения большого целого.
  //
  // Конструкция 0b${a} превращает строку a
  // в текст вида '0b101', который понятен
  // парсеру BigInt.
  //
  // Конкатенация 0b${a} превращает "11" в
  // "0b11", что интерпретируется как
  // двоичное число, равное десятичному 3.
  //
  // Пример:
  //   для a = "11"
  //   результат BigInt(`0b${a}`) будет 3n.
  //
  // ---
  //
  // Причина использования BigInt
  // 
  // - Предотвращение потери точности при
  //   больших числах.
  //   BigInt обеспечивает целочисленную
  //   арифметику произвольной точности,
  //   в отличие от типа Number, который
  //   теряет точность при значениях выше
  //   2^53 − 1.  
  //
  // - Точное сложение двоичных строк любой
  //   длины.
  //   Преобразование двоичной строки в
  //   BigInt позволяет корректно складывать
  //   очень длинные двоичные числа без
  //   переполнения и ошибок округления.  
  //
  // - Удобный парсинг бинарного литерала.
  //   Передача строки с префиксом "0b" в
  //   конструктор BigInt парсит двоичное
  //   представление напрямую и возвращает
  //   целое значение типа BigInt.  
  //
  // - Единый тип для арифметики.
  //   После преобразования обоих операндов
  //   в BigInt операция '+' выполняется в
  //   рамках одного числового типа
  //   произвольной точности, результат
  //   остаётся BigInt и может быть точно
  //   преобразован обратно в строку с
  //   основанием 2.  
  //
  // - Отсутствие побочных эффектов
  //   связанного с плавающей точкой.
  //   Нет риска получения дробных значений
  //   или неожиданных округлений, потому
  //   что BigInt — целый тип данных.  
  //
  // - Явное поведение при неверном вводе.
  //   Если входная строка содержит
  //   недопустимые символы, BigInt бросит
  //   исключение, что делает ошибку явной
  //   и простую для отлавливания.
  // 
  // ---
  // 
  // Альтернатива и когда можно не
  // использовать BigInt
  // 
  // - Если гарантированно маленькие числа
  //   (меньше 2^53 − 1), можно использовать
  //   Number и parseInt(a, 2), но это
  //   ограничено безопасным диапазоном
  //   целых значений.  
  //
  // - Если нужна поддержка отрицательных
  //   двоичных входов или особой валидации,
  //   требуется дополнительная обработка
  //   перед передачей в BigInt.
  const bigIntA = BigInt(`0b${a}`);

  // Аналогично для b:
  // Формируем литерал двоичного числа
  // с префиксом 0b и создаём BigInt.
  //
  // Пример:
  //   для b = "11"
  //   результат BigInt(`0b${b}`) будет 3n.
  const bigIntB = BigInt(`0b${b}`);

  // Складываем два значения типа BigInt.
  // Операция выполняется как
  // арифметическое сложение целых.
  //
  // Поскольку bigIntA и bigIntB — BigInt,
  // результат sum также будет BigInt.
  //
  // Пример:
  //   3n + 3n = 6n.
  const sum = bigIntA + bigIntB;

  // Преобразуем BigInt sum в строковое
  // представление в базе 2, то есть в
  // двоичную строку.
  //
  // Метод toString(2) возвращает строку
  // без префикса '0b', содержащую только
  // '0' и '1'.
  //
  // Пример:
  //   6n.toString(2) даст "110".
  return sum.toString(2);
}
