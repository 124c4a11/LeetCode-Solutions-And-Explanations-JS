/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 * 
 * Функция находит наибольшую строку-делитель (GCD string)
 * для двух входных строк — максимально длинный префикс,
 * который при повторении некоторого числа раз точно
 * воспроизводит обе строки. Если такой строки нет, функция
 * возвращает пустую строку.
 * 
 * Параметры: 
 * - str1 — первая строка
 * - str2 — вторая строка
 * 
 * Возвращаемое значение и логика.
 * Возвращает строку — общий делитель длиной равной НОД
 * длин str1 и str2, если обе строки состоят из повторений
 * этого префикса. Иначе возвращает пустую строку. Алгоритм
 * вычисляет НОД длин, затем проверяет, что каждая позиция
 * в str1 и в str2 совпадает с соответствующей позицией в
 * префиксе длиной этого НОД, и если все проверки проходят,
 * возвращает префикс str1.slice(0, gcdLength).
 * 
 * Пример:
 *   Для: str1 = "ABABAB", str2 = "ABAB"
 *   Возвращает: str1.slice(0, 2) → "AB
 */
function gcdOfStrings(str1, str2) {

  // Объявление вспомогательной функции gcd для
  // вычисления наибольшего общего делителя (НОД) двух
  // целых чисел.
  //
  // Реализована рекурсивно по алгоритму Евклида:
  // Если второе число равно 0, возвращаем первое,
  // иначе рекурсивно вызываем gcd(b, a % b).
  //
  // В контексте строк эта функция будет применена к
  // длинам строк, чтобы найти длину потенциального
  // общеского делителя строки.
  //
  // Пример:
  // gcd(6, 4) → gcd(4, 2) → gcd(2, 0) → 2.
  //
  // ---
  //
  // Суть алгоритма Евклида
  //
  // Алгоритм Евклида вычисляет наибольший общий
  // делитель (НОД) двух целых чисел, последовательно
  // заменяя большую из двух величин на остаток от
  // деления большей на меньшую до тех пор, пока
  // остаток не станет равен нулю. Тогда НОД равен
  // оставшемуся ненулевому числу.
  // 
  // Основная идея:
  // Если a и b — два целых числа и r — остаток от
  // деления a на b, то любые общие делители a и b
  // также делят r, поэтому НОД(a, b) = НОД(b, r).
  // Повторяя это сокращение, мы придём к паре (d, 0),
  // где d — искомый НОД.
  // 
  // Пошаговая процедура итеративная:
  // 1. Принять два числа a и b, где a ≥ b ≥ 0.  
  // 2. Вычислить r = a % b.  
  // 3. Если r = 0, вернуть b как НОД.  
  // 4. Подставить a = b, b = r и вернуться к шагу 2.  
  // Эта версия — наиболе распространённая и
  // эффективная для целых чисел.
  // 
  // Рекурсивная формулировка:
  // Функция gcd(a, b) возвращает a, если b = 0,
  // иначе возвращает gcd(b, a mod b).
  // Рекурсивная запись компактна и эквивалентна
  // итеративной процедуре.
  // 
  // Пример:
  // Вычислим НОД(48, 18) итеративно:
  // 48 % 18 = 12 → пара (18,12);
  // 18 % 12 =  6 → пара (12,6);
  // 12 % 6  =  0 → НОД = 6.
  // 
  // Сложность и применение:
  // Алгоритм работает за O(log min(a, b)) шагов в
  // среднем и на практике очень быстрый. Он лежит
  // в основе многих алгоритмов теории чисел и
  // криптографии и обосновывает операции с целыми
  // числами в математических библиотеках.
  const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));

  // Вычисление gcdLength как НОД длин str1 и str2.
  //
  // Это максимальная возможная длина строки-делителя,
  // потому что любой общий делитель строк должен
  // иметь длину, делящую длины обеих строк.
  //
  // Идея:
  // Если строки состоят из повторов некоторой
  // подстроки t, то длина t должна делить длины обеих
  // строк, поэтому её длина — один из делителей
  // НОД(str1.length, str2.length), и лучший кандидат
  // — сам НОД.
  //
  // Пример:
  // для str1 = "ABABAB" (длина 6)
  // и str2 = "ABAB" (длина 4)
  // gcdLength = gcd(6, 4) = 2.
  const gcdLength = gcd(str1.length, str2.length);

  // Цикл перебирает все индексы первой строки str1
  // от 0 до str1.length - 1.
  //
  // Цель — убедиться, что первая строка
  // действительно состоит из повторений префикса
  // длины gcdLength.
  //
  // Идея:
  // Если str1 действительно состоит из повторов
  // подстроки длины gcdLength, то символ в позиции
  // i должен совпадать с символом в позиции
  // i % gcdLength (т.е. симметрично повторяющейся
  // части).
  //
  // Пример:
  // gcdLength = 2, str1 = "ABABAB" → ожидаем, что
  // индексы 0,2,4 равны символу str1[0];
  //         1,3,5 равны str1[1].
  for (let i = 0; i < str1.length; i++) {

    // Сравниваем символ str1[i] с символом в
    // пределах предполагаемого базового блока
    // — str1[i % gcdLength].
    //
    // Использование i % gcdLength реализует
    // циклическую проверку: для i >= gcdLength
    // мы сверяем с соответствующим символом
    // внутри блока длины gcdLength.
    //
    // Если хоть один символ не совпадает,
    // значит str1 не является повторением
    // префикса длины gcdLength, и общего
    // строкового делителя такой длины нет.
    //
    // Пример для str1 = "ABABAB" и gcdLength = 2:
    // проверяются пары
    //
    // i=0: str1[0] === str1[0 % 2] → 'A' === 'A'
    // i=1: str1[1] === str1[1 % 2] → 'B' === 'B'
    // i=2: str1[2] === str1[0] → 'A' === 'A'
    // i=3: str1[3] === str1[1] → 'B' === 'B'
    // i=4: str1[4] === str1[0] → 'A' === 'A'
    // i=5: str1[5] === str1[1] → 'B' === 'B'
    //
    // все сравнения проходят, цикл продолжается.
    if (str1[i] !== str1[i % gcdLength]) return '';
  }

  // Второй цикл проверяет вторую строку str2 по
  // тому же базовому блоку (который берётся из
  // начала str1).
  //
  // Это необходимо, потому что даже если str1
  // состоит из повторений префикса длины
  // gcdLength, str2 тоже должна состоять из
  // повторений того же префикса, чтобы он был
  // общим делителем.
  for (let i = 0; i < str2.length; i++) {

    // Сравниваем символ str2[i] с символом
    // базового блока str1[i % gcdLength].
    //
    // Если хоть одна позиция не совпадает,
    // значит нет общего строкового делителя
    // длины gcdLength.
    //
    // Пример для str2 = "ABAB" и gcdLength = 2:
    //
    // i=0: str2[0] === str1[0] → 'A' === 'A'
    // i=1: str2[1] === str1[1] → 'B' === 'B'
    // i=2: str2[2] === str1[0] → 'A' === 'A'
    // i=3: str2[3] === str1[1] → 'B' === 'B'
    //
    // все сравнения проходят, цикл продолжается.
    if (str2[i] !== str1[i % gcdLength]) return '';
  }

  // Если обе проверки прошли успешно, возвращаем
  // префикс str1 длиной gcdLength.
  //
  // Этот префикс является наибольшей строкой,
  // повторяемой и в str1, и в str2.
  //
  // Пример:
  // str1 = "ABABAB", str2 = "ABAB", gcdLength = 2,
  // возвращаем str1.slice(0, 2) → "AB"
  return str1.slice(0, gcdLength);
}
