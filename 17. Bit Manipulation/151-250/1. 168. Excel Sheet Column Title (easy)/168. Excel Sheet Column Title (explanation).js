/**
 * @param {number} columnNumber
 * @return {string}
 * 
 * convertToTitle принимает один параметр:
 * columnNumber — целое положительное число,
 * представляющее порядковый номер столбца
 * в таблице Excel, начинающийся с 1
 * и преобразует номер столбца в строковую
 * метку в формате Excel, где 1 → A, 26 → Z,
 * 27 → AA и так далее.
 * 
 * Возвращает строку с соответствующим
 * буквенным заголовком.
 * 
 * Пример:
 *   Для: columnNumber = 28
 *   Возвращает: "AB"
 */
function convertToTitle(columnNumber) {

  // Инициализация пустого массива result.
  //
  // В него будут добавляться символы столбца
  // по одному, в обратном порядке - младший
  // разряд (правая буква) первым
  const result = [];

  // Цикл выполняется при columnNumber > 0
  // потому что функция последовательно
  // извлекает буквы заголовка от младших
  // разрядов к старшим до тех пор, пока не
  // обработает все разряды числа.
  // - Внутри каждой итерации происходит
  //   уменьшение columnNumber на 1 чтобы
  //   перейти от 1‑основанной системы
  //   заголовков к 0‑основанной индексации
  //   букв (1→0, 26→25) и вычисление
  //   остатка от деления на 26 для
  //   получения текущей буквы.
  //
  // - В Excel столбцы нумеруются с
  //   1: 1 → A, 2 → B, …, 26 → Z, 27 → AA.
  //   Математически это похоже на запись
  //   числа в «системе счисления с
  //   основанием 26», но с тем отличием,
  //   что разряды здесь 1..26, а не
  //   привычные 0..25. Уменьшая
  //   columnNumber на 1 перед взятием
  //   остатка, мы переводим эту
  //   1‑индексацию в 0‑индексацию, что
  //   позволяет корректно использовать
  //   операцию остатка и отображать
  //   0→A, 25→Z.
  //
  // - После добавления буквы columnNumber
  //   делится на 26 с округлением вниз, что
  //   с каждым шагом уменьшает значение и в
  //   конечном счёте приводит его к нулю.  
  //
  // - Когда columnNumber становится равным
  //   нулю значит все разряды обработаны и
  //   дальнейших букв нет, поэтому цикл
  //   завершает работу.  
  while (columnNumber > 0) {

    // Почему columnNumber-- перед offset
    // - До уменьшения остаток от деления
    //   по модулю 26 для числа 26 вернёт 0,
    //   что соответствует A в 0‑индексной
    //   системе, но для Excel 26 должно
    //   давать Z.  
    //
    // - Уменьшение на 1 смещает весь
    //   диапазон: числа 1..26 превращаются
    //   в 0..25, поэтому остаток
    //   offset = (columnNumber - 1) % 26
    //   прямо даёт индекс буквы в диапазоне
    //   0→A … 25→Z.  
    //
    // - Без этого сдвига границы
    //   «переполнения» разрядов были бы
    //   неверными: 26%26=0 дала бы A вместо
    //   Z, а 27%26=1 дала бы B вместо A
    //   старшего разряда.
    columnNumber--;

    // Вычисляем смещение offset как
    // остаток  от деления columnNumber
    // на 26 (номер буквы в алфавите
    // от 0 до 25)
    const offset = columnNumber % 26;

    // Берём код символа 'A' и прибавляем
    // offset, получая код нужной буквы.
    //
    // Затем преобразуем числовой код в
    // строковый символ и добавляем его в
    // result.
    //
    // Заметьте: добавляем в конец массива,
    // то есть сначала окажутся буквы
    // младших разрядов (правые буквы).
    result.push(String.fromCharCode('A'.charCodeAt(0) + offset));

    // Обновляем columnNumber с помощью
    // целочисленного деления на 26
    // (Math.floor).
    //
    // Это сдвигает число на один разряд
    // в системе основания 26 и позволяет
    // обработать следующий разряд в
    // следующей итерации.
    columnNumber = Math.floor(columnNumber / 26);
  }

  // Пример работы цикла для
  // columnNumber = 28
  // 
  // Начальное состояние
  // - columnNumber = 28  
  // - result = []
  // 
  // Итерация 1
  // - Выполняется columnNumber--:
  //   columnNumber = 27  
  // - Вычисляется offset = 27 % 26 = 1  
  // - Вычисляется буква:
  //   String.fromCharCode('A'.charCodeAt(0) + 1) = "B"  
  // - Выполняется result.push(...): 
  //   result = ["B"]  
  // - Выполняется columnNumber = Math.floor(27 / 26) = 1
  // 
  // Итерация 2
  // - Выполняется columnNumber--: 
  //   columnNumber = 0  
  // - Вычисляется offset = 0 % 26 = 0  
  // - Вычисляется буква:
  //   String.fromCharCode('A'.charCodeAt(0) + 0) = "A"  
  // - Выполняется result.push(...):
  //   result = ["B", "A"]  
  // - Выполняется columnNumber = Math.floor(0 / 26) = 0
  // 
  // После цикла
  // - Цикл завершается, так как columnNumber = 0  
  // - Текущий массив result (в порядке добавления):
  //   ["B", "A"]  
  // - После reverse() и join('') получаем финальную
  //   строку: "AB"

  // После цикла result содержит буквы в
  // обратном порядке (младший разряд первый),
  // поэтому разворачиваем массив, объединяем
  // элементы в строку и возвращаем результат.
  return result.reverse().join('');
}
