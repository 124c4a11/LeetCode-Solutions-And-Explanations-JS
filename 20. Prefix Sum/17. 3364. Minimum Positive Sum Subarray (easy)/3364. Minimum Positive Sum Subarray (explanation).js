/**
 * @param {number[]} nums
 * @param {number} l
 * @param {number} r
 * @return {number}
 * 
 * minimumSumSubarray ищет и возвращает минимальную
 * положительную сумму среди всех непрерывных
 * подмассивов массива nums, длина которых
 * находится в диапазоне от l до r включительно.
 * Если подходящих подмассивов не найдено, функция
 * возвращает -1. 
 * 
 * Параметры:
 * - nums — массив целых чисел 
 * 
 * - l — минимальная допустимая длина подмассива
 *   (включительно).
 * 
 * - r — максимальная допустимая длина подмассива
 *   (включительно).
 * 
 * 
 * Пример для:
 *   nums = [3, -2, 1, 4], l = 2, r = 3
 * Результат:
 *   1
 * Пояснение:
 * Подмассивы длины от l = 2 до r = 3, у которых
 * сумма больше 0:
 *   [3, -2] — сумма 1
 *   [1, 4] — сумма 5
 *   [3, -2, 1] — сумма 2
 *   [-2, 1, 4] — сумма 3
 * Из них подмассив [3, -2] имеет наименьшую
 * положительную сумму 1, поэтому ответ равен 1.
 */
function minimumSumSubarray(nums, l, r) {
  const n = nums.length;

  // Инициализирует переменную result значением
  // Infinity.
  // 
  // Это служит маркером "пока не найдено ни одной
  // подходящей суммы".
  //
  // Используем Infinity, чтобы первое реальное 
  // значение было меньше и заменило Infinity
  // 
  // Позже будет использовано для проверки, найден
  // ли хотя бы один допустимый подмассив.
  let result = Infinity;

  // Перебираем все возможные начальные индексы
  // подмассива i от 0 до n - l (включительно).
  // Это предотвращает лишние итерации, когда от
  // текущего i невозможно получить подмассив
  // минимально допустимой длины l.
  //
  // Верхняя граница i <= n - l гарантирует, что
  // от позиции i можно получить подмассив
  // миниально допустимой длины l. 
  // 
  // Для каждого i мы будем накапливать суммы
  // подмассивов, начинающихся в i.
  for (let i = 0; i <= n - l; i++) {

    // Сбрасываем накопленную сумму currSum при
    // переходе к новому началу подмассива i.
    // 
    // currSum будет хранить сумму элементов от
    // i до текущего j.
    let currSum = 0;

    // Внутренний цикл расширяет правую границу
    // подмассива j, начиная с i, что позволяет
    // накопить currSum для текущего подмассива
    // 
    // Верхняя граница Math.min(i + r, n)
    // гарантирует, что длина подмассива не
    // превысит r и что j не выйдет за пределы
    // массива 
    for (let j = i; j < Math.min(i + r, n); j++) {

      // Вычисляем текущую длину подмассива
      // от i до j включительно.
      // 
      // Это значение используется для проверки,
      // достиг ли подмассив минимально допустимой
      // длины l.
      const subarrayLen = j - i + 1;

      // Добавляем текущий элемент nums[j] к
      // накопительной сумме currSum, тем самым
      // currSum всегда содержит сумму элементов
      // подмассива nums[i..j].
      currSum += nums[j];

      // Условие проверяет два момента:
      // 1. currSum > 0 — рассматриваем только
      //    положительные суммы (строго больше
      //    нуля). 
      //
      // 2. l <= subarrayLen — длина текущего
      //    подмассива должна быть не меньше l.
      // Если оба условия выполнены, обновляем
      // result минимальным из текущего result и
      // currSum. Math.min гарантирует, что в
      // result останется наименьшая найденная
      // положительная сумма.
      if (
        currSum > 0
        && l <= subarrayLen
      ) result = Math.min(result, currSum);
    }
  }

  // После перебора всех возможных подмассивов
  // проверяем, изменился ли result.
  // 
  // Если result всё ещё равен Infinity, это
  // означает, что не найдено ни одного подмассива
  // с положительной суммой и длиной в диапазоне
  // [l, r], поэтому возвращаем -1.
  // 
  // В противном случае возвращаем найденную
  // минимальную положительную сумму.
  return result === Infinity ? -1 : result;
}
