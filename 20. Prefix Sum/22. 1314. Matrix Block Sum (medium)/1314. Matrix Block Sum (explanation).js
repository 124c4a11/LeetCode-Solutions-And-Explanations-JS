/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number[][]}
 *
 * matrixBlockSum принимает Вам дана матрица mat размера
 * m x n и целое число k. Cоздает и возвращает новую
 * матрицу result, где каждый элемент result[i][j]
 * представляет собой сумму всех элементов исходной
 * матрицы, находящихся в определённой прямоугольной
 * области, центрированной в позиции (i, j).
 *
 * Для каждой позиции (i, j) в результирующей матрице
 * нужно просуммировать все элементы mat[r][c] исходной
 * матрицы, для которых выполняются условия:
 *  - строка r находится в диапазоне: i - k ≤ r ≤ i + k

 *  - столбец c находится в диапазоне: j - k ≤ c ≤ j + k

 *  - позиция (r, c) допустима (находится в пределах
 *    границ исходной матрицы)
 *
 * Иными словами, для каждой ячейки результирующей
 * матрицы вычисляется сумма всех элементов в
 * прямоугольном блоке, который простирается на k
 * позиций во всех четырёх направлениях (вверх, вниз,
 * влево, вправо) от соответствующей позиции в исходной
 * матрице. Если блок выходит за границы матрицы, в
 * сумму включаются только те части блока, которые лежат
 * внутри матрицы.
 *
 * Например, если k = 1, то для позиции (i, j)
 * суммируются все элементы в блоке 3×3, центрированном
 * в (i, j) (или меньший блок, если позиция близка к
 * краю матрицы).
 *
 *
 * Пример для:
 *   mat = [[1,2,3],[4,5,6],[7,8,9]],
 *   k = 1
 * Результат:
 *   [[12,21,16],[27,45,33],[24,39,28]]
 */
function matrixBlockSum(mat, k) {

  // Определяем количество строк в исходной матрице
  const ROWS = mat.length;

  // Определяем количество столбцов в исходной матрице
  const COLS = mat[0].length;

  // Создаём вспомогательную матрицу префиксных сумм
  // размером (ROWS+1) x (COLS+1)
  //
  // Дополнительная строка и столбец с нулями упрощают
  // вычисления сумм прямоугольников без отдельной
  // обработки границ
  const prefixSums = Array.from(
    { length: ROWS + 1 },
    () => Array(COLS + 1).fill(0)
  );

  // Проходим по всем строкам исходной матрицы для
  // заполнения префиксных сумм
  for (let r = 0; r < ROWS; r++) {

    // Проходим по всем столбцам текущей строки
    for (let c = 0; c < COLS; c++) {

      // Вычисляем префиксную сумму для позиции
      // (r+1, c+1) в таблице prefixSums.
      //
      // Формула:
      // Сумма прямоугольника от (0,0) до (r,c)
      // включительно.
      //
      // Используется принцип включения-исключения:
      // Берем суммы сверху и слева, вычитаем двойной
      // пересекающийся верхний левый прямоугольник и
      // добавляем текущую ячейку.
      prefixSums[r + 1][c + 1] =

        // prefixSums[r][c + 1] — сумма всех элементов
        // в прямоугольнике выше текущей строки, до
        // столбца c включительно
        prefixSums[r][c + 1]

        // prefixSums[r + 1][c] — сумма всех элементов
        // в прямоугольнике слева от текущего столбца,
        // до строки r включительно
        + prefixSums[r + 1][c]

        // - prefixSums[r][c] — вычитаем область,
        // которая была учтена дважды в предыдущих
        // двух слагаемых (верхний левый
        // прямоугольник)
        - prefixSums[r][c]

        // + mat[r][c] — добавляем значение текущей
        // ячейки исходной матрицы, чтобы получить
        // полную сумму до (r,c)
        + mat[r][c];
    }
  }

  // Создаём результирующую матрицу result того же
  // размера, что и исходная, и заполняем нулями
  //
  // В ней будут храниться суммы блоков радиуса k
  // для каждой позиции
  const result = Array.from(
    { length: ROWS },
    () => Array(COLS).fill(0)
  );

  // Проходим по каждой строке исходной матрицы,
  // чтобы вычислить сумму соответствующего блока
  for (let r = 0; r < ROWS; r++) {

    // Проходим по всем столбцам текущей строки
    for (let c = 0; c < COLS; c++) {

      // Вычисляем индекс верхней границы блока:
      // r - k, но не меньше 0
      //
      // Math.max гарантирует, что блок не выйдет
      // за верхнюю границу матрицы
      const topRow = Math.max(r - k, 0);

      // Вычисляем индекс левой границы блока:
      // c - k, но не меньше 0
      //
      // Math.max гарантирует, что блок не выйдет
      // за левую границу матрицы
      const leftCol = Math.max(c - k, 0);

      // Вычисляем индекс нижней границы блока:
      // r + k, но не больше ROWS - 1
      //
      // Math.min гарантирует, что блок не выйдет
      // за нижнюю границу матрицы
      const bottomRow = Math.min(ROWS - 1, r + k);

      // Вычисляем индекс правой границы блока:
      // c + k, но не больше COLS - 1
      //
      // Math.min гарантирует, что блок не выйдет
      // за правую границу матрицы
      const rightCol = Math.min(COLS - 1, c + k);

      // Используем префиксные суммы для получения
      // суммы всех элементов в прямоугольнике с
      // вершинами (topRow,leftCol) и
      // (bottomRow,rightCol) за O(1)
      //
      // В префиксной матрице индексы сдвинуты
      // на +1, поэтому добавляем 1 к bottomRow и
      // rightCol
      result[r][c] =

        // полная сумма от начала до
        // правого-нижнего угла интересующего
        // прямоугольника
        prefixSums[bottomRow + 1][rightCol + 1]

        // вычитаем область выше прямоугольника
        // (включая строку topRow-1)
        - prefixSums[topRow][rightCol + 1]

        // вычитаем область слева от
        // прямоугольника (включая столбец
        // leftCol-1)
        - prefixSums[bottomRow + 1][leftCol]

        // добавляем обратно область, вычтенную
        // дважды (верхний левый
        // перекрывающийся прямоугольник), по
        // правилу включения-исключения
        + prefixSums[topRow][leftCol];
    }
  }

  // Возвращаем результирующую матрицу, где в
  // каждой ячейке хранится сумма элементов
  // блока радиуса k вокруг соответствующей
  // ячейки исходной матрицы
  return result;
}
