/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 *
 * numberOfSubarrays принимает массив целых чисел nums и
 * целое число k и возвращает количество "хороших"
 * непрерывных подмассивов.
 *
 * Непрерывный подмассив называется "хорошим", если в нём
 * ровно k нечётных чисел.
 *
 *
 * Пример для:
 *   nums = [1,1,2,1,1],
 *   k = 3
 * Вывод:
 *   2
 * Пояснение:
 *   Единственные подмассивы с ровно 3 нечётными числами
 *   — [1,1,2,1] и [1,2,1,1].
 */
function numberOfSubarrays(nums, k) {
  const n = nums.length;

  // Создаём типизированный массив Int32Array длиной n + 1
  // для хранения количества префиксов с определённым
  // числом нечётных.
  //
  // - Индекс - число нечётных в префиксе.
  //
  // - Значение - количество префиксов с таким числом
  //   нечётных.
  //
  // Почему n+1:
  // Возможные значения счётчика нечётных в префиксе
  // варьируются от 0 до n включительно. Чтобы иметь
  // возможность индексировать prefixOddCnts[currOddCnt]
  // для всех возможных значений currOddCnt от 0 до n,
  // массив частот должен иметь длину не меньше n + 1.
  // Иначе при currOddCnt === n попытка обратиться к
  // prefixOddCnts[n] выйдет за границы.
  //
  // Пример для:
  //   nums = [1,1,2,1,1],
  //   k = 3
  // prefixOddCnts = [1,1,2,1,1,0]
  const prefixOddCnts = new Int32Array(n + 1);

  // Инициализируем счётчик префиксов:
  //
  // Пустой префикс (до начала массива) содержит 0
  // нечетных и встречается один раз.
  //
  // Это важно, чтобы корректно учитывать подмассивы,
  // начинающиеся с индекса 0, когда currOddCnt
  // достигает k.
  prefixOddCnts[0] = 1;

  // Переменная для накопления итогового количества
  // подмассивов с ровно k нечетными числами.
  let result = 0;

  // Текущий счётчик нечетных чисел в префиксе при
  // итерации по массиву.
  //
  // currOddCnt отражает количество нечетных элементов в
  // префиксе, заканчивающемся на текущем элементе.
  //
  // Начинаем с 0, затем при обходе массива увеличиваем на
  // 1 для каждого нечётного элемента.
  let currOddCnt = 0;

  // Итерация по каждому элементу массива nums
  for (const num of nums) {

    // Определяем, нечётное ли текущее число:
    //
    // Выражение (num & 1) возвращает 1 для нечётных и 0
    // для чётных.
    //
    // Это битовая операция быстрее, чем num % 2, и
    // корректно работает для целых чисел в JS.
    //
    // Увеличиваем currOddCnt на 1 только если число
    // нечётное.
    currOddCnt += num & 1;

    // Если в текущем префиксе накопилось как минимум k
    // нечётных, то существуют префиксы, которые
    // расположены левее и имеют ровно
    // currOddCnt - k нечётных.
    //
    // Каждый такой префикс образует с текущим суффиксом
    // подмассив с ровно k нечётными.
    if (currOddCnt >= k) {

      // Добавляем к результату количество префиксов с
      // (currOddCnt - k) нечётными.
      //
      // prefixOddCnts хранит число префиксов,
      // встреченных ранее, с конкретным (i) количеством
      // нечётных.
      //
      // Таким образом, суммируя
      // prefixOddCnts[currOddCnt - k], мы учитываем все
      // подмассивы, которые заканчиваются в текущей
      // позиции и содержат ровно k нечётных.
      result += prefixOddCnts[currOddCnt - k];
    }

    // Фиксируем, что встретился ещё один префикс с
    // текущим количеством нечётных currOddCnt:
    //
    // Увеличиваем соответствующий счётчик в
    // prefixOddCnts, чтобы будущие элементы могли
    // использовать этот префикс.
    //
    // Это обновление должно происходить после учёта
    // возможных подмассивов, чтобы не включать текущую
    // позицию дважды.
    prefixOddCnts[currOddCnt]++;
  }

  // Пример работы цикла для:
  // - nums = [1,1,2,1,1]
  //
  // - k = 3
  //
  //
  // Исходные значения перед входом в цикл
  // - prefixOddCnts = [1,0,0,0,0,0]
  //   (индекс 0 = 1 означает один пустой префикс с 0
  //   нечетных)
  //
  // - result = 0
  //
  // - currOddCnt = 0
  //
  // ---
  //
  // Итерация 1: num = 1 (первый элемент):
  //
  // - currOddCnt += num & 1
  //   → num & 1 = 1
  //   → currOddCnt = 0 + 1 = 1
  //
  // - Условие currOddCnt >= k
  //   → 1 >= 3 — ложь
  //   → result = 0 (не меняется).
  //
  // - prefixOddCnts[currOddCnt]++
  //   → prefixOddCnts[1] = 1
  //
  // - Состояние после итерации:
  //   - prefixOddCnts = [1,1,0,0,0,0]
  //   - result = 0
  //   - currOddCnt = 1
  //
  // - Пояснение:
  //   Префикс, заканчивающийся на этом элементе, содержит
  //   1 нечётное.
  //
  //   Подмассивов с ровно 3 нечётными пока нет.
  //
  // ---
  //
  // Итерация 2: num = 1 (второй элемент):
  //
  // - currOddCnt += num & 1
  //   → 1 & 1 = 1
  //   → currOddCnt = 1 + 1 = 2
  //
  // - Условие currOddCnt >= k
  //   → 2 >= 3 — ложь
  //   → result = 0 (не меняется).
  //
  // - prefixOddCnts[2]++
  //   → prefixOddCnts[2] = 1
  //
  // - Состояние после итерации:
  //   - prefixOddCnts = [1,1,1,0,0,0]
  //   - result = 0
  //   - currOddCnt = 2
  //
  // - Пояснение:
  //   Накоплено 2 нечетных в префиксе
  //
  //   Всё ещё нет подмассивов с ровно 3 нечётными.
  //
  // ---
  //
  // Итерация 3: num = 2 (третий элемент):
  //
  // - currOddCnt += num & 1
  //   → num & 1 = 0
  //   → currOddCnt = 2 + 0 = 2
  //
  // - Условие currOddCnt >= k
  //   → 2 >= 3 — ложь
  //   → result = 0 (не меняется)
  //
  // - prefixOddCnts[2]++
  //   → prefixOddCnts[2] = 2
  //
  // - Состояние после итерации:
  //   - prefixOddCnts = [1,1,2,0,0,0]
  //   - result = 0
  //   - currOddCnt = 2
  //
  // - Пояснение:
  //   Чётный элемент не увеличил счётчик нечётных, но
  //   добавлен ещё один префикс с 2 нечётными.
  //   (это префиксы до индексов 2 и 3).
  //
  // ---
  //
  // Итерация 4: num = 1 (четвёртый элемент):
  //
  // - currOddCnt += num & 1
  //   → currOddCnt = 2 + 1 = 3
  //
  // - Условие currOddCnt >= k
  //   → 3 >= 3 — истина.
  //   - result += prefixOddCnts[currOddCnt - k]
  //     → prefixOddCnts[0] = 1
  //     → result = 0 + 1 = 1.
  //
  //   - Это означает:
  //     Существует 1 префикс с currOddCnt - k = 0
  //     нечётными (пустой префикс), который даёт
  //     подмассив(ы), заканчивающийся в текущем индексе,
  //     с ровно 3 нечётными. Конкретный подмассив:
  //     элементы с индекса 0 по 3 → [1,1,2,1].
  //
  // - prefixOddCnts[3]++
  //   → prefixOddCnts[3] = 1.
  //
  // - Состояние после итерации:
  //   - prefixOddCnts = [1,1,2,1,0,0]
  //   - result = 1
  //   - currOddCnt = 3
  //
  // ---
  //
  // Итерация 5: num = 1 (пятый элемент):
  //
  // - currOddCnt += num & 1
  //   → currOddCnt = 3 + 1 = 4
  //
  // - Условие currOddCnt >= k
  //   → 4 >= 3 — истина.
  //   - result += prefixOddCnts[currOddCnt - k]
  //     → prefixOddCnts[1] = 1,
  //     → result = 1 + 1 = 2.
  //
  //   - Интерпретация:
  //     Есть 1 префикс с currOddCnt - k = 1 нечётными.
  //     Каждая такая позиция начала даёт подмассив с
  //     ровно 3 нечётными, заканчивающийся в текущем
  //     индексе. Конкретный подмассив, соответствующий
  //     этому префиксу: начало после префикса с 1
  //     нечётным (то есть с индекса 1) до текущего
  //     индекса 4 → элементы с индекса 1..4 → [1,2,1,1].
  //
  // - prefixOddCnts[4]++
  //   → prefixOddCnts[4] = 1.
  //
  // - Состояние после итерации:
  //   - prefixOddCnts = [1,1,2,1,1,0]
  //   - result = 2
  //   - currOddCnt = 4
  //
  // ---
  //
  // Итог после завершения цикла:
  //
  // - Окончательный result = 2 — найдено 2 подмассива с
  //   ровно 3 нечётными.
  //
  // - Найденные подмассивы (в явном виде):
  //   1. [1,1,2,1] (индексы 0..3) [1,1,2,1,1]
  //                                ^ ^ ^ ^
  //   2. [1,2,1,1] (индексы 1..4) [1,1,2,1,1]
  //                                  ^ ^ ^ ^

  // Возвращаем итоговое количество подмассивов,
  // содержащих ровно k нечетных чисел.
  return result;
}
