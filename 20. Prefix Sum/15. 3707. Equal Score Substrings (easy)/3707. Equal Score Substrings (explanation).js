/**
 * @param {string} s
 * @return {boolean}
 *
 * scoreBalance принимает строку из строчных латинских
 * букв и проверяет, существует ли позиция в этой
 * строке, при которой сумма "весов" букв слева от
 * этой позиции равна сумме "весов" букв справа.
 *
 * Вес каждой буквы определяется как её порядковый
 * номер в алфавите: a → 1, b → 2, …, z → 26.
 *
 * Возвращает:
 * - true, если существует позиция раздела строки, при
 *   которой суммы весов слева и справа равны
 *
 * - false в противном случае.
 *
 *
 * Пример для:
 *   s = "adcb"
 * Результат:
 *   true
 * Пояснение:
 * Разделение на индексе i = 1:
 *   Левая подстрока = s[0..1] = "ad"
 *   со счётом = 1 + 4 = 5
 *
 *   Правая подстрока = s[2..3] = "cb"
 *   со счётом = 3 + 2 = 5
 *
 *   Обе подстроки имеют равные суммы, поэтому
 *   результат true.
 */
function scoreBalance(s) {

  // Инициализация переменной rightSum значением 0.
  //
  // rightSum будет содержать суммарный "вес" всех
  // символов, которые находятся справа от текущей
  // позиции разделителя.
  let rightSum = 0;

  // Итерация по каждому символу строки s.
  //
  // В этом первом проходе мы вычисляем полную сумму
  // значений всех символов и сохраняем её в rightSum.
  for (const char of s) {

    // Получаем кодовую точку текущего символа с
    // помощью codePointAt(0).
    //
    // Вычитаем 96, чтобы преобразовать кодовую
    // точку строчной латинской буквы в её позицию в
    // алфавите:
    // 'a'.codePointAt(0) === 97 → 97 - 96 === 1,
    // 'b' → 2 ... 'z' → 26
    //
    // Добавляем полученное значение к rightSum.
    rightSum += char.codePointAt(0) - 96;
  }

  // Инициализация переменной leftSum значением 0.
  //
  // leftSum будет содержать суммарный "вес" всех
  // символов, которые находятся слева от текущей
  // позиции разделителя.
  let leftSum = 0;

  // Второй проход по тем же символам:
  //
  // Моделируем перемещение разделителя слева направо,
  // последовательно переводя символы из правой суммы
  // в левую.
  for (const char of s) {

    // Вычисляем "вес" текущего символа в алфавите и
    // сохраняем в локальную переменную charScore.
    const charScore = char.codePointAt(0) - 96;

    // Добавляем вес текущего символа к leftSum,
    // поскольку при движении разделителя этот символ
    // теперь считается слева.
    leftSum += charScore;

    // Одновременно вычитаем вес текущего символа из
    // rightSum, так как он больше не принадлежит
    // правой части.
    rightSum -= charScore;

    // Проверяем условие баланса:
    //
    // Если суммы слева и справа равны, значит найдено
    // место, где строка "сбалансирована".
    //
    // В этом случае функция немедленно возвращает
    // true, прекращая дальнейшую обработку.
    if (leftSum === rightSum) return true;
  }

  // Если цикл завершился и ни в одной позиции не было
  // равенства сумм, возвращаем false.
  //
  // Это покрывает случаи, когда строка пустая (в этом
  // случае rightSum изначально 0, но цикл проверки не
  // выполнит ни одной итерации), а также случаи,
  // когда никакая граница не даёт равенства сумм.
  return false;
}
