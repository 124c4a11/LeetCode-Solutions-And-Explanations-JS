/**
 * @param {number[][]} ranges
 * @param {number} left
 * @param {number} right
 * @return {boolean}
 *
 * isCovered проверяет, покрыты ли все целые числа в
 * диапазоне [left, right] хотя бы одним из интервалов
 * из массива ranges.
 *
 * Параметры:
 * - ranges — массив диапазонов, где каждый элемент
 *   имеет вид [start, end] и задаёт включительный
 *   интервал от start до end.
 *
 * - left — целое число, левая граница проверяемого
 *   включительного отрезка.
 *
 * - right — целое число, правая граница проверяемого
 *   включительного отрезка.
 *
 * Возвращает
 * - true, если каждое целое число в диапазоне
 *   [left, right] покрывается хотя бы одним
 *   интервалом в диапазоне ranges.
 *
 * - В противном случае возвращает false.
 *
 *
 * Пример для:
 *   ranges = [[1,2],[3,4],[5,6]],
 *   left = 2,
 *   right = 5
 * Результат:
 *   true
 * Пояснение:
 *   Каждое целое число между 2 и 5 покрыто:
 *   - 2 покрывается первым диапазоном.
 *   - 3 и 4 покрываются вторым диапазоном.
 *   - 5 покрывается третьим диапазоном.
 */
function isCovered(ranges, left, right) {

  // Создаём массив разностей фиксированной длины 52
  // (индексы 0..51) для реализации техники
  // "разностного массива"
  //
  // Почему 52:
  // Предполагается, что значения границ интервалов
  // лежат в диапазоне 1..50, поэтому нужен запас
  // для range[1] + 1
  const diffArr = new Int32Array(52);

  // Проходим по каждому интервалу в входном массиве
  // ranges
  //
  // Для ускорения работы цилкла не используем
  // деструктуризацию массива range, а обращаемся к
  // значениям range по индексу
  for (const range of ranges) {

    // Пометка начала покрытия:
    //
    // Увеличиваем значение в позиции, равной левой
    // границе интервала.
    //
    // Это означает, что начиная с этого индекса
    // количество активных покрытий увеличивается на 1
    diffArr[range[0]]++;

    // Пометка конца покрытия:
    //
    // Уменьшаем значение в позиции сразу после правой
    // границы интервала.
    //
    // Это гарантирует, что при накоплении префиксной
    // суммы покрытие перестаёт действовать после
    // range[1]
    diffArr[range[1] + 1]--;
  }

  // Инициализируем переменную для накопления
  // префиксной суммы — она будет показывать, сколько
  // интервалов покрывают текущую точку
  let prefixSum = 0;

  // Проходим по всем возможным позициям, начиная с
  // 1 до 51 включительно
  //
  // Начало с 1 связано с тем, что индексы интервалов
  // ожидаются в диапазоне, начинающемся с 1
  for (let i = 1; i < 52; i++) {

    // Обновляем префиксную сумму:
    //
    // Добавляем значение разностного массива в
    // текущей позиции.
    //
    // После этой операции prefixSum отражает число
    // интервалов, покрывающих точку i
    prefixSum += diffArr[i];

    // Проверяем условие:
    //
    // Если в текущей позиции i нет ни одного покрытия
    // (prefixSum <= 0) и при этом i находится внутри
    // проверяемого интервала [left, right]
    // (left <= i && i <= right), то это означает, что
    // хотя бы одна точка в интервале left..right не
    // покрыта ни одним диапазоном.
    //
    // В этом случае сразу возвращаем false — интервал
    // покрыт не полностью.
    if (
      prefixSum <= 0
      && left <= i
      && i <= right
    ) return false;
  }

  // Если цикл завершился и ни одна точка в интервале
  // [left, right] не была обнаружена непокрытой,
  // значит весь интервал покрыт хотя бы одним
  // диапазоном, и функция возвращает true.
  return true;
}
