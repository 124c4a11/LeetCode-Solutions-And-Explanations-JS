/**
 * @param {number[]} nums
 * @return {number}
 *
 * findMiddleIndex принимает целочисленный массив nums
 * с нумерацией с нуля. Находит и возвращает самый
 * левый middleIndex (то есть наименьший из всех
 * возможных), возвращает, или -1, если такого индекса
 * нет.
 *
 * MiddleIndex — это индекс, для которого сумма
 * элементов слева от него
 * nums[0] + nums[1] + ... + nums[middleIndex - 1]
 * равна сумме элементов справа от него
 * nums[middleIndex + 1] + nums[middleIndex + 2] +
 * ... + nums[nums.length - 1].
 *
 *
 * Пример для:
 *   nums = [2, 3, -1, 8, 4]
 *                     ^
 * Результат:
 *   3
 * Пояснение:
 *   Сумма чисел до индекса 3: 2 + 3 + -1 = 4
 *   Сумма чисел после индекса 3: 4 = 4
 */
function findMiddleIndex(nums) {

  // Инициализация leftSum нулём.
  //
  // В процессе обхода leftSum будет аккумулировать
  // сумму элементов слева от текущей позиции.
  //
  // На момент начала обхода "слева" ничего нет,
  // поэтому leftSum = 0.
  let leftSum = 0;

  // Вычисляем общую сумму элементов массива и
  // сохраняем в rightSum.
  //
  // На каждой итерации мы будем вычитать из
  // rightSum текущий элемент, чтобы rightSum
  // отражала сумму элементов строго справа от i.
  let rightSum = nums.reduce((a, b) => a + b, 0);

  // Проходим по всем индексам массива в порядке от
  // 0 до nums.length - 1.
  for (let i = 0; i < nums.length; i++) {

    // Перед проверкой вычитаем текущий элемент
    // nums[i] из rightSum.
    //
    // После этой операции rightSum содержит сумму
    // всех элементов с индексами > i, то есть
    // строго справа от текущего индекса.
    //
    // Это важно! Элемент в позиции i не включается
    // ни в leftSum, ни в rightSum при сравнении.
    rightSum -= nums[i];

    // Сравниваем leftSum и rightSum:
    // Если они равны, значит сумма всех элементов
    // слева от i равна сумме всех элементов справа
    // от i.
    //
    // В этом случае i — искомый "middle index".
    // Возвращаем i немедленно, что обеспечивает
    // выбор самого левого подходящего индекса.
    if (leftSum === rightSum) return i;

    // Если равенства нет, добавляем текущий элемент
    // nums[i] к leftSum.
    //
    // Это подготавливает leftSum для следующей
    // итерации.
    //
    // После добавления leftSum будет равна сумме
    // элементов с индексами < i+1.
    //
    // Порядок важен! Вычитание из rightSum
    // происходит до сравнения, а добавление в
    // leftSum — после.
    //
    // Такой порядок гарантирует, что текущий
    // элемент не учитывается ни в одной из сумм при
    // проверке.
    leftSum += nums[i];
  }

  // Если цикл завершился и ни один индекс не
  // удовлетворил условию равенства сумм,
  // возвращаем -1.
  return -1;
}
