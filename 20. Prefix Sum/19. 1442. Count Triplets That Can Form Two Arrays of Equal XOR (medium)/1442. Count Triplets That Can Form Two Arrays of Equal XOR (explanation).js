/**
 * @param {number[]} arr
 * @return {number}
 *
 * countTriplets подсчитывает количество троек индексов
 * (i, j, k) в массиве arr, таких что
 * 0 <= i < j <= k < arr.length и XOR всех элементов в
 * отрезке arr[i..j-1] равен XOR всех элементов в
 * отрезке arr[j..k].
 *
 * Параметры:
 * - arr — массив целых чисел
 *
 * Возвращает:
 * - число - общее количество троек индексов (i, j, k)
 *   удовлетворяющих условию
 *
 *
 * Пример для:
 *   arr = [2,3,1,6,7]
 * Результат:
 *   4
 * Пояснение:
 * Тройки индексов: (0,1,2), (0,2,2), (2,3,4) и (2,4,4)
 */
function countTriplets(arr) {
  const n = arr.length;

  // Инициализируем аккумулятор result нулём.
  //
  // В нём будет суммироваться итоговое количество
  // подходящих троек.
  let result = 0;

  // Внешний цикл перебирает все возможные начальные
  // индексы i подотрезков.
  for (let i = 0; i < n; i++) {

    // Инициализируем xorSum значением элемента arr[i].
    //
    // В дальнейшем xorSum будет хранить XOR всех
    // элементов от i до текущего j включительно
    // (префиксный XOR для подотрезка arr[i..j]).
    let xorSum = arr[i];

    // Внутренний цикл по j:
    //
    // j - правая граница отрезка, начиная с i+1
    // (поскольку требуется i < j).
    for (let j = i + 1; j < n; j++) {

      // Обновляем xorSum операцией побитового XOR с
      // arr[j].
      //
      // После этой операции
      // xorSum = arr[i] ^ arr[i+1] ^ ... ^ arr[j].
      xorSum ^= arr[j];

      // Проверяем, равен ли XOR на отрезке [i, j] нулю.
      //
      // Математический смысл:
      // Если XOR(i..j) == 0, то для любого m такого,
      // что i < m <= j, выполняется
      // XOR(i..m-1) == XOR(m..j), что даёт (j - i)
      // различных троек (i, m, j).
      //
      // Поэтому при обнаружении нулевого xorSum
      // увеличиваем result на количество возможных m,
      // равное j - i.
      if (xorSum === 0) result += j - i;
    }
  }

  // Возвращаем итоговое количество троек, накопленное
  // в result.
  return result;
}
