/**
 * @param {number[]} nums
 * @param {number[]} queries
 * @return {number[]}
 *
 * answerQueries принимает целочисленный массив nums длины n и
 * целочисленный массив queries длины m и возвращает массив
 * result длины m, где result[i] — максимальный размер
 * подпоследовательности, которую можно выбрать из nums так,
 * чтобы сумма её элементов была меньше или равна queries[i].
 *
 * Подпоследовательность — это массив, который можно получить
 * из другого массива удалением некоторых элементов или без
 * удаления, при этом порядок оставшихся элементов не меняется.
 *
 *
 * Пример для:
 *   nums = [4,5,2,1],
 *   queries = [3,10,21]
 * Результат:
 *   [2,3,4]
 * Пояснение:
 * Отвечаем на запросы следующим образом:
 * - Подпоследовательность [2,1] имеет сумму, не превышающую 3.
 *   Можно доказать, что 2 — максимальный размер такой
 *   подпоследовательности, поэтому result[0] = 2.
 *
 * - Подпоследовательность [4,5,1] имеет сумму, не превышающую
 *   10.
 *   Можно доказать, что 3 — максимальный размер такой
 *   подпоследовательности, поэтому result[1] = 3.
 *
 * - Подпоследовательность [4,5,2,1] имеет сумму,
 *   не превышающую 21.
 *   Можно доказать, что 4 — максимальный размер такой
 *   подпоследовательности, поэтому result[2] = 4
 */
function answerQueries(nums, queries) {

  // Сортируем массив nums по возрастанию числовым сравнением.
  //
  // Это необходимо, чтобы при последующем накоплении
  // префиксных сумм получить неубывающую последовательность
  // сумм, что позволяет применять бинарный поиск.
  nums.sort((a, b) => a - b);

  // Начинаем цикл с индекса 1, потому что префиксная сумма
  // для нулевого элемента равна самому элементу.
  //
  // Цикл преобразует отсортированный массив в массив
  // префиксных сумм на месте.
  for (let i = 1; i < nums.length; i++) {

    // На каждой итерации добавляем к текущему элементу сумму
    // всех предыдущих элементов, тем самым nums[i]
    // становится суммой элементов nums[0]..nums[i].
    nums[i] += nums[i - 1];
  }

  // Для каждого query выполняем отображение (map):
  // вызываем binarySearchUpperBound, которая находит первую
  // позицию в массиве префиксных сумм, где значение > query.
  //
  // Возвращаем массив индексов — это и есть максимальная
  // длина префикса, потому что индексы префиксных сумм
  // соответствуют длинам префиксов (l элементов дают индекс
  // l-1), а функция возвращает позицию первого элемента
  // > query, что равно количеству элементов <= query.
  return queries.map((query) => binarySearchUpperBound(nums, query));
}


// Объявление вспомогательной функции binarySearchUpperBound.
//
// Принимает отсортированный (неубывающий) массив arr и
// значение target.
//
// Возвращает наименьший индекс l такой, что arr[l] > target.
//
// Если все элементы <= target, возвращает arr.length.
function binarySearchUpperBound(arr, target) {

  // Инициализация левой границы поиска (включительно) нулём.
  let l = 0;

  // Инициализация правой границы поиска (исключительно)
  // равной длине массива.
  //
  // Такое значение r = arr.length позволяет корректно вернуть
  // arr.length, когда сумма всех элементов массива <= target.
  let r = arr.length;

  // Стандартный цикл бинарного поиска по полуинтервалу [l, r).
  //
  // Условие l < r гарантирует, что пока есть хотя бы один
  // кандидат, цикл продолжается.
  while (l < r) {

    // Вычисление среднего индекса безопасным способом:
    // l + Math.floor((r - l) / 2).
    //
    // Почему используем Math.floor(l + (r - l) / 2) вместо
    // Math.floor((l + r) / 2):
    //
    // 1. Безопасность от переполнения
    //    В языках с фиксированным диапазоном целых чисел
    //    (Java, C++, C) выражение (l + r) может превысить
    //    MAX_INT и дать неправильный результат.
    //    При (r - l) результат всегда лежит в диапазоне
    //    [0, r], а потом мы добавляем l.
    //
    // 2. Переносимость кода
    //    Такой приём принят в алгоритмических библиотеках на
    //    разных языках. Он сразу даёт понять: мы делим
    //    отрезок пополам без риска overflow.
    //
    // 3. Особенности JavaScript
    //    JS хранит числа в формате IEEE-754, и переполнение
    //    при сумме до Number.MAX_SAFE_INTEGER встречается
    //    редко. Но придерживаться этой практики полезно,
    //    если код может быть портирован.
    //
    // 4. Альтернативы и нюансы
    //    Вместо Math.floor((l + r) / 2) можно использовать
    //    (l + r) >>> 1 — побитовый сдвиг. Однако он
    //    «маскирует» знак и ведёт себя иначе при
    //    отрицательных значениях.
    //
    // 5. Универсальность применения
    //    Рекомендуется применять l + (r - l) / 2 во всех
    //    задачах целочисленного бинарного поиска, чтобы
    //    исключить риск переполнения и сохранить
    //    переносимость.
    //    Исключения допустимы лишь при гарантированном
    //    контроле диапазона значений, но единообразие кода
    //    остаётся приоритетом.
    //
    // Итог: выражение l + (r - l) / 2 надёжнее, чище и
    // переносимее для бинарного поиска.
    const midd = Math.floor(l + (r - l) / 2);

    // Если значение в середине меньше или равно target,
    // значит все индексы <= midd не могут быть ответом
    // (нам нужна первая позиция с элементом > target),
    // поэтому сдвигаем левую границу на midd + 1.
    if (arr[midd] <= target) l = midd + 1;

    // Иначе, если arr[midd] > target, то возможный ответ
    // находится в левом подинтервале, включая midd, поэтому
    // сдвигаем правую границу на midd.
    else r = midd;
  }

  // По завершении цикла l === r и указывает на первую позицию,
  // где arr[index] > target.
  //
  // Это также количество элементов в исходном массиве, сумма
  // которых не превышает target - то есть длина максимальной
  // подпоследовательности, сумма элементов которой меньше
  // или равна target.
  //
  // Если l === arr.length, значит все префиксные суммы
  // <= target.
  return l;
}
