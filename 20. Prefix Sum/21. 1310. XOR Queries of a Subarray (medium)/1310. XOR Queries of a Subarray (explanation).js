/**
 * @param {number[]} arr
 * @param {number[][]} queries
 * @return {number[]}
 *
 * xorQueries принимает массив arr положительных целых чисел и
 * массив queries, где queries[i] = [lefti, righti].
 *
 * Для каждого query i вычисляет побитовое XOR элементов от
 * lefti до righti (то есть arr[lefti] XOR arr[lefti + 1]
 * XOR ... XOR arr[righti]).
 *
 * Возвращает массив result, где result[i] — ответ на i-й query.
 *
 *
 * Пример для:
 *   arr = [1,3,4,8],
 *   queries = [[0,1],[1,2],[0,3],[3,3]]
 * Результат:
 *   [2,7,14,8]
 * Пояснение:
 * Двоичное представление элементов массива:
 *   1 = 0001
 *   3 = 0011
 *   4 = 0100
 *   8 = 1000
 * Значения XOR для запросов:
 *   [0,1] = 1 xor 3 = 2
 *   [1,2] = 3 xor 4 = 7
 *   [0,3] = 1 xor 3 xor 4 xor 8 = 14
 *   [3,3] = 8
 */
function xorQueries(arr, queries) {
  const n = arr.length;

  // Создаём типизированный массив Int32Array длиной n + 1 для
  // хранения префиксных XOR.
  //
  // Почему n + 1:
  // Индекс 0 будет хранить нейтральный элемент (0),
  // а prefixXors[i+1] — XOR первых i+1 элементов.
  const prefixXors = new Int32Array(n + 1);

  // Заполняем массив префиксов:
  //
  // Для каждого i вычисляем XOR всех элементов arr[0..i].
  //
  // Итерация идёт по индексам исходного массива от 0 до n-1.
  for (let i = 0; i < n; i++) {

    // Записываем prefixXors[i+1] как XOR предыдущего префикса и
    // текущего элемента arr[i].
    //
    // Свойства XOR, используемые здесь:
    // a ^ a = 0, a ^ 0 = a, операция ассоциативна и коммутативна.
    //
    // Это позволяет в дальнейшем получать XOR подмассива за O(1)
    // через разность (XOR) префиксов.
    //
    // Если prefixXors[k] = arr[0] ^ ... ^ arr[k-1], то XOR
    // подмассива arr[l..r] = prefixXors[r+1] ^ prefixXors[l].
    prefixXors[i + 1] = prefixXors[i] ^ arr[i];
  }

  // Инициализируем массив для результатов.
  //
  // В него будем добавлять ответ на каждый запрос (query).
  const result = [];

  // Проходим по каждому запросу в массиве queries.
  //
  // Ожидается, что каждый query — это массив из двух чисел
  // [left, right].
  //
  // Для ускорения работы цикла не используем деструктуризацию
  // query, а обращаемся к каждому элементу query по индексу.
  for (const query of queries) {

    // Для текущего query извлекаем границы подмассива через
    // индексы query[0] (left) и query[1] (right).
    //
    // Вычисляем XOR подмассива [left..right] как
    // prefixXors[right + 1] ^ prefixXors[left].
    //
    // Это работает потому, что
    // prefixXors[right + 1] = XOR(arr[0..right]),
    // prefixXors[left] = XOR(arr[0..left-1]),
    // и при XOR этих двух значений остаётся XOR элементов
    // arr[left..right].
    //
    // Операция выполняется за константное время, поэтому
    // обработка каждого query — O(1).
    //
    // Результат добавляем в массив result методом push.
    result.push(prefixXors[query[1] + 1] ^ prefixXors[query[0]]);
  }

  // Возвращаем массив результатов для всех запросов в том же
  // порядке, в котором они были заданы.
  return result;
}
