/**
 * @param {number[]} nums
 * @return {number}
 *
 * countValidSelections принимает массив целых чисел и
 * возвращает количество «валидных выборов» стартовой
 * позиции и направления движения в задаче, где элементы
 * массива уменьшаются по определённым правилам до нуля.
 *
 * В этой задаче считается, что допустимая стартовая
 * позиция — это индекс, где значение равно нулю, и для
 * каждой такой позиции проверяются два направления
 * (влево и вправо). Функция подсчитывает и возвращает,
 * сколько таких пар (позиция, направление) в итоге приведут
 * к тому, что все элементы массива станут нулями при
 * описанном процессе.
 *
 * Условие:
 * Начните с выбора начальной позиции curr такой, что
 * nums[curr] == 0, и выберите направление движения —
 * влево или вправо.
 *
 * После этого повторяйте следующий процесс:
 * - Если curr выходит за пределы диапазона [0, n - 1],
 *   процесс заканчивается.
 *
 * - Если nums[curr] == 0, двигайтесь в текущем направлении:
 *   увеличьте curr при движении вправо или уменьшите curr
 *   при движении влево.
 *
 * - Иначе, если nums[curr] > 0:
 *   - Уменьшите nums[curr] на 1.
 *
 *   - Разверните направление движения (влево становится
 *     вправо и наоборот).
 *
 *   - Сделайте шаг в новом направлении.
 *
 * Пара (начальная позиция curr и выбранное направление)
 * считается валидной, если к концу процесса все элементы
 * nums становятся равны 0.
 *
 * Верните количество возможных валидных выборов.
 *
 *
 * Пример для:
 *   nums = [1,0,2,0,3]
 * Результат:
 *   2
 * Пояснение:
 *   Единственные возможные валидные выборы следующие:
 *   Выбрать curr = 3 и направление движения влево.
 *   [1,0,2,0,3] → [1,0,2,0,3] → [1,0,1,0,3] → [1,0,1,0,3]
 *          ^           ^               ^               ^
 *   → [1,0,1,0,2] → [1,0,1,0,2] → [1,0,0,0,2] → [1,0,0,0,2]
 *            ^           ^               ^               ^
 *   → [1,0,0,0,1] → [1,0,0,0,1] → [1,0,0,0,1] → [1,0,0,0,1]
 *            ^           ^           ^           ^
 *   → [0,0,0,0,1] → [0,0,0,0,1] → [0,0,0,0,1] → [0,0,0,0,1]
 *        ^               ^               ^               ^
 *   → [0,0,0,0,0]
 *
 *
 * Пример для:
 *   nums = [2,3,4,0,4,1,0]
 * Результат:
 *   0
 * Пояснение:
 *   Нет ни одного возможного валидного выбора.
 */
function countValidSelections(nums) {

  // Инициализация счётчика result, который будет
  // аккумулировать количество «валидных выборов» стартовой
  // позиции и направления движения, которые в итоге
  // приведут к тому, что все элементы массива станут нулями
  let result = 0;

  // Инициализация leftSum — переменная будет хранить
  // накопленную сумму элементов, которые  были обработаны и
  // отнесены к "левой" части при проходе по массиву слева
  // направо.
  //
  // Изначально 0, затем при встрече положительных элементов
  // leftSum увеличивается на значение этого элемента.
  let leftSum = 0;

  // Вычисление правой суммы rightSum как суммы всех
  // элементов массива nums.
  //
  // rightSum представляет сумму элементов, которые ещё не
  // были "перемещены" в leftSum на момент начала итерации.
  let rightSum = nums.reduce((a, b) => a + b, 0);

  // Перебираем элементы массива nums в порядке их
  // следования.
  //
  // Алгоритм проходит по массиву слева направо, не
  // моделируя пошагово весь процесс движения по индексам,
  // а поддерживает две накопительные суммы — leftSum
  // (сумма «уже пройденных» положительных элементов) и
  // rightSum (сумма оставшихся элементов). Для каждого
  // элемента он либо обновляет эти суммы (если элемент
  // положительный), либо для неположительного (нулевого)
  // элемента вычисляет вклад в result на основе текущей
  // разницы между суммами по сторонам. Таким образом задача
  // о допустимых начальных выборах сводится к локальной
  // проверке условия равновесия сумм в момент встречи с
  // нулевым элементом.
  //
  // Для каждой позиции, где значение равно нулю (в коде
  // это проверяется через ветку else для неположительных
  // значений), на основе сравнения leftSum и rightSum
  // определяется, сколько из двух направлений (влево и
  // вправо) приведут к успешному обнулению всех элементов.
  // Если суммы равны, оба направления годятся. Если разница
  // равна 1, годится только направление в сторону большей
  // суммы. При разнице ≥ 2 ни одно направление не годится.
  // Это позволяет посчитать вклад каждой нулевой позиции в
  // итог без симуляции процесса для каждой пары
  // (позиция, направление).
  for (const num of nums) {

    // Условие проверяет, является ли текущий элемент
    // больше нуля (> 0).
    if (num > 0) {

      // Если элемент больше нуля, он считается частью
      // "левой" суммы:
      //
      // Добавляем его к leftSum, тем самым фиксируя, что
      // этот элемент теперь обработан и находится слева.
      leftSum += num;

      // Одновременно вычитаем этот же элемент из rightSum,
      // чтобы rightSum всегда отражала сумму элементов,
      // ещё не обработанных (справа).
      //
      // После этих двух операций invariant:
      // leftSum + rightSum == исходная полная сумма массива.
      rightSum -= num;
    } else {

      // Ветка else обрабатывает нулевые элементы.
      //
      // - leftSum - rightSum
      //   Вычисляет разницу между текущими накопленными
      //   суммами слева и справа. Эта разница показывает,
      //   насколько одна часть массива «тяжелее» другой в
      //   данный момент.
      //
      // - Math.abs(leftSum - rightSum)
      //   Берёт абсолютное значение разницы, то есть
      //   рассматривает только величину
      //   несбалансированности, без учёта направления
      //   (лево больше или право больше).
      //
      // - 2 - Math.abs(...)
      //   Вычисляет, насколько эта абсолютная разница
      //   меньше числа 2. Если разница равна 0, выражение
      //   даёт 2. Если разница равна 1, даёт 1. Если
      //   разница ≥ 2, даёт значение ≤ 0.
      //
      // - Math.max(0, 2 - Math.abs(...))
      //   Гарантирует, что вклад в result не будет
      //   отрицательным: Если 2 - |разница| отрицательно
      //   или ноль, добавляется 0. Иначе добавляется
      //   положительная величина (1 или 2 при
      //   целочисленных суммах).
      //
      // - result += ...
      //   Прибавляет полученное неотрицательное число к
      //   накопительному счётчику result.
      //
      // Число 2 в выражении 2 - Math.abs(leftSum - rightSum)
      // — это максимальное количество допустимых направлений
      // для данной начальной позиции curr (влево и вправо).
      // Выражение даёт 2, 1 или 0 в зависимости от того,
      // насколько «сбалансированы» суммы слева и справа:
      // - Если разница равна 0 → добавляется 2 (оба
      //   направления годятся)
      //
      // - Если разница равна 1 → добавляется 1 (одно
      //   направление годится)
      //
      // - Если разница ≥ 2 → добавляется 0 (ни одно
      //   направление не годится.).
      result += Math.max(0, 2 - Math.abs(leftSum - rightSum));
    }
  }

  // Возвращает количество «валидных выборов» стартовой
  // позиции и направления движения, которые в итоге
  // приведут к тому, что все элементы массива станут нулями
  return result;
}
