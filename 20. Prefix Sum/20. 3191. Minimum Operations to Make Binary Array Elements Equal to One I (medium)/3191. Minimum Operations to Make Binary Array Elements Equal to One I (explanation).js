/**
 * @param {number[]} nums
 * @return {number}
 *
 * minOperations принимает бинарный массив nums (состоящий
 * из 0 и 1). Выполняет следующую операцию над массивом
 * любое количество раз (включая ноль):
 * - Выбрает любые три подряд идущих элемента массива и
 *   инвертироует все три.
 *
 * Инвертирование элемента означает замену 0 на 1 и 1 на 0.
 *
 * Возвращает минимальное количество операций, необходимых,
 * чтобы все элементы в nums стали равны 1. Если это
 * невозможно, возвращает -1.
 *
 *
 * Пример для:
 *   nums = [0,1,1,1,0,0]
 * Результат:
 *   3
 * Пояснение:
 * Мы можем выполнить следующие операции:
 * - Выбрать элементы с индексами 0, 1 и 2.
 *   В результате массив станет nums = [1,0,0,1,0,0].
 *                                      ^ ^ ^
 *
 * - Выбрать элементы с индексами 1, 2 и 3.
 *   В результате массив станет nums = [1,1,1,0,0,0].
 *                                        ^ ^ ^
 *
 * - Выбрать элементы с индексами 3, 4 и 5.
 *   В результате массив станет nums = [1,1,1,1,1,1].
 *                                            ^ ^ ^
 *
 * Пример для:
 *   nums = [0,1,1,1]
 * Результат:
 *   -1
 * Пояснение:
 * Невозможно сделать все элементы равными 1 с помощью
 * допустимых операций (инвертирования любых трёх подряд
 * идущих элементов).
 * - nums = [1,0,0,1]
 *           ^ ^ ^
 * - nums = [1,1,1,0]
 *             ^ ^ ^
 * - nums = [1,1,1,0]
 *               ^ ^ ^
 *   Выхдим за пределы массива. Нет возможности выбрать
 *   три элемента, чтобы инвертировать последний 0.
 */
function minOperations(nums) {
  const n = nums.length;

  // Инициализируем счётчик операций, необходимых, чтобы
  // все элементы в nums стали равны 1
  let operationCnt = 0;

  // Запускаем цикл по индексам массива от 0 до n-1.
  //
  // Идея:
  // При встрече нуля на позиции i мы пытаемся "исправить"
  // его (инветировать к 1), что приводит к инвертации
  // двух последующих элементов (nums[i+1] и nums[i+2]).
  for (let i = 0; i < n; i++) {

    // Если текущий элемент nums[i] не равен 0, то он не
    // требует действий.
    //
    // continue пропускает оставшуюся часть тела цикла и
    // переходит к следующему i.
    //
    // Это реализует жадную стратегию:
    // Мы обрабатываем нули слева направо и не трогаем уже
    // корректные позиции.
    if (nums[i] !== 0) continue;

    // Если текущий элемент равен 0, нам нужно выполнить
    // операцию, которая инвертирует два следующих элемента.
    //
    // Но если до конца массива осталось меньше двух
    // элементов (i+1 или i+2 выходит за границы), то
    // выполнить требуемую операцию невозможно.
    //
    // В этом случае функция возвращает -1 как индикатор
    // невозможности добиться всех единиц в nums (или
    // требуемого состояния) применением инвертации трех
    // соседних элементов.
    if (i + 2 >= n) return -1;

    // Инвертируем значение элемента в позиции i+1 с
    // помощью побитового XOR с 1.
    //
    // Для битов 0/1 операция ^= 1 переключает 0→1 и 1→0.
    //
    // Это изменяет состояние массива in-place и влияет
    // на последующие проверки.
    nums[i + 1] ^= 1;

    // Инвертируем значение элемента в позиции i+2
    // аналогичным образом.
    nums[i + 2] ^= 1;

    // Увеличиваем счётчик операций инверсии
    operationCnt++;
  }

  // Если цикл завершился без раннего возврата -1, значит
  // все позиции удалось обработать.
  //
  // Возвращаем общее количество требуемых операций.
  return operationCnt;
}
