/**
 * @param {number[][]} logs
 * @return {number}
 *
 * maximumPopulation вычисляет и возвращает самый ранний
 * год с наибольшим числом живых людей на основе массива
 * логов, где каждая запись — пара годов рождения и
 * смерти.
 *
 * Параметры:
 *   logs — массив записей, где каждая запись имеет вид
 *   [birthYear, deathYear]
 *
 *   birthYear и deathYear — целые числа в диапазоне
 *   1950 ≤ birthYear < deathYear ≤ 2050.
 *
 *
 * Пример для:
 *   logs = [[1950,1961],[1960,1971],[1970,1981]]
 * Вывод:
 *   1960
 * Пояснение:
 *   Максимальная численность населения равна 2, и это
 *   наблюдалось в годах 1960 и 1970. Ранний год среди
 *   них — 1960.
 */
function maximumPopulation(logs) {

  // Создаёт массив фиксированной длины 101 типа
  // Int32Array для хранения дельт населения по годам.
  //
  // Индекс 0 соответствует 1950 году, индекс
  // 100 — 2050 году.
  const populationChanges = new Int32Array(101);

  // Итерация по каждому элементу входного массива logs.
  //
  // Каждый элемент log — ожидаемо массив из двух чисел:
  // [год рождения, год смерти].
  //
  // Для ускорения работы цилкла не используем
  // деструктуризацию массива log, а обращаемся
  // к значениям log по индексу
  for (const log of logs) {

    // Увеличиваем счётчик в году рождения:
    //
    // Это означает, что с этого года человек
    // учитывается в популяции.
    //
    // Выражение log[0] - 1950 переводит год в индекс
    // массива (например, 1950 → 0).
    populationChanges[log[0] - 1950]++;

    // Уменьшаем счётчик в году смерти:
    //
    // По условию задачи человек не считается живущим в
    // год смерти, поэтому мы вычитаем единицу в
    // индексе, соответствующем году смерти.
    populationChanges[log[1] - 1950]--;
  }

  // Инициализация переменной для хранения года с
  // максимальным населением.
  //
  // По умолчанию ставим 1950, чтобы при равных
  // значениях возвращался наименьший год.
  let maxPopulationYear = 1950;

  // Инициализация переменной для хранения
  // максимального найденного значения населения.
  //
  // Начинаем с 0, так как население не может быть
  // меньше нуля в корректных входных данных.
  let maxPopulation = 0;

  // Переменная для накопления текущей численности
  // населения при проходе по годам.
  //
  // Будет обновляться суммированием дельт из
  // populationChanges.
  let currPopulation = 0;

  // Проходим по всем индексам массива
  // populationChanges (0..100), соответствующим
  // годам 1950..2050.
  for (let i = 0; i < 101; i++) {

    // Накопление текущей численности:
    //
    // Прибавляем изменение, зарегистрированное для
    // данного года.
    //
    // Это превращает массив дельт в префиксную сумму,
    // где currPopulation — реальное население в году
    // i+1950.
    currPopulation += populationChanges[i];

    // Сравниваем текущую численность с максимальной
    // найденной ранее
    //
    // Используется строгое '>' — это обеспечивает
    // выбор самого раннего года при равных максимумах.
    if (currPopulation > maxPopulation) {

      // Обновляем максимальное значение популяции,
      // если нашли большее.
      maxPopulation = currPopulation;

      // Обновляем год максимума:
      //
      // Индекс i переводим обратно в год, прибавляя
      // 1950.
      maxPopulationYear = i + 1950;
    }
  }

  // Возвращаем год, в котором наблюдалась максимальная
  // численность населения.
  return maxPopulationYear;
}
