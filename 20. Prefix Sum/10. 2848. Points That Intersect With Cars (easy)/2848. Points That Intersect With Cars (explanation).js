/**
 * @param {number[][]} nums
 * @return {number}
 *
 * numberOfPoints принимает 2D целочисленный массив nums
 * с 0‑индексацией, представляющий координаты
 * припаркованных машин на числовой прямой.
 *
 * Для любого индекса i nums[i] = [start, end],
 * где start — начальная точка i‑й машины, а end —
 * конечная точка i‑й машины.
 *
 * Возвращает количество целочисленных точек на числовой
 * прямой, которые покрыты хотя бы одним из заданных
 * интервалов. Каждый интервал задаётся парой целых
 * чисел [start, end], и учитываются все целые
 * координаты от start до end включительно.
 *
 *
 * Пример для:
 *   nums = [[3,6],[1,5],[4,7]]
 * Результат:
 *   7
 * Пояснение:
 *   Все целочисленные точки от 1 до 7 пересекаются хотя
 *   бы с одной машиной, поэтому ответ равен 7.
 *
 *
 * Пример для:
 *   nums = [[1,3],[5,8]]
 * Результат:
 *   7
 * Пояснение:
 *   Точки, пересекающиеся хотя бы с одной машиной:
 *   1, 2, 3,   5, 6, 7, 8.
 *   Всего 7 точек, поэтому ответ равен 7.
 */
function numberOfPoints(nums) {

  // Создаём типизированный массив diffArr
  //
  // diffArr — это массив разностей (difference array),
  // который служит компактным способом пометить начала
  // и концы интервалов так, чтобы затем за один проход
  // восстановить, сколько интервалов покрывают каждую
  // целую точку.
  //
  // Идея:
  // Вместо того чтобы для каждого интервала увеличивать
  // счётчик на каждой точке внутри интервала, мы
  // отмечаем только границы:
  // добавляем +1 в позиции начала интервала и -1 в
  // позиции сразу после конца интервала. После всех
  // таких пометок префиксная сумма по diffArr даёт для
  // каждой точки число покрывающих её интервалов. Это
  // превращает множество диапазонных обновлений в набор
  // точечных изменений и один линейный проход для
  // подсчета результата.
  //
  // Почему длина 102:
  // В коде используется обращение
  // diffArr[interval[1] + 1]-- (diffArr[end + 1]--).
  // Чтобы это не выходило за границы, массив должен
  // содержать индекс maxEnd + 1. Если предполагается,
  // что границы интервалов лежат в диапазоне [0,100],
  // то максимальный индекс interval[1] + 1 равен 101,
  // значит нужен массив длины как минимум 102.
  //
  // Пошаговая роль diffArr в алгоритме:
  // 1. Маркировка изменений:
  //    Для каждого интервала [start, end] выполняются
  //    diffArr[start]++ и diffArr[end+1]--. Это
  //    фиксирует, что начиная со start количество
  //    активных интервалов увеличилось, а начиная с
  //    end+1 — уменьшилось.
  //
  // 2. Восстановление покрытий:
  //    Проходя по diffArr слева направо и накапливая
  //    сумму prefixSum += diff, мы получаем для каждой
  //    позиции i число интервалов, покрывающих точку i.
  //
  // 3. Подсчёт покрытых точек:
  //    Если prefixSum > 0 в позиции i, значит точка i
  //    покрыта хотя бы одним интервалом, и счётчик
  //    увеличивается.
  const diffArr = new Int32Array(102);

  // Итерация по входному массиву nums.
  //
  // Каждый элемент присваивается переменной interval.
  //
  // Каждый элемент interval является массивом или
  // кортежем из двух чисел [start, end].
  //
  // Для ускорения работы цилкла не используем
  // деструктуризацию массива interval, а обращаемся
  // к значениям interval по индексу
  for (const interval of nums) {

    // Увеличиваем значение в diffArr на позиции, равной
    // началу интервала.
    //
    // Это означает: начиная с индекса interval[0]
    // (interval[start]) количество активных интервалов
    // увеличивается на 1.
    //
    // Такой приём позволяет пометить начало покрытия
    // без явного заполнения всех точек внутри интервала.
    diffArr[interval[0]]++;

    // Уменьшаем значение в diffArr на позиции
    // interval[1] + 1 (interval[end] + 1), чтобы
    // отметить конец покрытия интервала.
    //
    // После накопления префиксной суммы это приведёт к
    // тому, что позиции > interval[end] не будут
    // учитывать этот интервал.
    //
    // Важно, что мы обращаемся к interval[end] + 1,
    // поэтому diffArr должен иметь достаточную длину,
    // чтобы этот индекс существовал.
    diffArr[interval[1] + 1]--;
  }

  // Инициализация счётчика результата — количества
  // целых точек, покрытых хотя бы одним интервалом.
  let result = 0;

  // Инициализация переменной prefixSum, которая будет
  // хранить текущую префиксную сумму по diffArr.
  //
  // prefixSum отражает число интервалов, покрывающих
  // текущую позицию при обходе diffArr слева направо.
  let prefixSum = 0;

  // Проход по всем элементам массива разностей diffArr.
  //
  // Каждый элемент diff — это изменение
  // (плюс или минус) числа активных интервалов в
  // данной позиции.
  for (const diff of diffArr) {

    // Обновляем префиксную сумму: добавляем текущее
    // изменение.
    //
    // После этой операции prefixSum равен количеству
    // интервалов, покрывающих текущую целую точку (i).
    prefixSum += diff;

    // Если prefixSum больше нуля, значит текущая
    // точка покрыта хотя бы одним интервалом.
    //
    // Увеличиваем итоговый счётчик result на 1 для
    // каждой такой точки.
    if (prefixSum > 0) result++;
  }

  // Возвращаем итоговое количество целых точек,
  // покрытых хотя бы одним интервалом
  return result;
}
