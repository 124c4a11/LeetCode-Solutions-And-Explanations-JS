/**
 * @param {number[]} arr
 * @return {number}
 *
 * sumOddLengthSubarrays вычисляет сумму всех подмассивов нечётной
 * длины входного массива: для каждого возможного подмассива
 * нечётной длины она суммирует его элементы и возвращает общую
 * сумму всех таких подмассивов.
 *
 * Краткая идея алгоритма:
 * Вместо явной генерации всех подмассивов функция для каждого
 * элемента arr[i] вычисляет, в скольких подмассивах нечётной
 * длины этот элемент участвует, и добавляет arr[i] умноженное на
 * это количество к итоговой сумме. Это даёт линейную по длине
 * массива сложность по времени и константный дополнительный объём
 * памяти.
 *
 *
 * Пример для:
 *   arr = [1,4,2,5,3]
 * Результат:
 *   58
 * Пояснение:
 *   Подмассивы нечётной длины массива arr и их суммы:
 *     [1] = 1
 *     [4] = 4
 *     [2] = 2
 *     [5] = 5
 *     [3] = 3
 *     [1,4,2] = 7
 *     [4,2,5] = 11
 *     [2,5,3] = 10
 *     [1,4,2,5,3] = 15
 *   Если сложить все эти значения, получаем
 *   1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
 */
function sumOddLengthSubarrays(arr) {
  const n = arr.length;

  // Инициализируем переменную-аккумулятор result нулём
  //
  // В него будем поэлементно добавлять вклад каждого элемента
  // массива, умноженный на число нечетных подмассивов, содержащих
  // этот элемент.
  let result = 0;

  // Запускаем цикл по индексам массива от 0 до n-1.
  //
  // Для каждого индекса i мы вычисляем, сколько нечётных
  // подмассивов включает элемент arr[i], и добавляем его вклад в
  // result.
  for (let i = 0; i < n; ++i) {

    // Вычисляем общее количество подмассивов (не обязательно
    // нечётных), в которых встречается элемент с индексом i.
    //
    // (i + 1) — количество возможных вариантов начала подмассива,
    // которые включают позицию i (начало может быть в любом
    // индексе от 0 до i).
    //
    // (n - i) — количество возможных вариантов конца подмассива,
    // которые включают позицию i (конец может быть в любом
    // индексе от i до n-1).
    //
    // Произведение даёт число всех непрерывных подмассивов,
    // содержащих элемент arr[i].
    const totalSubarrayCnt = (i + 1) * (n - i);

    // Из общего числа подмассивов выбираем только те, у
    // которых нечётная длина.
    //
    // Нечётные и чётные по длине подмассивы чередуются,
    // поэтому половина (или на единицу больше) подмассивов
    // нечётные.
    //
    // Формула Math.ceil(totalSubarrayCnt / 2) корректно даёт
    // количество подмассивов с нечетной длиной:
    // - если totalSubarrayCnt чётно, ровно половина
    //   подмассивов будет нечетной длины
    //
    // - если totalSubarrayCnt нечётно, то подмассивов с
    //   нечетной длиной будет на единицу больше, поэтому
    //   округляем результат деления вверх
    //
    // Пример:
    // Если totalSubarrayCnt = 5, то 5 / 2 = 2.5 → ceil → 3
    // Если totalSubarrayCnt = 4, то 4 / 2 = 2 → 2
    const oddSubarrayCnt = Math.ceil(totalSubarrayCnt / 2);

    // Вклад текущего элемента в итоговую сумму равен
    // значению элемента, умноженному на количество нечётных
    // подмассивов, где он присутствует.
    //
    // Это следует из линейности суммы: суммируя по всем
    // подмассивам, каждый элемент добавляется столько раз,
    // в скольких подмассивах с нечетной длиной он
    // встречается.
    //
    // Умножение arr[i] * oddSubarrayCnt даёт суммарный
    // вклад этого элемента во все нечётные подмассивы.
    //
    // Это позволяет избежать явной генерации всех
    // подмассивов и даёт линейную по n сложность.
    result += arr[i] * oddSubarrayCnt;
  }

  // Возвращаем накопленную сумму всех подмассивов нечётной
  // длины.
  //
  // Если массив пустой (n === 0), цикл не выполнится и
  // вернётся 0, что корректно.
  return result;
}
