/**
 * @param {number[]} nums
 * @return {number}
 *
 * countPartitions принимает массив чисел nums и возвращает
 * количество позиций разбиения массива на две непустые
 * части, при которых разность сумм левой и правой частей
 * является чётной.
 *
 *
 * Пример для:
 *   nums = [10,10,3,7,6]
 * Результат:
 *   4
 * Пояснение:
 * Эти 4 разреза:
 *   [10], [10, 3, 7, 6] с разностью сумм 10 - 26 = -16, что
 *   является чётным.
 *
 *   [10, 10], [3, 7, 6] с разностью сумм 20 - 16 = 4, что
 *   является чётным.
 *
 *   [10, 10, 3], [7, 6] с разностью сумм 23 - 13 = 10, что
 *   является чётным.
 *
 *   [10, 10, 3, 7], [6] с разностью сумм 30 - 6 = 24, что
 *   является чётным.
 */
function countPartitions(nums) {

  // Инициализация переменной result, которая будет
  // аккумулировать количество подходящих разбиений.
  let result = 0;

  // Инициализация суммы левой части leftSum.
  //
  // В начале левая часть пуста, поэтому сумма равна 0.
  //
  // leftSum будет обновляться по мере сдвига границы
  // разбиения вправо.
  let leftSum = 0;

  // Вычисление суммы всех элементов массива и сохранение
  // её в rightSum.
  //
  // Эта сумма используется как начальная сумма правой
  // части (весь массив считается правой частью до
  // первого сдвига).
  let rightSum = nums.reduce((a, b) => a + b, 0);

  // Проходим по всем элементам массива, за исключением
  // последнего (i < nums.length - 1)
  //
  // Исключение последнего элемента нужно, чтобы не
  // рассматривать разделение после последнего элемента
  // (правая часть не должна быть пустой).
  //
  // Разделение "после" последнего элемента оставило бы
  // пустую правую часть
  for (let i = 0; i < nums.length - 1; i++) {

    // Добавляет текущий элемент nums[i] к leftSum, тем
    // самым обновляя сумму левой части для текущего
    // положения разделения.
    //
    // Это действие соответствует перемещению границы
    // разделения вправо на один элемент.
    leftSum += nums[i];

    // Вычитаем текущий элемент nums[i] из rightSum, чтобы
    // rightSum всегда отражала сумму элементов,
    // находящихся справа от границы разделения.
    //
    // После этих двух операций leftSum + rightSum
    // остаётся равным исходной сумме всех элементов
    // массива.
    rightSum -= nums[i];

    // Проверка чётности разности сумм левой и правой
    // частей и обновление счётчика result.
    //
    // Выражение (leftSum - rightSum) % 2 вычисляет
    // остаток от деления разности на 2.
    //
    // Для чётной разности остаток равен 0, для нечётной
    // — 1 или -1 (в JavaScript при отрицательных числах
    // остаток может быть отрицательным).
    //
    // В тернарном операторе проверяется истинность
    // остатка: если остаток не равен 0 (т.е. выражение
    // истинно), добавляем 0, иначе (остаток равен 0)
    // добавляем 1. Таким образом, в result
    // инкрементируется 1 только для чётной разности.
    //
    // В JS значение -1 считается truthy, поэтому выражение
    // корректно распознаёт нечётные отрицательные разности
    // как нечётные и не добавляет 1.
    result += (leftSum - rightSum) % 2 ? 0 : 1;
  }

  // Возвращаем итоговое количество разбиений, где разность
  // сумм левой и правой частей чётна.
  return result;
}
