/**
 * @param {number[]} nums
 * @return {number}
 * 
 * subarraySum принимает массив чисел nums и возвращает одно
 * числовое значение, которое получается суммированием для
 * каждого индекса i суммы элементов подмассива от индекса
 * start до i, где start вычисляется как
 * Math.max(0, i - nums[i]).
 * 
 * Для вычисления сумм подмассивов используется массив
 * префиксных сумм, что делает получение суммы любого
 * отрезка за O(1).
 * 
 * 
 * Пример для:
 *   nums = [3,1,1,2]
 * Результат:
 *   13
 * Поясненине:
 *   nums[0] = [3]             → sum = 3
 *   nums[0 ... 1] = [3, 1]    → sum = 4
 *   nums[1 ... 2] = [1, 1]    → sum = 2
 *   nums[1 ... 3] = [1, 1, 2] → sum = 4
 *                             → Total Sum = 13
 */
function subarraySum(nums) {
  const n = nums.length;

  // Создаём буфер префиксных сумм длиной n+1 в виде
  // Int32Array — это типизированный массив с 32‑битными
  // целыми, который экономит память и обеспечивает более
  // быстрый доступ по сравнению с обычным массивом в
  // некоторых сценариях.
  // 
  // Нулевой элемент служит базовой префиксной суммой (0),
  // а индекс i+1 будет хранить действительную сумму первых
  // i элементов nums в диапазоне nums[0..i]. То есть
  // действительные префиксные суммы nums хранятся в
  // prefixSums по индексам со здвигом +1.
  //
  // Длина prefixSums равна n + 1, чтобы в нулевом элементе
  // хранить сумму пустого префикса (prefixSums[0] = 0)
  // — это даёт единообразную формулу для суммы любого
  // отрезка a..b как prefixSums[b + 1] - prefixSums[a] и
  // устраняет специальные проверки для границы a = 0.
  // Без этого пришлось бы писать условные ветвления для
  // случая a = 0 или использовать менее наглядные формулы.
  //
  // prefixSums нужен, чтобы превратить многократные
  // запросы сумм подмассивов из O(n) в O(1) и тем самым
  // снизить общую временную сложность алгоритма до O(n).
  // 
  // Он хранит накопленные суммы префиксов массива и служит
  // быстрым способом получить сумму любого отрезка через
  // разность двух префиксных сумм.
  //
  // prefixSums — это массив, где элемент с индексом k
  // хранит сумму первых k элементов исходного массива
  // (часто делают длину n + 1 и ставят нулевой элемент
  // равным 0). Благодаря этому сумма любого отрезка
  // [start...i] вычисляется как разность двух префиксных
  // сумм: prefixSums[i + 1] - prefixSums[start]
  //
  // В исходном коде для каждого индекса i требуется сумма
  // элементов от start до i. Без префиксных сумм это
  // потребовало бы прохода по этому отрезку для каждого i,
  // то есть потенциально O(n^2) операций в худшем случае.
  // С prefixSums та же операция выполняется за O(1):
  // prefixSums[i+1] - prefixSums[start].
  // - prefixSums[i + 1] — это сумма элементов nums[0..i].
  //
  // - prefixSums[start] — это сумма элементов
  //   nums[0..start-1]
  // Их разность даёт сумму nums[start..i] без перебора
  // элементов. Именно это значение присваивается subarraySum
  // и затем аккумулируется в result.
  const prefixSums = new Int32Array(n + 1);

  // Заполняем массив префиксных сумм
  for (let i = 0; i < n; i++) {

    // Вычисляем префиксную сумму для позиции i+1 как сумму
    // предыдущей префиксной суммы и текущего элемента nums[i].
    // 
    // prefixSums[0] по умолчанию равен 0, поэтому первый шаг
    // корректно задаёт сумму первого элемента.
    //
    // prefixSums[i + 1] — это сумма всех элементов
    // nums[0..i].
    prefixSums[i + 1] = prefixSums[i] + nums[i];
  }

  // Инициализируем аккумулятор result нулём.
  // 
  // В него будем накапливать итоговую сумму всех вычисленных
  // подмассивов.
  let result = 0;

  // Проходим по каждому индексу массива nums
  //
  // Для каждого индекса i вычисляем начало подмассива и его
  // сумму
  for (let i = 0; i < n; i++) {

    // Вычисляем индекс начала подмассива start как максимум
    // между 0 и i - nums[i].
    // 
    // Это гарантирует, что start не станет отрицательным,
    // то есть подмассив не выйдет за левую границу массива.
    const start = Math.max(0, i - nums[i]);

    // Вычисляем сумму подмассива от start до i включительно
    // с помощью префиксных сумм:
    // - prefixSums[i + 1] содержит сумму элементов nums[0..i],
    //
    // - prefixSums[start] — сумму nums[0..start-1].
    //
    // Разность даёт сумму nums[start..i] за O(1).
    const subarraySum = prefixSums[i + 1] - prefixSums[start];

    // Добавляем вычисленную сумму подмассива к общему
    // результату.
    result += subarraySum;
  }

  // Возвращаем накопленный результат после обработки всех
  // индексов.
  return result;
}
