/**
 * @param {string[]} garbage
 * @param {number[]} travel
 * @return {number}
 * 
 * garbageCollection принимает 0‑индексированный массив
 * строк garbage, где garbage[i] представляет набор
 * мусора в i‑м доме. garbage[i] состоит только из
 * символов 'M', 'P' и 'G', которые обозначают одну
 * единицу металлического, бумажного и стеклянного
 * мусора соответственно. Сбор одной единицы любого
 * типа мусора занимает 1 минуту. 
 * 
 * Функция также принимает 0‑индексированный
 * целочисленный массив travel, где travel[i] — это
 * количество минут, необходимых, чтобы добраться от
 * дома i до дома i + 1. 
 * 
 * В городе есть три мусоровоза, каждый отвечает за
 * сбор одного типа мусора. Каждый мусоровоз стартует
 * из дома 0 и должен посещать дома в порядке
 * возрастания индекса, однако, им не обязательно
 * посещать каждый дом. Каждый мусоровоз может
 * останавливается, когда собрал все единицы мусора
 * своего типа.
 * 
 * В любой момент времени может работать только один
 * мусоровоз. Пока один грузовик едет или собирает
 * мусор, два других не могут ничего делать.
 * 
 * Функция возвращает минимальное количество минут,
 * необходимое, чтобы собрать весь мусор.
 * 
 * 
 * Пример для:
 *   garbage = ["G","P","GP","GG"],
 *   travel = [2,4,3] 
 * Результат:
 *   21 
 * Пояснение:
 * Мусоровоз для бумаги:
 * 1. Едет от дома 0 до дома 1 (travel[0] = 2)
 * 2. Собирает бумагу в доме 1 (1 минута)
 * 3. Едет от дома 1 до дома 2 (travel[1] = 4)
 * 4. Собирает бумагу в доме 2 (1 минута)
 * Всего для бумаги: время в пути 2 + 4 = 6 минут,
 * время на сбор 2 единиц = 2 минуты, итого 8 минут.
 * 
 * Мусоровоз для стекла:
 * 1. Собирает стекло в доме 0 (1 минута)
 * 2. Едет от дома 0 до дома 1 (travel[0] = 2)
 * 3. Едет от дома 1 до дома 2 (travel[1] = 4)
 * 4. Собирает стекло в доме 2 (1 минута)
 * 5. Едет от дома 2 до дома 3 (travel[2] = 3)
 * 6. Собирает стекло в доме 3 (1 минута)
 * Всего для стекла: время в пути 2 + 4 + 3 = 9 минут,
 * время на сбор 4 единиц = 4 минуты, итого 13 минут.
 * 
 * Мусора типа 'M' (металл) нет, поэтому мусоровоз для
 * металла не используется. 
 *
 * Общее время = 8 (бумага) + 13 (стекло) = 21 минута.
 */
function garbageCollection(garbage, travel) {

  // Получаем количество домов по длине массива garbage.
  // 
  // Используется многократно, поэтому сохраняем в
  // локальную константу.
  const n = garbage.length;

  // Создаём массив префиксных сумм длины n типа
  // Int32Array для экономии памяти и ускорения
  // операций.
  // 
  // prefixSums[i] будет хранить суммарное время пути
  // от дома 0 до дома i. 
  //
  // Пример для:
  // travel = [2,4,3]
  // - prefixSums[0] = 0(до дома 0 — 0 минут)
  // - prefixSums[1] = 0 + 2 = 2 (до дома 1 — 2 минуты)
  // - prefixSums[2] = 2 + 4 = 6 (до дома 2 — 6 минут)
  // - prefixSums[3] = 6 + 3 = 9 (до дома 3 — 9 минут)
  const prefixSums = new Int32Array(n);

  // Заполняем префиксные суммы на основе массива
  // travel, где travel[i] — время перехода от текущего
  // дома i к следующему i+1.
  // 
  // Цикл идёт по длине travel, и на каждой итерации
  // вычисляется prefixSums[i+1].
  for (let i = 0; i < travel.length; i++) {

    // Добавляет время перехода от текущего дома i к
    // следующему дому i+1 в префиксную сумму для
    // индекса i+1.
    // 
    // Это даёт возможность позже получить суммарное
    // время от дома 0 до дома i за O(1).
    //
    // - prefixSums[i] уже содержит суммарное время от
    //   дома 0 до дома i.
    //
    // - travel[i] — это время перехода от i к i+1.
    //
    // - Чтобы получить суммарное время от 0 до i+1,
    //   нужно сложить эти два значения:
    //   prefixSums[i] + travel[i].
    //
    // - Результат записывается в prefixSums[i + 1],
    //   потому что он соответствует следующему дому
    //   i+1.
    prefixSums[i + 1] = prefixSums[i] + travel[i];
  }

  // Инициализируем переменную для накопления общего
  // времени (сбор + поездка).
  let result = 0;

  // Индексы последних домов, где встречается
  // соответствующий тип мусора.
  // 
  // Изначально 0 — безопасный выбор, потому что
  // prefixSums[0] = 0 (нет пути).
  let lastMNdx = 0;
  let lastPNdx = 0;
  let lastGNdx = 0;

  // Проходим по всем домам, чтобы посчитать время на
  // сбор мусора и найти индексы последних домов для
  // каждого типа мусора.
  for (let i = 0; i < n; i++) {

    // Добавляем к результату количество единиц мусора в
    // текущем доме. 
    // 
    // Каждая буква в строке garbage[i] соответствует
    // одной единице мусора и требует 1 минуты на сбор.
    result += garbage[i].length;

    // Проверяем, содержит ли строка garbage[i] символ
    // 'M' (металлический мусор).
    // 
    // Если да, обновляем индекс последнего дома с
    // металлом 'M' на текущий i.
    if (garbage[i].includes('M')) lastMNdx = i;

    // Если в строке есть символ 'P', обновляем индекс
    // последнего дома с бумагой 'P' на текущий i.
    if (garbage[i].includes('P')) lastPNdx = i;

    // Если в строке есть символ 'G', обновляем индекс
    // последнего дома со стеклом 'G' на текущий i.
    if (garbage[i].includes('G')) lastGNdx = i;
  }

  // Добавляем к результату суммарное время поездок для
  // каждого типа мусора.
  // - prefixSums[lastMNdx] — расстояние от дома 0 до
  //   последнего дома с M,
  // 
  // - prefixSums[lastPNdx] — расстояние до последнего
  //   дома с P,
  //
  // - prefixSums[lastGNdx] — расстояние до последнего
  //   дома с G.
  // Это учитывает, что для каждого типа мусора машина
  // должна проехать только до последнего дома, где он 
  // встречается.
  // 
  // Суммирование трёх значений моделирует три отдельных
  // грузовика, которые не мешают друг другу.
  //
  // Если какой-то тип мусора не встречался,
  // соответствующий last*Ndx останется 0 и добавит 0 к
  // result.
  result += prefixSums[lastMNdx] + prefixSums[lastPNdx] + prefixSums[lastGNdx];

  // Возвращаем итоговое значение result — суммарное
  // время на сбор всего мусора и необходимые
  // перемещения.
  return result;
}
