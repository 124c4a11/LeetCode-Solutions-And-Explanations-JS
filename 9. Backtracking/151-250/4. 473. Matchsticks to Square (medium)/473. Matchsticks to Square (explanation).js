/**
 * @param {number[]} matchsticks
 * @return {boolean}
 * 
 * Makesquareя принимает на вход массив
 * длин спичек и возвращает true, если
 * из них можно составить квадрат.
 * 
 * Например:
 * при matchsticks = [1,1,2,2,2]
 * проверяем, можно ли разбить эти спички
 * на 4 равные стороны.
 * 
 * Для matchsticks = [1,1,2,2,2] функция
 * вернёт true, то есть из спичек
 * [1,1,2,2,2] можно составить квадрат,
 * потому что из них можно составить
 * четыре стороны длины 2.
 * 
 * Вот как спички распределятся по сторонам
 * (каждая должна быть длины 2):
 * - сторона 1: 2
 * - сторона 2: 2
 * - сторона 3: 2
 * - сторона 4: 1 + 1 = 2
 * Все четыре стороны получаются равными,
 * значит квадрат собрать можно.
 */
function makesquare(matchsticks) {
  // Вычисляем общую длину всех спичек.
  //
  // Для массива [1,1,2,2,2] reduce вернёт 8,
  // потому что 1+1+2+2+2 = 8.
  const totalLength =
    matchsticks.reduce((a, b) => a + b, 0);

  // Если общая длина не делится на 4 без
  // остатка, квадрат составить невозможно.
  //
  // В примере 8 % 4 = 0, значит потенциально
  // может получиться квадрат со сторонами
  // длиной 2.
  //
  // А если бы, скажем, было 9,
  // то 9 % 4 = 1 → false.
  if (totalLength % 4) return false;

  // Сортируем спички по убыванию,
  // чтобы сначала пытаться разместить самые
  // длинные, для более раннего отсева
  // неудачных вариантов
  //
  // Для [1,1,2,2,2]
  // после sort получим [2,2,2,1,1].
  matchsticks.sort((a, b) => b - a);

  // Вычисляем целевую длину каждой стороны
  // квадрата:
  //
  // Длина каждой стороны квадрата должна быть
  // равна (общая длина / 4).
  //
  // В нашем примере length = 8 / 4 = 2.
  const length = totalLength / 4;

  // Массив для накопления суммарных длин
  // текущих четырёх сторон.
  //
  // Изначально все стороны пусты:
  // sides = [0, 0, 0, 0].
  const sides = new Int32Array(4);

  // Рекурсивная функция dfs(i) пытается
  // разместить i-ю спичку в одной из сторон
  function dfs(i = 0) {

    // Базовый случай: 
    // Если мы успешно разместили все
    // спички (i дошёл до длины массива),
    // возвращаем true.
    //
    // Например:
    // если i === 5 для пяти спичек,
    // значит каждая спичка заняла нужную
    // позицию в одной из сторон.
    if (i === matchsticks.length) return true;

    // Цикл по четырём сторонам квадрата:
    // j = 0,1,2,3.
    for (let j = 0; j < 4; j++) {

      // Если добавление текущей спички
      // превысит длину текущей стороны,
      // пропускаем эту сторону.
      //
      // Если sides[j] = 1
      // и matchsticks[i] = 2,
      // то 1+2 > 2 → continue.
      if (sides[j] + matchsticks[i] > length) continue

      // Пробуем добавить i-ю спичку
      // к стороне j.
      //
      // Например:
      // для первой спички 2:
      // sides = [2,0,0,0].
      sides[j] += matchsticks[i];

      // Рекурсивно пытаемся разместить
      // следующую спичку (i+1).
      if (dfs(i + 1)) return true;

      // Если попытка не удалась,
      // откатываем добавление спички
      //
      // sides возвращается к предыдущему
      // состоянию
      //
      // Возвращаем состояние:
      // sides = [0,0,0,0] снова.
      sides[j] -= matchsticks[i];

      // Оптимизация: 
      // если после отката сторона стала
      // снова 0, значит мы пытались
      // разместить спичку на пустой стороне
      // и это не дало результата,
      // значит нет смысла пытаться разместить
      // ее на других пустых сторонах
      //
      // Пример: 
      // - Первая спичка 2 пытается встать
      //   на сторону 0: [2,0,0,0].
      // - Если дальше выясняется, что
      //   остальные спички никак не дадут
      //   полный квадрат → откат:
      //   sides[0] снова 0.
      // - Поскольку sides[0] === 0,
      //   мы выходим из цикла for (j…)
      //   и возвращаем false,
      //   не пытаясь ставить эту же длинную
      //   спичку на сторону 1, 2 или 3.
      if (sides[j] === 0) break;
    }

    // Ни одна из сторон не подошла для текущей
    // спички → возвращаем false.
    return false;
  };

  // Запускаем рекурсивную проверку
  // с первой спички (i = 0) и возвращаем
  // результат.
  // 
  // Для matchsticks = [1,1,2,2,2] функция
  // вернёт true, то есть из спичек
  // [1,1,2,2,2] можно составить квадрат,
  // потому что из них можно составить
  // четыре стороны длины 2.
  // 
  // Вот как спички распределятся по сторонам
  // (каждая должна быть длины 2):
  // - сторона 1: 2
  // - сторона 2: 2
  // - сторона 3: 2
  // - сторона 4: 1 + 1 = 2
  // Все четыре стороны получаются равными,
  // значит квадрат собрать можно.
  return dfs();
}
