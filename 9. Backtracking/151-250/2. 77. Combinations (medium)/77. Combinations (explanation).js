/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 * 
 * combine принимает два параметра:
 * n — верхняя граница натуральных чисел от 1 до n
 * k — размер каждой комбинации
 * 
 * Например:
 * combine(4, 2) вернёт все пары чисел от 1 до 4:
 * [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
 */
function combine(n, k) {

  // Инициализируем пустой массив для
  // хранения всех найденных комбинаций.
  //
  // После инициализации result пустой
  // comb ещё не используется
  //
  // comb = [], 
  // result = []
  const result = [];

  // Начало рекурсии: первый вход в dfs
  //
  // Немедленно вызываем рекурсивную
  // функцию dfs через IIFE,
  // чтобы начать генерацию комбинаций без
  // дополнительного вызова.
  //
  // dfs отвечает за построение комбинаций
  // по шагам
  //
  // start — минимальное следующее число
  //         для выбора (по умолчанию 1)
  // comb  — текущая комбинация
  //         (по умолчанию пустой массив)
  //
  // состояние:
  // start = 1,
  // comb = [],
  // result = []
  !function dfs(start = 1, comb = []) {

    // Проверка базового случая:
    // (НЕ выполняется на этом шаге)
    // comb.length (0) === k (2)? → false,
    // пропускаем ветку
    //
    // Если текущая комбинация comb достигла
    // длины k, значит, она завершена и
    // готова к добавлению в результат.
    if (comb.length === k) {

      // Добавляем копию comb в result
      //
      // Пример:
      // result.push([1, 2])
      //   → result = [[1, 2]]
      result.push([...comb]);

      return;
    }

    // Начало цикла for с i = start..n
    //
    // Первый уровень рекурсии: start = 1,
    // i будет принимать значения 1,2,3,4
    // (для n = 4)
    //
    // Перебираем все возможные следующие
    // числа от текущей позиции start до n.
    for (let i = start; i <= n; i++) {

      // Шаг для i = 1:
      // Добавляем текущее число i
      // в комбинацию
      //
      // comb.push(1)
      // comb = [1], 
      // result = []
      comb.push(i);

      // Рекурсивно вызываем dfs с
      // новым стартом i+1
      //
      // Вход в рекурсию dfs(2, [1]):
      // start = 2, 
      // comb = [1],
      // result = []
      //
      // Внутри этого вызова будут
      // формироваться пары
      // [1,2], [1,3], [1,4]
      dfs(i + 1, comb);

      // После dfs(2, [1]) вернулись сюда:
      //
      // Убираем добавленный элемент, чтобы
      // попробовать следующий вариант i + 1.
      //
      // В этот момент 
      // result = [[1, 2], [1, 3], [1, 4]]
      // comb всё ещё = [1]
      //
      //
      // Пример: после всех веток для i=1:
      //   comb внутри dfs мог побывать
      //   [1,2], [1,3], [1,4],
      //   но после pop всегда возвращается к [1],
      //   а затем к [].
      comb.pop();

      // Визуализация изменений comb и result для combine(4, 2):
      // Шаг | Действие             | start | i  | comb    | result
      // ---------------------------------------------------------------
      // 1   | вход в dfs           | 1     | —  | []      | []
      // 2   | push(1)              | 1     | 1  | [1]     | []
      // 3   | recurse dfs(2, [1])  | 2     | —  | [1]     | []
      // 4   | push(2)              | 2     | 2  | [1,2]   | []
      // 5   | save [1,2]           | —     | —  | [1,2]   | [[1,2]]
      // 6   | pop                  | —     | —  | [1]     | [[1,2]]
      // 7   | push(3)              | 2     | 3  | [1,3]   | [[1,2]]
      // 8   | save [1,3]           | —     | —  | [1,3]   | [[1,2],[1,3]]
      // 9   | pop                  | —     | —  | [1]     | [[1,2],[1,3]]
      // 10  | push(4)              | 2     | 4  | [1,4]   | [[1,2],[1,3]]
      // 11  | save [1,4]           | —     | —  | [1,4]   | [[1,2],[1,3],[1,4]]
      // 12  | pop                  | —     | —  | [1]     | [[1,2],[1,3],[1,4]]
      // (далее аналогично для веток с началом 2, 3, 4)

      // Далее внешний цикл переходит к i = 2,3,4:
      //  i=2 → comb=[2] → вложенный dfs даёт [2,3],[2,4] → comb снова=[]
      //  i=3 → comb=[3] → вложенный dfs даёт [3,4]       → comb снова=[]
      //  i=4 → comb=[4] → вложенный dfs не даёт новых    → comb снова=[]
      // К моменту окончания цикла:
      // comb = [],
      // result = [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]

      // Визуализация работы рекурсии для combine(4,2):
      // 1) dfs(1, [])
      //    comb = [], result = []
      //    for i = 1..4:
      //      i = 1 → comb.push(1) → comb = [1], result = []
      //        dfs(2, [1]):
      //          for j = 2..4:
      //            j = 2 → comb = [1,2], result = []
      //              comb.length === k → push → result = [[1,2]]
      //              pop → comb = [1]
      //            j = 3 → comb = [1,3], result = [[1,2]]
      //              push → result = [[1,2],[1,3]]
      //              pop → comb = [1]
      //            j = 4 → comb = [1,4], result = [[1,2],[1,3]]
      //              push → result = [[1,2],[1,3],[1,4]]
      //              pop → comb = [1]
      //          pop (возврат) → comb = []
      //
      //      i = 2 → comb = [2], result = [[1,2],[1,3],[1,4]]
      //        dfs(3, [2]):
      //          for j = 3..4:
      //            j = 3 → comb = [2,3], result = [[1,2],[1,3],[1,4]]
      //              push → result = [[1,2],[1,3],[1,4],[2,3]]
      //              pop → comb = [2]
      //            j = 4 → comb = [2,4], result = [[1,2],[1,3],[1,4],[2,3]]
      //              push → result = [[1,2],[1,3],[1,4],[2,3],[2,4]]
      //              pop → comb = [2]
      //          pop → comb = []
      //
      //      i = 3 → comb = [3], result = [[1,2],[1,3],[1,4],[2,3],[2,4]]
      //        dfs(4, [3]):
      //          j = 4 → comb = [3,4], result = [[1,2],[1,3],[1,4],[2,3],[2,4]]
      //            push → result = [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
      //            pop → comb = [3]
      //          pop → comb = []
      //
      //      i = 4 → comb = [4], result = [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
      //        dfs(5, [4]) – цикл не выполняется, pop → comb = []
      //
    }
  }();

  // По завершении всех ветвей:
  // result = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
  return result;
}
