/**
 * @param {number[]} nums
 * @return {number}
 */
function subsetXORSum(nums) {
  // Инициализируем result нулем.
  let result = 0;

  // Проходим по каждому числу
  // num в массиве nums.
  for (let num of nums) {
    // На первой итерации num = 1:
    //   result до операции = 0
    //   result |= 1 
    //     → result становится 1 (0 OR 1 = 1)
    //
    // На второй итерации num = 2:
    //   result до операции = 1 (0b01)
    //   result |= 2 
    //     → result становится 3 (0b01 OR 0b10 = 0b11)
    //
    // На третьей итерации num = 3:
    //   result до операции = 3 (0b11)
    //   result |= 3
    //     → result остаётся 3 (0b11 OR 0b11 = 0b11)
    result |= num;
  }

  // После цикла result = 3 (0b11) — это побитовое
  // OR всех элементов.
  // Длина массива n = 3,
  // общее число подмножеств = 2^3 = 8.
  //
  // Каждый бит из result участвует в XOR-сумме
  // ровно в половине подмножеств:
  // 2^(n−1) = 2^2 = 4 раза. Сдвиг влево на
  // (n−1) == умножение на 4.
  //
  // Почему именно (n − 1)?
  // Для массива длины n каждый «1»-бит будет учтён
  // во всех подмножествах, и суммарный эффект даёт
  // умножение на число подмножеств без этого элемента,
  // то есть 2^(n−1).
  //
  // Вычисление:
  // 3 << 2 = 3 * 4 = 12 — это и есть итоговая сумма.
  //
  // Для наглядности полный список подмножеств
  // и их XOR:
  //   []        → 0
  //   [1]       → 1
  //   [2]       → 2
  //   [3]       → 3
  //   [1,2]     → 1 ^ 2 = 3
  //   [1,3]     → 1 ^ 3 = 2
  //   [2,3]     → 2 ^ 3 = 1
  //   [1,2,3]   → 1 ^ 2 ^ 3 = 0
  // Сумма всех этих значений: 
  // 0 + 1 + 2 + 3 + 3 + 2 + 1 + 0 = 12
  return result << (nums.length - 1);
}
