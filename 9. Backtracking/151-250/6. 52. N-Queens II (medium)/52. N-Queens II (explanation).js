/**
 * @param {number} n
 * @return {number}
 * 
 * totalNQueens принимающей число n
 * — размер доски n×n и возвращает
 * количество способов расставить n ферзей
 * на доске n×n так, чтобы они не били
 * друг друга.
 * 
 * Пример: 
 * totalNQueens(4) вернет 2.
 */
function totalNQueens(n) {

  // Создаем массив cols длины n для
  // отслеживания занятых столбцов.
  // cols[c] === true означает,
  // что в столбце c уже стоит ферзь.
  //
  // При инициализации все элементы
  // undefined (false-подобные)
  const cols = new Array(n);

  // Создаем массив posDiag длины 2*n
  // для диагоналей с положительным
  // наклоном (r+c) "\".
  //
  // posDiag[d] === true означает,
  // что диагональ с индексом d занята.
  //
  // Пример при n=4:
  // индексы r+c могут принимать значения
  // от 0 до 6, posDiag = Array(8)
  //
  // ---
  //
  // Причина выбора длины n*2 для
  // массивов диагоналей
  //
  //  1. Как мы нумеруем диагонали  
  // На шахматной доске размером n×n
  // у каждой клетки (r, c) есть две
  // характеристики диагонали:  
  // - Положительная диагональ определяется
  //   суммой индексов r+c.  
  // - Отрицательная диагональ определяется
  //   разностью r−c (со знаком) и
  //   дополнительно сдвигается на n, чтобы
  //   получить неотрицательный индекс.
  //
  // 2. Диапазон значений для posDiag (r+c)  
  // - Минимальное значение:  
  //   - r=0, c=0 → r+c = 0  
  // - Максимальное значение:  
  //   - r=n−1, c=n−1 → r+c=2(n−1)  
  // - Всего возможных различных сумм:  
  //   - от 0 до 2n−2 включительно
  //     → 2n−1 значений  
  // - Выделяем массив длины 2n,
  //   а не ровно 2n−1, чтобы:  
  //   - Индекс "2n−1" тоже был в пределах
  //     массива (хоть он и не используется).  
  //   - Упростить вычисления: не нужно
  //     постоянно вычитать или прибавлять "−1"
  //     при проверке границ.
  //
  // 3. Диапазон значений для negDiag (r−c+n)  
  // - Вычисляем базовую разность: r−c  
  //   - Минимум: r=0, c=n−1 → r−c = −(n−1)  
  //   - Максимум: r=n−1, c=0 → r−c= n−1  
  // - Чтобы убрать отрицательные индексы,
  //   прибавляем n:  
  //   - Диапазон (r−c+n) от 1
  //     до 2n−1 включительно  
  // - Всего возможных значений:  
  //   - от −(n−1) до (n−1) → 2n−1
  //     вариантов после сдвига  
  // - Снова проще выделить массив длины 2n,
  //   чтобы в него «влезли» индексы от 0 до 2n−1.
  //
  // ---
  //
  // Иллюстрация на примере n = 4
  //
  // | r | c | r + c | r − c | r − c + 4 |
  // |---|---|-------|-------|-----------|
  // | 0 | 0 | 0     | 0     | 4         |
  // | 0 | 3 | 3     | −3    | 1         |
  // | 2 | 1 | 3     | 1     | 5         |
  // | 3 | 3 | 6     | 0     | 4         |
  //
  // - Для posDiag возможны суммы
  //   0,1,2,3,4,5,6 → всего 7 значений.
  //   Массив длины 8 (2*4) покрывает индексы 0…7.  
  // - Для negDiag (r−c+4) возможны значения
  //   1,2,3,4,5,6,7 → всего 7 значений.
  //   Массив длины 8 покрывает индексы 0…7.
  //
  // Таким образом, new Array(n*2) гарантирует,
  // что любая диагональ, вычисленная по формулам
  // r+c или r−c+n, попадёт в границы массива
  // без дополнительных проверок или смещений.
  const posDiag = new Array(n * 2);

  // Создаем массив negDiag длины 2*n
  // для диагоналей с отрицательным
  // наклоном (r-c+n) "/".
  //
  // negDiag[d] === true означает, 
  // что диагональ с индексом d занята.
  //
  // Пример при n=4 и r=1, c=3:
  // индекс = 1-3+4=2
  const negDiag = new Array(n * 2);

  // Инициализируем счетчик найденных решений.
  let result = 0;

  // Немедленно-вызываемая рекурсивная
  // функция dfs для обхода рядов.
  //
  // Начинает с r = 0 (первый ряд).
  !function dfs(r = 0) {

    // Базовый случай:
    // если мы вышли за последний ряд
    // (r === n), значит расставили всех
    // ферзей найдено и допустимое решение
    //
    // Увеличиваем количество решений на 1.
    // Возвращаемся к предыдущему уровню
    // рекурсии для поиска новых вариантов.
    if (r === n) {
      result++;
      return;
    }

    // Перебираем все столбцы c в текущем
    // ряду r.
    for (let c = 0; c < n; c++) {

      // Проверяем, свободна ли клетка (r,c):
      // - нет ли уже ферзя в том же столбце
      //   cols[c]
      // - нет ли ферзя на диагонали "\"
      //   posDiag[r+c]
      // - нет ли ферзя на диагонали "/"
      //   negDiag[r-c+n]
      // Если хоть одно условие истинно,
      // переходим к следующему столбцу.
      if (
        cols[c]
        || posDiag[r + c]
        || negDiag[r - c + n]
      ) continue;

      // Помечаем столбец c занятым.
      cols[c] = true;

      // Помечаем положительную диагональ "\"
      // r+c занятой.
      posDiag[r + c] = true;

      // Помечаем отрицательную диагональ "/"
      // r-c+n занятой.
      negDiag[r - c + n] = true;

      // Рекурсивно пытаемся разместить ферзя
      // в следующем ряду
      dfs(r + 1);

      // Откат:
      // удаляем ферзя с (r,c), освобождаем
      // столбец и диагонали для других
      // вариантов.
      cols[c] = false;
      posDiag[r + c] = false;
      negDiag[r - c + n] = false;
    }
  }();

  // После завершения DFS возвращаем общее число
  // найденных решений для доски размера n×n.
  return result;
}
