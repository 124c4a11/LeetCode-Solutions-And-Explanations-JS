/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 * 
 * Определяем функцию для проверки,
 * можно ли разделить массив nums
 * на k подмножеств с равной суммой
 * 
 * Пример:
 * для nums = [2,4,1,3,5]
 * и k = 3
 * функция вернет true, так как 
 * nums можно разбить на следующие
 * подмножества
 * [5], [2,3], [4,1]
 */
function canPartitionKSubsets(nums, k) {

  // Вычисляем общую сумму элементов
  // массива nums
  //
  // Для [2,4,1,3,5] это 2+4+1+3+5 = 15
  const sum = nums.reduce((a, b) => a + b, 0);

  // Если общая сумма не делится на k
  // без остатка, равное разбиение
  // невозможно
  //
  // В примере:
  // 15 % 3 = 0, делится без остатка
  // (условие ложно) - мы продолжаем
  if (sum % k) return false;

  // Определяем, какой должна быть
  // сумма каждого подмножества
  //
  // В примере:
  // target = 15 / 3 = 5
  const target = sum / k;

  // Сортируем nums по убыванию, чтобы
  // сначала использовать большие числа
  // и ускорить отсечение ненужных 
  // веток
  // 
  //: [5,4,3,2,1]
  nums.sort((a, b) => b - a);


  // Если наибольший элемент в nums
  // превышает target, разбиение
  // невозможно 
  //
  // В примере:
  // nums[0] = 5, равно target = 5,
  // условие ложно - мы продолжаем
  if (nums[0] > target) return false;

  // Запоминаем длину массива для
  // использования в циклах
  //
  // В примере n = 5
  const n = nums.length;

  // Массив visited для пометки уже
  // использованных в подмножествах
  // элементов
  //
  // Изначально все значения undefined
  // (в проверках falsey), позже будем
  // устанавливать true
  const visited = new Array(n);

  // Рекурсивная функция dfs:
  // i — индекс, с которого будем
  //     искать следующий элемент;
  // k — сколько ещё подмножеств
  //     нужно сформировать;
  // subsetSum — текущая сумма
  //     собираемого подмножества
  function dfs(i, k, subsetSum) {

    // Базовый случай:
    // если осталось собрать 0 подмножеств,
    // значит все предыдущие собраны успешно
    if (k === 0) return true;

    // Как только текущая сумма равна target,
    // начинаем собирать следующее подмножество
    //
    // Например:
    // subsetSum = 5 
    // -> переходим к dfs(0, k-1, 0)
    //
    // ---
    //
    // Пояснение сброса индекса i
    // и суммы subsetSum
    //
    // Когда текущая сумма subsetSum достигла
    // целевого значения target, мы фактически
    // "закрыли" одно подмножество и должны
    // приступить к формированию следующего.
    //
    // делает именно это:
    // - Сбрасывает subsetSum на 0, чтобы начать
    //   накапливать новую группу чисел с нуля.  
    // - Возвращает индекс i в 0, чтобы снова
    //   пройти по всем элементам массива, но
    //   благодаря флагам visited мы не затронем
    //   уже использованные ранее числа.  
    // - Уменьшает счётчик оставшихся групп k
    //   на 1 — мы уже успешно сформировали одну
    //   группу, значит осталось ещё k - 1.
    //
    // ---
    //
    // Почему значения не будут переиспользоваться
    //
    // 1. Флаги visited  
    //    Даже если мы начинаем перебор с j = 0,
    //    все позиции, которые были отмечены как
    //    visited[j] = true, при проверке  
    //    будут пропущены. Это гарантирует, что
    //    элемент окажется только в одном
    //    подмножестве.
    //
    // 2. Сброс только индекса, а не флага  
    //    Сброс i не "отпускает" уже поставленные
    //    метки visited[j]. Мы лишь начинаем заново
    //    сканировать массив, чтобы найти
    //    неиспользованные числа, которые войдут в
    //    новое подмножество.
    //
    // 3. Избежание дублирования  
    //    Благодаря комбинации сброса индекса и
    //    фиксированному флагу visited, каждая цифра
    //    попадёт ровно в одну группу. Никаких
    //    повторных вставок из одного и того же
    //    индекса не произойдёт.
    if (subsetSum === target) {
      return dfs(0, k - 1, 0);
    }

    // Перебираем оставшиеся элементы массива,
    // начиная с индекса i.
    for (let j = i; j < n; j++) {

      // Пропускаем элемент, если он уже
      // использован или его добавление
      // превысит target
      if (
        visited[j]
        || subsetSum + nums[j] > target
      ) continue;

      // Отмечаем nums[j] как использованный
      visited[j] = true;

      // Рекурсивно пытаемся добавить nums[j]
      // к текущему подмножеству
      // и сформировать нужное подмножество
      //
      // Если в глубине вызовов мы получим
      // true, сразу возвращаем true.
      if (dfs(j + 1, k, subsetSum + nums[j])) return true;

      // Если путь не завершился успехом,
      // откатываем выбор
      visited[j] = false;

      // Оптимизация:
      // Если мы не смогли добавить первый
      // элемент в абсолютно пустое
      // подмножество, значит дальнейшие
      // попытки с другими j
      // при subsetSum=0 бессмысленны
      //
      // Привязка не к
      // "первому элементу всего алгоритма",
      // а к первой попытке в каждом новом
      // подмножестве (subsetSum === 0)
      if (!subsetSum) return false;
    }

    // Если не удалось подобрать комбинацию
    // для текущего подмножества,
    // возвращаем false
    return false;
  };

  // Начинаем поиск: 
  // стартуем с индекса 0,
  // k подмножеств и начальной суммы 0
  // и возвращаем результат работы
  // функции dfs
  //
  // В примере DFS найдёт такие группы:
  // [5], [4,1], [3,2]
  // и вернет true
  return dfs(0, k, 0);
}