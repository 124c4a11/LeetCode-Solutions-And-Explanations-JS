/**
 * @param {number[]} nums
 * @return {number[][]}
 * 
 * permuteUnique генерирует все уникальные
 * перестановки входного массива nums 
 * с пропуском дубликатов.
 * 
 * Например, при вызове permuteUnique([1,2,1])
 * ожидается результат:
 * [
 *   [1,1,2],
 *   [1,2,1],
 *   [2,1,1]
 * ]
 */
function permuteUnique(nums) {

  // Сортируем входной массив,
  // чтобы одинаковые элементы оказались рядом.
  //
  // Это упрощает логику пропуска дубликатов в
  // дальнейшем.
  //
  // Пример:
  // из [1,2,1] получим [1,1,2].
  nums.sort((a, b) => a - b);

  // Сохраняем длину массива nums в переменную n
  // для многократного использования.
  //
  // В нашем примере n = 3.
  const n = nums.length;

  // Создаем массив result для накопления всех
  // уникальных перестановок.
  //
  // После выполнения dfs здесь будут лежать
  // вложенные массивы вида 
  // [[1,1,2], [1,2,1], [2,1,1]].
  const result = [];

  // Массив perm будет представлять текущую
  // перестановку в процессе глубинного поиска.
  //
  // Он заполняется и очищается на каждом
  // уровне рекурсии.
  const perm = [];

  // Булев массив visit отмечает, был ли
  // элемент nums[i] уже включен в perm.
  //
  // Изначально все элементы не посещены:
  // visit = [undefined, undefined, undefined],
  // но в логике мы будем считать undefined
  // как false.
  const visit = new Array(n);

  // Немедленно-вызываемая функция dfs реализует
  // рекурсивный перебор вариантов.
  //
  // [Вход в dfs] 
  // perm = [], 
  // visit = [false,false,false], 
  // result = []
  !function dfs() {

    // Базовый случай рекурсии: когда perm достиг
    // длины n, это готовая перестановка.
    //
    // Кладем в result копию perm, чтобы
    // дальнейшие изменения perm не затронули
    // сохраненную копию.
    if (perm.length === n) {

      // [Запись результата]
      // perm = [1,1,2] → result = [[1,1,2]]
      // perm = [1,2,1] → result = [[1,1,2],[1,2,1]]
      // perm = [2,1,1] → result = [[1,1,2],[1,2,1],[2,1,1]]
      result.push([...perm]);

      // Завершаем текущий путь рекурсии,
      // возвращаемся к предыдущему уровню
      return;
    }

    // Перебираем все индексы массива nums
    for (let i = 0; i < n; i++) {

      // Условие пропуска:
      // 1) visit[i] === true — элемент уже
      //    включен в текущую перестановку.
      // 2) nums[i] === nums[i - 1] и предыдущий
      //    равный элемент еще не использован
      //    (!visit[i - 1]):
      //    это гарантирует, что мы не возьмем
      //    второй из двух одинаковых элементов
      //    раньше первого, тем самым избегаем
      //    дубликатов.
      //
      // Подробный разбор условия:
      //
      // if (
      //   visit[i] ||
      //   (
      //      i > 0 
      //      && nums[i] === nums[i - 1]
      //      && !visit[i - 1]
      //    )
      // ) continue;
      //
      // 1. visit[i]  
      //   - Гарантирует, что мы не возьмём элемент
      //     дважды в одной перестановке.  
      //   - Если visit[i] === true, значит nums[i]
      //     уже лежит в perm, и мы сразу пропускаем
      //     этот индекс.
      //
      // 2. (
      //       i > 0 
      //       && nums[i] === nums[i - 1]
      //       && !visit[i - 1]
      //    )  
      //   - Разбиваем на подпункты:
      //
      //   a. i > 0  
      //      - проверяем, что у текущего элемента
      //        есть «сосед-предыдущий». Без этого
      //        нельзя обращаться к nums[i - 1].
      //
      //   b. nums[i] === nums[i - 1]  
      //      - текущий элемент повторяет предыдущий
      //        (массив уже отсортирован, дубликаты
      //        идут подряд).
      //
      //   c. !visit[i - 1]  
      //      — предыдущий дубликат ещё не включён в
      //        perm на текущем уровне.
      //        Гарантирует, что мы ещё не использовали
      //        предыдущий элемент-"двойник" в этой
      //        ветке рекурсии. То есть, если
      //        предыдущий равный элемент всё ещё
      //        свободен и взять текущий, то это приведёт
      //        к генерации тех же перестановок,
      //        но в другом порядке.
      //
      //        Это условие пропуска !visit[i - 1]
      //        сработает для второго (i = 1) именно тогда,
      //        когда первая ветка рекурсии с nums[0] = 1
      //        полностью "откатится" и мы сбросим
      //        visit[0] = false.
      //  
      //        Это означает, что из этой ветки уже
      //        сгенерированы все уникальные перестановки,
      //        начинающиеся с этого конкретного
      //        nums[0] = 1 → result = [[1,1,2]].
      //        После этого алгоритм вернётся
      //        на уровень 0 и при i = 1 встретит проверку
      //        дубликата, пропустит второй nums[1] = 1 и
      //        перейдёт к i = 2, чтобы обработать остальные
      //        варианты.
      //
      // Когда вы видите проверку  
      // if (i > 0
      //     && nums[i] === nums[i - 1]
      //     && !visit[i - 1]
      // ) continue;
      //
      // она смотрит не на visit[i],
      // а именно на visit[i-1]. То есть, когда
      // вы на текущей итерации берёте i = 1,
      // код спрашивает: "А использовали ли мы уже
      // элемент с индексом 0?" — и если нет,
      // то пропускает этот повторяющийся элемент.
      //
      // Почему же при входе в ветку с i = 1 бывает
      // visit[0] === false, хоть вы и ставите
      // перед рекурсией visit[i] = true?
      // Ответ кроется в механизме backtracking:
      //
      // В этой строке ключевым является то,
      // что visit отражает состояние 
      // "на данном уровне рекурсии",
      // а не "раз и навсегда". Как только вы
      // выходите из рекурсивного вызова для i = 0,
      // вы сразу же откатываете изменения:
      //
      // 1. В корневом вызове dfs() (уровень 0)
      //    все флаги visit  изначально false.
      //    visit = [false, false, false]
      //
      // 2. Первая итерация корня:  
      //    - i = 0,
      //      ставим visit[0] = true,
      //      уходим в рекурсивный dfs (уровень 1).
      //      генерим все перестановки,
      //      где первый элемент — nums[0].  
      //      visit = [true, false, false]
      //    - По возвращении из рекурсии выполняем
      //      visit[0] = false
      //      и perm.pop(),
      //      чтобы "откатиться" и попробовать
      //      следующий i.
      //      visit = [false, false, false]
      //
      // 3. Теперь снова в корне (уровень 0),
      //    но уже после  полного обхода ветки i = 0
      //    у нас снова
      //    visit = [false, false, false].
      //
      // 4. Следующая итерация корня — i = 1 (уровень 0).
      //    Мы смотрим на соседний предыдущий элемент
      //    (индекс 0):  
      //    - nums[1] === nums[0] (оба 1),  
      //    - visit[0] сейчас false
      //      (мы ведь только что его обнулили).  
      //    - Значит условие дублирования срабатывает,
      //      nums[1] === nums[0] и !visit[0] === true
      //      и мы пропускаем i = 1, чтобы не получить
      //      тот же набор элементов в другом порядке.
      //
      // Иными словами, visit[i] = true влияет
      // только на текущий индекс i, а нe предыдущий
      // элемент visit[i-1] этот приём не меняет.
      // А благодаря тому, что после каждого полного
      // спуска рекурсия снимает все метки 
      // visit[...] = false, к моменту проверки
      // дубликата в корне отдыхающий флаг visit[0]
      // действительно будет false.
      //
      // Когда все три условия истинны,
      // мы пропускаем nums[i].  
      //
      // Зачем так?  
      // - Представьте два одинаковых элемента
      //   1a и 1b.  
      // - В начале perm = [], ни один из них
      //   не взят (visit = [false, false]).  
      // - Если мы сначала возьмём 1b (i=1),
      //   а потом 1a, то получится такая же
      //   перестановка, как если бы мы сначала
      //   взяли 1a, потом 1b.  
      // - Чтобы не получить дубли, мы запрещаем
      //   "перехватить" второй дубликат до того,
      //   как будет взят первый.  
      //
      // Вместе это условие отбрасывает вариант,
      // когда мы пытаемся сначала взять "правый"
      // из двух одинаковых элементов, а "левый"
      // оставить на потом.
      //
      // Без этой проверки в корне рекурсии
      // для [1,1,2] мы бы сгенерировали две
      // одинаковые ветки:  
      //  - сначала взять nums[0] = 1,
      //    потом nums[1] = 1
      //    → даст [1,1,2]  
      //  - потом взять nums[1] = 1,
      //    потом nums[0] = 1
      //    → снова [1,1,2]
      //
      // Проверка не позволит
      // при perm = []
      // и visit = [false,false,false]
      // взять сначала nums[1],
      // потому что nums[1] === nums[0]
      // и visit[0] === false. 
      //
      // Итог:
      // в любой момент из группы
      // одинаковых элементов мы можем взять
      // только самый первый ещё не использованный.
      // Это и гарантирует уникальность
      // получаемых перестановок.
      //
      // Пример: 
      // nums = [1,1,2],
      // i=1,
      // nums[1]===nums[0],
      // но visit[0]===false,
      // пропускаем этот i, потому что обработаем
      // вариант с первым «1» раньше.
      if (
        visit[i]
        || (
          i > 0
          && nums[i] === nums[i - 1]
          && !visit[i - 1]
        )
      ) continue;

      // Отмечаем nums[i] как использованный,
      // чтобы не брать его повторно в perm.
      //
      // [Действие] 
      // visit[0] = true → visit = [true,false,false]
      visit[i] = true;

      // Добавляем текущий элемент в конец perm.
      //
      // [Действие]
      // perm.push(1) → perm = [1]
      perm.push(nums[i]);

      // Рекурсивно вызываем dfs для продолжения
      // построения перестановки.
      //
      // → вход во второй уровень DFS:
      // perm=[1],
      // visit=[true,false,false]
      dfs();
      // ← возврат из dfs:
      // продолжаем после глубинного обхода

      // По возврату из глубины снимаем отметку
      // использования с nums[i], чтобы
      // попробовать другие варианты на том же
      // уровне рекурсии.
      //
      // [Откат]:
      // visit[0] = false → visit = [false,false,false]
      visit[i] = false;

      // Убираем последний добавленный элемент из perm,
      // откатывая perm к состоянию до вызова dfs().
      //
      // [Откат] 
      // perm = [1] → perm.pop() → perm = []
      perm.pop();
    }

    // Шаги выполнения permuteUnique([1, 1, 2]):
    //
    // Шаг | Операция                                  | perm      | visit                   | result
    // ----|-------------------------------------------|-----------|-------------------------|-----------------------------
    // 0   | старт функции                             | []        | [false, false, false]   | []
    // 1   | dfs depth 0, выбираем i = 0               | [1]       | [true, false, false]    | []
    // 2   | dfs depth 1, выбираем i = 1               | [1,1]     | [true, true, false]     | []
    // 3   | dfs depth 2, выбираем i = 2               | [1,1,2]   | [true, true, true]      | []
    // 4   | достигнут базовый случай, добавляем       | [1,1,2]   | [true, true, true]      | [[1,1,2]]
    // 5   | откат последнего шага (pop и visit=false) | [1,1]     | [true, true, false]     | [[1,1,2]]
    // 6   | dfs depth 1, продолжаем, i = 2            | [1,2]     | [true, false, true]     | [[1,1,2]]
    // 7   | dfs depth 2, выбираем i = 1               | [1,2,1]   | [true, true, true]      | [[1,1,2]]
    // 8   | базовый случай, добавляем                 | [1,2,1]   | [true, true, true]      | [[1,1,2], [1,2,1]]
    // 9   | откатываем до depth 0                     | []        | [false, false, false]   | [[1,1,2], [1,2,1]]
    // 10  | dfs depth 0, i = 1 — пропускаем (дубликат)| []        | [false, false, false]   | [[1,1,2], [1,2,1]]
    // 11  | dfs depth 0, i = 2                        | [2]       | [false, false, true]    | [[1,1,2], [1,2,1]]
    // 12  | dfs depth 1, i = 0                        | [2,1]     | [true, false, true]     | [[1,1,2], [1,2,1]]
    // 13  | dfs depth 2, i = 1                        | [2,1,1]   | [true, true, true]      | [[1,1,2], [1,2,1]]
    // 14  | базовый случай, добавляем                 | [2,1,1]   | [true, true, true]      | [[1,1,2], [1,2,1], [2,1,1]]
    // 15  | финальный откат, готово результатом       | []        | [false, false, false]   | [[1,1,2], [1,2,1], [2,1,1]]
  }();

  // После полного перебора возвращаем массив
  // всех уникальных перестановок.
  //
  // result = [
  //   [1, 1, 2],
  //   [1, 2, 1],
  //   [2, 1, 1]
  // ]
  return result;
}
