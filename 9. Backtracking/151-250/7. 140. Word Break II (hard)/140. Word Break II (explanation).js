// Класс TrieNode представляет
// один узел префиксного дерева (Trie)
//
// Каждый узел хранит ссылки на детей
// по символам и флаг конца слова
class TrieNode {
  constructor() {

    // Объект children хранит пары
    // «символ → TrieNode»,
    // позволяющие расширять дерево
    this.children = new Map();

    // Флаг isEndOfWord сигнализирует,
    // что путь от корня до этого узла
    // составляет полное слово
    this.isEndOfWord = false;
  }
}

// Класс Trie реализует саму структуру
// префиксного дерева для набора слов,
// позволяющего добавлять слова
// и осуществлять поиск префиксов
class Trie {
  constructor() {

    // Корень, от которого начинаются
    // все возможные пути по символам
    //
    // Корень Trie всегда существует,
    // но не соответствует ни одному
    // символу
    this.root = new TrieNode();
  }

  /**
   * @param {string} word
   * @return {void}
   * 
   * Метод addWord добавляет слово в
   * префиксное дерево: идет по символам,
   * создавая новые узлы по мере
   * необходимости и ставя флаг в конце
   * слова.
   */
  addWord(word) {

    // curr указывает на текущий узел
    // (начнём с корня)
    let curr = this.root;

    // Проходим по каждому символу
    // вставляемого слова
    for (const char of word) {

      // Если для текущего символа
      // ещё нет ветви – создаём
      // новый узел
      if (!curr.children.has(char)) {
        curr.children.set(char, new TrieNode());
      }

      // Переходим к новому или
      // уже существующему узлу
      curr = curr.children.get(char);
    }

    // Если текущий символ является
    // окончанием слова,
    // помечаем узел как «конец слова»
    curr.isEndOfWord = true;
  }
}

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 * 
 * Функция wordBreak принимает строку s
 * и массив слов wordDict и возвращает
 * все возможные предложения, которые
 * можно получить, полностью разбив
 * строку s на слова из wordDict при 
 * помощи пробелов.
 * 
 * Пример:
 * s = "catsanddog"
 * wordDict =
 * ["cat", "cats", "and", "sand", "dog"]
 * 
 * Результат:
 * ["cats and dog", "cat sand dog"]
 */
function wordBreak(s, wordDict) {
  const n = s.length;

  // Создаем структуру Trie для быстрого
  // поиска слов по префиксу.
  //
  // После этого можно за O(L) найти все
  // слова из словаря длины L
  //
  // Trie после добавления
  // ["cat", "cats", "and", "sand", "dog"]:
  //
  // root
  // ├─ c
  // │  └─ a
  // │     └─ t (end of "cat")
  // │        └─ s (end of "cats")
  // ├─ a
  // │  └─ n
  // │     └─ d (end of "and")
  // ├─ s
  // │  └─ a
  // │     └─ n
  // │        └─ d (end of "sand")
  // └─ d
  //    └─ o
  //       └─ g (end of "dog")
  //
  const trie = new Trie();
  for (const word of wordDict) {
    trie.addWord(word);
  }

  // dp хранит результаты backtrack для
  // каждой стартовой позиции i
  //
  // Ключ – индекс в строке s,
  // значение – массив возможных фраз от
  // этой позиции
  //
  // Например:
  // dp.get(4)
  // для s="cats[a]nddog"
  // может быть ["and dog"]
  const dp = new Map();

  // Рекурсивная функция, возвращает все
  // предложения, начиная с позиции i.
  function backtrack(i = 0) {

    // Базовый случай:
    // если i === s.length, значит мы
    // дошли до конца строки и успешно
    // разбили всю строку,
    // возвращаем [""] — пустая строка
    // нужна для корректного объединения
    // слов без лишнего пробела.
    if (i === n) return [''];

    // Если для этой позиции i уже
    // вычисляли результат, возвращаем
    // его, избегая повторных вычислений
    if (dp.has(i)) return dp.get(i);

    // Здесь будем накапливать все
    // возможные предложения,
    // начинающиеся с позиции i.
    const result = [];

    // Начинаем обход Trie от корня,
    // чтобы искать слова-приставки в s
    // начиная с i.
    let curr = trie.root;

    // Проходим по символам строки,
    // расширяя префикс от i до j
    for (let j = i; j < n; j++) {
      const char = s[j];

      // Если в текущем узле Trie нет потомка
      // с таким символом, остановка – дальше
      // нет совпадений
      if (!curr.children.has(char)) break;

      // Опускаемся глубже в Trie
      curr = curr.children.get(char);

      // Если это не конец слова, продолжаем
      // строить более длинный префикс.
      if (!curr.isEndOfWord) continue;

      // Когда мы находим в строке s слово,
      // завершающееся в позиции j (то есть
      // текущий узел Trie помечен как
      // isEndOfWord), мы хотим соединить это
      // слово с остальными возможными
      // разбиениями суффикса, начинающегося
      // в позиции j + 1.
      //
      // ---
      //
      // Основная идея цикла  
      // Этот цикл перебирает все фрагменты
      // (суффиксы), которые возвращаются
      // рекурсивным вызовом backtrack(j + 1).
      // - Каждый элемент suffix — это одна из
      //   возможных строк, собранных из остатка
      //   s начиная с позиции j+1, которые
      //   возвращает backtrack(j + 1)
      //
      //   Каждая такая строка представляет собой
      //   полную разбивку остатка исходной
      //   строки s (начиная с позиции j+1)
      //   на слова из словаря, разделённые
      //   пробелами.
      //
      //   Если оставшаяся часть s может быть
      //   разбита на несколько слов, suffix будет
      //   содержать все эти слова через пробел,
      //   например "sand dog".
      //
      //   Когда мы дошли до конца строки
      //   (i === s.length), backtrack возвращает
      //   массив [''], и в этом случае suffix
      //   равен пустой строке, что означает
      //   отсутствие дополнительных слов.
      //
      // - Внутри цикла мы соединяем текущий
      //   префикс s.slice(i, j+1) с каждым таким
      //   suffix.
      // - Таким образом строятся полные
      //   предложения: сначала слово из позиции
      //   i … j, затем пробел (если есть суффикс)
      //   и остаток строки.
      //   Пример: 
      //   "cat" + " sand dog" → "cat sand dog"
      // 
      // ---
      // 
      // Пошаговая визуализация для s = "catsanddog",
      // wordDict = ["cat","cats","and","sand","dog"]
      // 
      // Мы вызываем wordBreak("catsanddog", wordDict),
      // внутри — backtrack(0).
      // 
      //   
      // backtrack(0)               // i = 0, s[i..] = "catsanddog"  
      //  ├─ j = 0–1: нет конца слова  
      //  ├─ j = 2: префикс = "cat"  
      //  │    └─ вызов backtrack(3) // оставшаяся строка s[3..] = "sanddog"  
      //  │         ├─ j=3–5: нет конца слова  
      //  │         ├─ j = 6: префикс = "sand"  
      //  │         │    └─ вызов backtrack(7) // s[7..] = "dog"  
      //  │         │         ├─ j=7–8: нет конца слова  
      //  │         │         ├─ j = 9: префикс = "dog"  
      //  │         │         │    └─ вызов backtrack(10) // i===s.length → ['']  
      //  │         │         └─ цикл по суффиксам ['']  
      //  │         │              → добавляем "dog"  
      //  │         │         возвращает ["dog"]  
      //  │         │  
      //  │         └─ цикл по суффиксам ["dog"]  
      //  │              → добавляем "sand dog"  
      //  │         возвращает ["sand dog"]  
      //  │  
      //  │    └─ цикл по суффиксам ["sand dog"]  
      //  │         → добавляем "cat sand dog"  
      //  │    возвращает ["cat sand dog"]  
      //  │  
      //  ├─ j = 3: префикс = "cats"  
      //  │    └─ вызов backtrack(4) // s[4..] = "anddog"  
      //  │         ├─ j=4–5: нет конца слова  
      //  │         ├─ j = 6: префикс = "and"  
      //  │         │    └─ вызов backtrack(7) // уже известен результат → ["dog"]  
      //  │         └─ цикл по суффиксам ["dog"]  
      //  │              → добавляем "and dog"  
      //  │         возвращает ["and dog"]  
      //  │  
      //  │    └─ цикл по суффиксам ["and dog"]  
      //  │         → добавляем "cats and dog"  
      //  │    возвращает ["cats and dog"]  
      //  │  
      //  └─ итог backtrack(0): объединяем все варианты  
      //       ["cat sand dog", "cats and dog"]  
      // 
      // 
      // Как именно работает цикл  
      // - В точке j=2 мы нашли слово "cat".
      // - backtrack(3) вернул ["sand dog"].
      // - Цикл for (const suffix of ["sand dog"])
      //   берёт единственный элемент "sand dog"
      //   и создаёт строку "cat sand dog".
      // - Аналогично для j=3 и слова "cats"
      //   мы комбинируем с суффиксом "and dog".
      // 
      // В каждом узле рекурсии этот цикл отвечает
      // за "склейку" текущего слова с любым из
      // вариантов, возвращённых из более
      // глубинного разбора.
      for (const suffix of backtrack(j + 1)) {
        if (suffix) {

          // Если суффикс не пуст, соединяем
          // текущее слово и суффикс через пробел
          //
          // Например:
          // "cat" + " sand dog" → "cat sand dog"
          result.push(`${s.slice(i, j + 1)} ${suffix}`);
        } else {

          // Если суффикс пуст (мы в конце строки),
          // добавляем только текущее слово без
          // пробела
          //
          // Например:
          // "dog"
          result.push(s.slice(i, j + 1));
        }
      }
    }

    // Запоминаем все найденные варианты
    // для данной позиции i, чтобы если
    // будет еще раз вызовaн backtrack(i),
    // не рассчитывать их снова
    dp.set(i, result);

    // Возвращаем все найденные предложения
    // от i до конца строки.
    return result;
  };

  // Запускаем рекурсивный сбор вариантов
  // с позиции 0 и возвращаем итоговый массив
  // всех возможных предложений, которые можно
  // получить, разбив строку s на слова из
  // wordDict при помощи пробелов.
  //
  // Пример для:
  // s = "catsanddog"
  // wordDict =
  // ["cat", "cats", "and", "sand", "dog"]
  //
  // результат будет
  // ["cats and dog", "cat sand dog"].
  return backtrack();
}
