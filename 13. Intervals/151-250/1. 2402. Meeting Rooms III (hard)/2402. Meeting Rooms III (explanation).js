/**
 * @param {number} n
 * @param {number[][]} meetings
 * @return {number}
 * 
 * mostBooked принимает количество комнат n
 * и список встреч meetings и возвращает
 * индекс комнаты, в которой прошло
 * максимальное число назначенных встреч.
 * При равенстве выбирается наименьший индекс.
 * 
 * Параметры:
 * n — целое число, количество переговорных
 *  комнат
 * meetings — массив пар [start, end],
 *  где start и end — целые времена начала
 *  и окончания встреч
 * 
 * Пример:
 *   Для:
 *     n = 3,
 *     meetings =
 *      [[1,20],[2,10],[3,5],[4,9],[6,8]]
 * 
 *  Возвращает:
 *    1
 */
function mostBooked(n, meetings) {

  // Сортировка массива meetings по времени
  // начала каждой встречи в порядке
  // возрастания.
  //
  // Это гарантирует, что мы обрабатываем
  // встречи в хронологическом порядке начала.
  meetings.sort((a, b) => a[0] - b[0]);

  // Создание приоритетной очереди available
  // с компаратором, который:
  // - сначала сравнивает по первому элементу
  //   записи (время, когда комната станет
  //   доступна);
  // - если времена доступности равны,
  //   сравнивает по второму элементу
  //   (номер комнаты).
  //
  // Формат записи в очереди:
  //   [availableTime, roomIndex]
  //   [время_доступности, номер_комнаты]
  //
  // Такая структура гарантирует, что мы всегда
  // извлечём комнату, которая свободна раньше
  // всех, а при равенстве свободных моментов
  // — комнату с меньшим индексом.
  const available = new PriorityQueue((a, b) =>
    a[0] === b[0] ? a[1] - b[1] : a[0] - b[0],
  );

  // Инициализация очереди доступных комнат:
  // для каждой комнаты i (0..n-1) добавляем
  // запись [0, i].
  //
  // Значение 0 означает, что изначально все
  // комнаты свободны начиная с момента времени 0.
  //
  // После этого приоритетная очередь содержит
  // n элементов, упорядоченных по
  // availableTime (все 0), и дополнительно
  // по индексу комнаты, чтобы соблюдалось правило
  // "меньший индекс при равенстве"
  for (let i = 0; i < n; i++) {
    available.enqueue([0, i]);
  }

  // Создание массива meetingsPerRoom длины n
  // для подсчёта числа встреч в каждой
  // комнате.
  //
  // Индекс i соответствует комнате.
  // Значение - число встреч проведенных в 
  //   в комнане i.
  //
  // Изначально все счётчики равны 0.
  const meetingsPerRoom = new Int32Array(n);

  // Итерация по всем встречам.
  // Каждая встреча представлена как [start, end].
  for (const [start, end] of meetings) {

    // Пока есть комнаты, у которых время
    // доступности строго меньше времени начала
    // текущей встречи, снимаем их с вершины
    // очереди и переустанавливаем их
    // доступность на время начала встречи.
    //
    // Это эмулирует освободившиеся комнаты,
    // которые не использовались до moment start
    // и считаются свободными именно с момента
    // start (чтобы не отдавать комнату
    // с устаревшим временем < start).
    while (
      !available.isEmpty()
      && available.front()[0] < start
    ) {
      const [_, room] = available.dequeue();

      // Перезаписываем время доступности
      // на start, сохраняя номер комнаты
      available.enqueue([start, room]);
    }

    // Извлекаем комнату с минимальным временем
    // доступности и минимальным индексом при
    // равенстве.
    //
    // Возможны два сценария:
    // 1. availableTime <= start: комната
    //    свободна к началу встречи, и мы займём
    //    её сразу в момент start.
    // 2. availableTime > start: все комнаты
    //    заняты к моменту start; тогда мы займём
    //    ту комнату, которая освободится самой
    //    ранней, и начало этой встречи
    //    фактически сдвинется до availableTime.
    //
    // Возвращаемые значения:
    //   endTime — время, когда комната
    //     освободится (до обновления),
    //   room — индекс выбранной комнаты.
    const [endTime, room] = available.dequeue();

    // Записываем в очередь обновлённое время
    // освобождения для выбранной комнаты.
    //
    // Если извлечённое endTime было <= start,
    // новая запись будет start + duration,
    // где duration = end - start, то есть
    // встреча начнётся в start и закончится
    // в start + duration.
    //
    // Если извлечённое endTime было > start,
    // это означает, что встреча фактически
    // начнётся в endTime, и тогда новая запись
    // будет endTime + duration, что моделирует
    // отложенный старт.
    available.enqueue([endTime + (end - start), room]);

    // Увеличиваем счётчик встреч для
    // выбранной комнаты, фиксируя, что в этой
    // комнате проведена еще одна встреча
    meetingsPerRoom[room]++;
  }

  // Возвращаем индекс комнаты, в которой прошло
  // максимальное количество встреч.
  //
  // Math.max(...meetingsPerRoom) вычисляет
  // максимальное количество встреч,
  //
  // indexOf находит первый индекс (комнату),
  // что соответствует требованию вернуть комнату
  // с наименьшим индексом при равенствном
  // количестве встреч.
  return meetingsPerRoom.indexOf(Math.max(...meetingsPerRoom));
}
