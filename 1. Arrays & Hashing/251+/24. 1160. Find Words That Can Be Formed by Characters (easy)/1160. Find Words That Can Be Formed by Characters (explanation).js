/**
 * @param {string[]} words
 * @param {string} chars
 * @return {number}
 * 
 * countCharacters подсчитывает суммарную
 * длину тех слов из массива words,
 * которые можно полностью составить из
 * доступных букв в строке chars, при
 * условии что каждая буква из chars может
 * быть использована не более того числа
 * раз, сколько она встречается в chars.
 * 
 * Параметры:
 * - words — массив строк
 * - chars — строка с доступными буквами
 * 
 * Возвращаемое значение:
 * - Число (integer) — суммарная длина
 *   всех слов из words, которые можно
 *   полностью составить из букв chars.
 * 
 * Пример для:
 *   words = ["cat","bt","hat","tree"]
 *   chars = "atach"  
 * Результат:
 *   6  
 * Пояснение:
 *   Строки, которые можно составить
 *   — "cat" и "hat", поэтому ответ
 *   равен 3 + 3 = 6. 
 */
function countCharacters(words, chars) {

  // Создаём массив целых чисел
  // фиксированной длины 26 для подсчёта
  // количества каждой буквы
  //
  // Индекс 0 соответствует 'a',
  // индекс 25 — 'z'.
  //
  // Int32Array экономичен по памяти и
  // даёт нулевые значения по умолчанию
  const charFreq = new Int32Array(26);

  // Итерация по каждому символу в
  // строке chars.
  //
  // Цель — подсчитать, сколько раз
  // каждая буква встречается в наборе
  // доступных букв.
  for (const char of chars) {

    // Получаем числовой код символа
    // и приводим его к индексу в
    // диапазоне 0..25:
    //
    // 'a'.charCodeAt(0) === 97,
    // поэтому для 'a' индекс будет 0,
    // для 'b' — 1 и т.д.
    charFreq[char.charCodeAt(0) - 97]++;
  }

  // Переменная-аккумулятор для
  // суммирования длин всех слов,
  // которые можно составить из chars
  let result = 0;

  // Метка outer позволяет из вложенного
  // цикла досрочно перейти к следующей
  // итерации внешнего цикла.
  outer: for (const word of words) {

    // Для каждого слова создаём отдельный
    // массив частот букв этого слова.
    //
    // Это нужно, чтобы сравнивать, сколько
    // каждой буквы требует текущее слово,
    // не изменяя общий массив доступных
    // букв charFreq.
    const wordCharFreq = new Int32Array(26);

    // Проходим по каждому символу текущего
    // слова, чтобы подсчитать сколько раз
    // он встречается в текущем слове
    for (const char of word) {

      // Преобразуем символ в индекс 0..25
      // точно так же, как для charFreq
      // выше
      const i = char.charCodeAt(0) - 97;

      // Увеличиваем счётчик для этой буквы
      // в wordCharFreq
      wordCharFreq[i]++;

      // Сравниваем частоту буквы в слове
      // с доступной частотой в chars.
      //
      // Если буква встречается в слове
      // чаще, чем она доступна в chars,
      // слово нельзя составить.
      if (wordCharFreq[i] > charFreq[i]) {

        // Немедленно переходим к
        // следующему слову внешнего цикла,
        // пропуская все оставшиеся символы
        // текущего слова
        //
        // Метка outer гарантирует, что мы
        // попадаем именно на следующий шаг
        // внешнего цикла
        continue outer;
      }
    }

    // Если все буквы слова прошли проверку
    // (ни для одной не произошло
    // превышение), то это слово можно
    // составить из chars — добавляем его
    // длину к результату.
    result += word.length;
  }

  // Возвращаем накопленную суммарную длину
  // всех слов, которые можно составить из
  // chars
  return result;
}
