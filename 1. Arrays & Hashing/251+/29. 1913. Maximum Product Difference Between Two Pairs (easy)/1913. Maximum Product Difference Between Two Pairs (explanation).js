/**
 * @param {number[]} nums
 * @return {number}
 * 
 * maxProductDifference принимает массив чисел
 * и возвращает разницу между произведением
 * двух наибольших элементов и произведением
 * двух наименьших элементов массива.
 * 
 * Параметры
 *   nums — массив чисел
 * 
 * Возвращаемое значение
 *   число - разница между произведением двух
 *   наибольших и произведением двух
 *   наименьших элементов массива.
 * 
 * Пример для:
 *   nums = [5,6,2,7,4]
 * Результат:
 *   34
 * Пояснение:
 *   Мы можем выбрать индексы 1 и 3 для первой
 *   пары (6, 7) и индексы 2 и 4 для второй
 *   пары (2, 4).
 * 
 *   Разница произведений равна
 *   (6 * 7) - (2 * 4) = 34.
 */
function maxProductDifference(nums) {

  // Проверка на случай короткого массива:
  // 
  // Если элементов меньше двух, логически нельзя
  // взять пару.
  //
  // В таком случае возвращаем первый элемент
  // массива, если он есть.
  // 
  // Если массива нет или он пуст, возвращаем 0.
  //
  // Оператор ?? гарантирует, что при undefined
  // вернётся 0.
  if (nums.length < 2) return nums[0] ?? 0;

  // Инициализация max1 — переменной для
  // хранения наибольшего найденного значения.
  //
  // Начальное значение 0 выбрано как нейтральное
  // для неотрицательных наборов.
  // 
  // При наличии отрицательных чисел алгоритм всё
  // равно корректно обновит max1 при первом
  // проходе, но начальное 0 предполагает, что
  // входные данные содержат числа >= 0 (если это
  // не так, можно было бы использовать -Infinity).
  let max1 = 0;

  // Инициализация переменной max2 — будет хранить
  // второй по величине элемент.
  //
  // Начальное значение 0 аналогично предполагает
  // неотрицательные элементы.
  // 
  // При встрече большего числа max2 будет
  // обновлён 
  let max2 = 0;

  // Инициализация переменной min1 — будет хранить
  // наименьшее найденное значение.
  //
  // Используется +Infinity, чтобы любой реальный
  // элемент массива оказался меньше и корректно
  // заменил min1.
  let min1 = Infinity;

  // Инициализация переменной min2 — будет
  // хранить второй по минимальности элемент.
  //
  // Тоже стартует с +Infinity, чтобы корректно
  // обновляться при обходе массива.
  let min2 = Infinity;

  // Проход по всем элементам массива nums
  for (const num of nums) {

    // Проверяем, больше ли текущий элемент,
    // чем текущий максимум max1.
    //
    // Если да, то текущий max1 становится
    // вторым максимумом (max2), а num
    // становится новым max1.
    //
    // Это обеспечивает корректное поддержание
    // двух наибольших значений в порядке
    // убывания.
    if (num > max1) {
      max2 = max1;
      max1 = num;

      // Если num не превысил max1, но больше,
      // чем текущий второй максимум max2, то
      // обновляем только max2 — таким образом
      // сохраняется порядок max1 >= max2
    } else if (num > max2) {
      max2 = num;
    }

    // Проверяем, меньше ли текущий элемент,
    // чем текущий минимум min1.
    //
    // Если да, то прежний min1 становится
    // min2, а num становится новым min1.
    //
    // Это поддерживает два наименьших
    // значения в порядке возрастания.
    if (num < min1) {
      min2 = min1;
      min1 = num;

      // Если num не оказался меньше min1,
      // но меньше, чем текущий второй
      // минимум min2, то обновляем только
      // min2 — таким образом сохраняется
      // порядок min1 <= min2.
    } else if (num < min2) {
      min2 = num;
    }
  }

  // После завершения цикла max1 и max2
  // содержат два наибольших значения,
  // а min1 и min2 — два наименьших,
  // при условии, что в массиве как
  // минимум два элемента.
  //
  // Возвращаем произведение двух
  // наибольших элементов минус
  // произведение двух наименьших.
  return max1 * max2 - min1 * min2;
}
