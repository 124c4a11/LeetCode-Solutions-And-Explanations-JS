/**
 * @param {string} s
 * @return {number}
 * 
 * longestPalindrome принимает один параметр
 * — строку s, состоящую из строчных или
 * заглавных букв и возвращает целое число
 * — максимальную длину палиндрома, которую
 * можно составить из букв этой строки,
 * используя каждую букву не более того
 * количества раз, сколько она встречается
 * в s.
 * 
 * Разрешено переставлять символы произвольно
 * 
 * Буквы чувствительны к регистру, например,
 * "Aa"не считается палиндромом.
 * 
 * 
 * Пример для:
 *   s = "abccccdd"
 * Результат:
 *   7
 * Пояснение:
 *   Самый длинный палиндром, который можно
 *   построить, — это "dccaccd", длина которого
 *   равна 7.
 * 
 * 
 * Пример для:
 *   s = "a"
 * Результат:
 *   1
 * Пояснение:
 *   Самый длинный палиндром, который можно
 *   построить, — это "a", длина которого
 *   равна 1.
 */
function longestPalindrome(s) {

  // Создаём пустой Set для отслеживания
  // символов, которые в текущий момент
  // встречаются нечетное число раз.
  //
  // Идея:
  // Если символ встречается дважды, они
  // образуют пару и могут быть использованы
  // симметрично в палиндроме.
  const set = new Set();

  // Инициализируем счётчик result, который
  // будет хранить суммарную длину уже
  // найденных пар символов.
  //
  // Каждая найденная пара увеличивает длину
  // палиндрома ровно на 2.
  let result = 0;

  // Проходим по каждому символу строки s
  for (const char of s) {

    // Проверяем, встречался ли этот символ
    // ранее в нечётном количестве
    // (т.е. находится ли он в множестве).
    //
    // Если да, то текущая встреча образует
    // пару с символом в множесте
    if (set.has(char)) {

      // Удаляем символ из множества,
      // потому что теперь его количество
      // стало чётным (пара сформирована).
      //
      // Это освобождает место для
      // возможных следующих одиночных
      // вхождений того же символа.
      set.delete(char);

      // Увеличиваем результат на 2,
      // поскольку найденная пара
      // добавляет две позиции в
      // палиндроме (левую и правую
      // симметричные).
      result += 2;
    } else {

      // Если символа ещё нет в множестве,
      // добавляем его — это означает,
      // что он сейчас встречается в
      // одиночном экземпляре.
      //
      // Если позже найдётся второй такой
      // символ, он будет удалён и учтён
      // в result как пара.
      set.add(char);
    }
  }

  // После обработки всех символов:
  // Если множество пусто, значит все
  // символы образовали пары и result
  // — окончательный ответ.
  //
  // Если множество не является пустым,
  // значит есть хотя бы один символ с
  // нечётной частотой, который можно
  // поместить в центр палиндрома, что
  // увеличит длину на 1. Оператор
  // !set.size проверяет является ли
  // множество пустым (size === 0).
  //
  // Возвращаем result или result + 1
  // в зависимости от наличия
  // центрального символа.
  return !set.size ? result : result + 1;
}
