/**
 * @param {string} path
 * @return {boolean}
 * 
 * isPathCrossing проверяет, пересекается ли путь,
 * заданный последовательностью шагов по четырём
 * направлениям 'N', 'S', 'E', 'W'. Она моделирует
 * перемещение по сетке, начиная с точки (0,0), и
 * возвращает true, если в какой‑то момент маршрут
 * проходит через уже посещённую точку, иначе false
 * 
 * Параметры
 * - path — строка, каждый символ которой
 *   обозначает направление для одного шага:
 *     'N' — север (увеличение (y))
 *     'S' — юг (уменьшение (y))
 *     'E' — восток (увеличение (x))
 *     'W' — запад (уменьшение (x))
 * 
 * Возвращаемое значение
 * - true — если в процессе следования по всем
 *   символам строки функция обнаружила позицию,
 *   которая уже была посещена ранее
 * 
 * - false — если все посещённые позиции
 *   уникальны.
 * 
 * Пример для:
 *   path = "NES"
 * Результат:
 *   false 
 * Пояснение:
 *   Обратите внимание, что путь не пересекает
 *   одну точку более одного раза.
 * 
 * Пример для:
 *   path = "NESWW"
 * Результат:
 *   true
 * Пояснение:
 *   Обратите внимание, что путь дважды
 *   проходит через начало координат.
 */
function isPathCrossing(path) {

  // Создаём новый объект Set для хранения
  // уникальных позиций, которые уже были
  // посещены.
  //
  // Set обеспечивает быстрые операции
  // проверки наличия элемента
  // (амортизированное O(1)).
  const visited = new Set();

  // Объявляем переменную x для текущей
  // горизонтальной координаты.
  //
  // Начальное значение 0.
  //
  // x увеличивается при движении на
  // восток и уменьшается при движении
  // на запад.
  let x = 0;

  // Объявляем переменную y для текущей
  // вертикальной координаты.
  //
  // Начальное значение 0.
  //
  // y увеличивается при движении на
  // север и уменьшается при движении
  // на юг.
  let y = 0;

  // Добавляем начальную позицию (0,0)
  // в множество посещённых позиций.
  //
  // Используется строковое
  // представление `${x},${y}` для
  // простоты хранения и сравнения.
  visited.add(`${x},${y}`);

  // Итерация по каждому символу в
  // строке path.
  for (const char of path) {

    // Если текущий символ равен 'N',
    // это шаг на север:
    // увеличиваем y на 1
    if (char === 'N') y++;

    // Если символ 'S', это шаг на юг:
    // уменьшаем y на 1
    else if (char === 'S') y--;

    // Если символ 'E', это шаг на
    // восток:
    // увеличиваем x на 1
    else if (char === 'E') x++;

    // Если символ 'W', это шаг на
    // запад:
    // уменьшаем x на 1
    else if (char === 'W') x--;

    // Формируем строковое
    // представление текущей позиции
    // в формате "x,y".
    //
    // Такое представление удобно
    // для хранения в Set и для
    // быстрого сравнения позиций. 
    const pos = `${x},${y}`;

    // Проверяем, содержится ли текущая
    // позиция в множестве visited.
    //
    // Если да, это означает, что мы
    // вернулись на уже посещённую
    // клетку — путь пересекается.
    //
    // В этом случае функция немедленно
    // возвращает true, чтобы не тратить
    // время на дальнейшие вычисления.
    if (visited.has(pos)) return true;

    // Если текущая позиция ещё не была
    // посещена, добавляем её в
    // множество visited.
    //
    // Это гарантирует, что последующие
    // проверки смогут обнаружить
    // возможные пересечения.
    visited.add(pos);
  }

  // Если цикл завершился и ни одна
  // позиция не была посещена дважды,
  // возвращаем false — путь не
  // пересекает сам себя.
  return false;
}
