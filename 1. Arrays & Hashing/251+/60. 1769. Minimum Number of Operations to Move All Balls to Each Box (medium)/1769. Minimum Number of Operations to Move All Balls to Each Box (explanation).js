/**
 * @param {string} boxes
 * @return {number[]}
 * 
 * minOperations принимает один параметр — boxes:
 * строка символов '0'/'1', где '1' означает наличие
 * шарика в коробке, '0' — отсутствие и вычисляет
 * для каждой коробки минимальное число операций,
 * чтобы переместить все шары в эту коробку
 * 
 * Возвращает:
 * Массив result длины n (где n = boxes.length), в
 * котором элемент result[i] — минимальное число
 * операций (шагов), чтобы собрать все шарики в
 * коробке i.
 * 
 * 
 * Пример для:
 *   boxes = "110"
 * Результат:
 *   [1,1,3]
 * Пояснение:
 *   Ответ для каждой коробки следующий:
 *   1. Первая коробка: нужно переместить один шар
 *      из второй коробки в первую — 1 операция.
 *
 *   2. Вторая коробка: нужно переместить один шар
 *      из первой коробки во вторую — 1 операция.
 *
 *   3. Третья коробка: нужно переместить один шар
 *      из первой коробки в третью за 2 операции,
 *      и переместить один шар из второй коробки в
 *      третью за 1 операцию.
 */
function minOperations(boxes) {
  // Получаем количество коробок и сохраняем в
  // константу n.
  //
  // Это фиксированное значение на время
  // выполнения функции, используется для границ
  // циклов.
  const n = boxes.length;

  // Создаём типизированный массив Int32Array
  // длины n для хранения результатов.
  //
  // Int32Array экономит память и гарантирует
  // целочисленные значения.
  // 
  // Все элементы инициализируются нулём.
  const result = new Int32Array(n);

  // Переменная для подсчёта количества шариков,
  // встреченных в текущем направлении обхода.
  //
  // В первом проходе это будет количество
  // шариков слева от текущей позиции.
  let balls = 0;

  // Переменная для накопления суммарного числа
  // шагов, которые уже были совершены этими
  // шариками при продвижении к текущей позиции
  // в процессе итераций.
  let moves = 0;

  // Цикл прохода слева направо:
  // 
  // i — индекс текущей коробки, от 0 до n-1.
  //
  // За один проход мы вычисляем вклад всех
  // шариков, находящихся слева от позиции i.
  for (let i = 0; i < n; i++) {

    // Для позиции i результат от левой части
    // равен сумме:
    // - balls: каждый шарик слева должен
    //   сделать ещё один шаг, чтобы подойти
    //   на одну позицию ближе к i;
    //
    // - moves: уже накопленные шаги, которые
    //   требовались этим шарикам, чтобы
    //   достичь предыдущих позиций.
    //
    // Вместе они дают общее число операций,
    // необходимых левым шарикам, чтобы
    // попасть в i.
    result[i] = balls + moves;

    // При переходе к следующему индексу (i+1)
    // все уже учтённые шарики сдвинутся на одну
    // позицию вправо, поэтому увеличиваем moves
    // на текущее количество balls — это
    // добавляет один шаг для каждого шарика.
    moves += balls;

    // Увеличиваем счётчик balls на
    // количество шариков в текущей коробке.
    //
    // Number(boxes[i]) преобразует символ
    // '0'/'1' в числовое 0 или 1
    balls += Number(boxes[i]);

    // Пример работы цикла слева направо для 
    // boxes = "110"
    //
    // ---
    // 
    // Исходные значения перед циклом
    // - n = 3  
    // - result = [0, 0, 0]
    // - balls = 0  
    // - moves = 0
    // 
    // ---
    // 
    // Шаг i = 0 (boxes[0] = '1')
    //
    // - Вычисление: 
    //   result[0] = balls + moves = 0 + 0 = 0  
    //
    // - Обновление moves:
    //   moves += balls → moves = 0 + 0 = 0  
    //
    // - Обновление balls:
    //   balls += Number(boxes[0])
    //   → balls = 0 + 1 = 1  
    // 
    // Состояние после шага:  
    // - result = [0, 0, 0]  
    // - moves = 0
    // - balls = 1
    // 
    // Пояснение:
    // Для первой коробки вклад шаров слева
    // равен 0, потому что слева нет шаров.
    // Затем мы учли, что теперь слева от
    // следующих позиций есть 1 шар.
    // 
    // ---
    // 
    // Шаг i = 1 (boxes[1] = '1')  
    //
    // - Вычисление:
    //   result[1] = balls + moves = 1 + 0 = 1  
    //
    // - Обновление moves:
    //   moves += balls → moves = 0 + 1 = 1
    //
    // - Обновление balls:
    //   balls += Number(boxes[1])
    //   → balls = 1 + 1 = 2
    // 
    // Состояние после шага:  
    // - result = [0, 1, 0]
    // - moves = 1
    // - balls = 2
    // 
    // Пояснение:
    // Для второй коробки вклад от шаров слева
    // равен 1 (есть один шар слева на
    // расстоянии 1). При переходе к следующей
    // позиции все уже учтённые шары (их 1 на
    // момент перехода) станут дальше на одну
    // позицию, поэтому moves увеличился на 1.
    // Также учтён сам шар в текущей коробке.
    // 
    // ---
    // 
    // Шаг i = 2 (boxes[2] = '0')  
    //
    // - Вычисление:
    //   result[2] = balls + moves = 2 + 1 = 3  
    //
    // - Обновление moves:
    //   moves += balls → moves = 1 + 2 = 3
    //
    // - Обновление balls:
    //   balls += Number(boxes[2])
    //   → balls = 2 + 0 = 2
    // 
    // Состояние после шага:  
    // - result = [0, 1, 3]
    // - moves = 3
    // - balls = 2
    // 
    // Пояснение:
    // Для третьей коробки вклад от шаров слева
    // равен 3 — это суммарное расстояние от двух
    // шаров, находящихся слева (один на
    // расстоянии 2, другой на расстоянии 1).
    // moves  увеличилось на текущее balls (2),
    // отражая, что при переходе дальше каждый из
    // двух шаров добавит ещё по одной операции.
    // 
    // ---
    // 
    // Итог по этому циклу:
    // После выполнения этого фрагмента (первого
    // прохода слева направо) массив result
    // содержит вклад только от шаров, находящихся
    // слева каждой позиции: [0, 1, 3]. Для
    // получения окончательного ответа нужно
    // выполнить второй проход справа налево и
    // добавить вклад шаров справа к этим
    // значениям.
  }

  // Сбрасываем счётчики balls и moves перед
  // вторым проходом, чтобы аналогично посчитать
  // вклад шариков, находящихся справа от каждой
  // позиции.
  balls = moves = 0;

  // Цикл прохода справа налево:
  // 
  // i идёт от n-1 до 0 включительно.
  //
  // Во втором проходе мы добавляем вклад
  // шариков, которые находятся справа от
  // позиции i.
  for (let i = n - 1; i >= 0; i--) {

    // Аналогично первому проходу, для
    // позиции i добавляем:
    // - balls: каждый шарик справа требует
    //   ещё одного шага, чтобы сдвинуться на
    //   одну позицию влево
    //
    // - moves: накопленные дополнительные
    //   шаги, которые эти правые шарики
    //   уже сделали, приближаясь к текущей
    //   позиции.
    //
    // Мы суммируем этот вклад с уже
    // записанным значением result[i] от
    // левого прохода.
    result[i] += balls + moves;

    // При переходе к предыдущей позиции
    // (влево) все учтённые справа шарики
    // окажутся на единицу дальше, поэтому
    // увеличиваем moves на текущее
    // количество balls.
    moves += balls;

    // Увеличиваем счётчик balls на
    // количество шариков в текущей коробке
    // (теперь рассматриваем правую сторону).
    balls += Number(boxes[i]);

    // Пример работы цикла справа налево для
    // boxes = "110"
    // 
    // Исходные значения перед циклом
    // - n = 3  
    //
    // - result = [0, 1, 3] (результат после
    //   первого прохода слева направо)  
    //
    // - balls = 0  
    // - moves = 0
    // 
    // ---
    // 
    // Шаг i = 2 (boxes[2] = '0')  
    // - Вычисление: 
    //   result[2] += balls + moves = 3 + 0 = 3  
    //
    // - Обновление moves:
    //   moves += balls = 0 + 0 = 0  
    //
    // - Обновление balls:
    //   balls += Number(boxes[2]) 
    //   → balls = 0 + 0 = 0
    // 
    // Состояние после шага:
    // - result = [0, 1, 3]
    // - moves = 0
    // - balls = 0
    // 
    // Пояснение:
    // Справа от позиции 2 нет шаров, поэтому
    // вклад правой части равен 0 и result[2]
    // остаётся 3.
    // 
    // ---
    // 
    // Шаг i = 1 (boxes[1] = '1')  
    //
    // - Вычисление: 
    //   result[1] += balls + moves = 1 + 0 = 1
    //
    // - Обновление moves:
    //   moves += balls = 0 + 0 = 0
    //
    // - Обновление balls:
    //   balls += Number(boxes[1])
    //   → balls = 0 + 1 = 1
    // 
    // Состояние после шага:
    // - result = [0, 1, 3]
    // - moves = 0
    // - balls = 1
    // 
    // Пояснение:
    // Перед обработкой позиции 1 справа не было
    // шаров, поэтому result[1] не меняется.
    // После шага мы учитываем, что теперь для
    // более левых позиций справа есть 1 шар
    // (тот, что в позиции 1).
    // 
    // ---
    // 
    // Шаг i = 0 (boxes[0] = '1')  
    //
    // - Вычисление:
    //   result[0] += balls + moves = 0 + 1 = 1
    //
    // - Обновление moves:
    //   moves += balls = 0 + 1 = 1
    //
    // - Обновление balls:
    //   balls += Number(boxes[0])
    //   → balls = 1 + 1 = 2
    // 
    // Состояние после шага:
    // - result = [1, 1, 3]  
    // - moves = 1
    // - balls = 2
    // 
    // Пояснение:
    // При обработке позиции 0 справа уже был
    // 1 шар (в позиции 1), поэтому к result[0]
    // добавляется 1. После этого balls
    // становится 2 (оба шара учтены для ещё
    // более левых позиций, если бы они были).
    // 
    // ---
    // 
    // Итог второго прохода:
    // После выполнения цикла справа налево
    // result стал [1, 1, 3] — это
    // окончательный ответ: минимальное число
    // операций для каждой коробки.
  }

  // Возвращаем заполненный Int32Array, где
  // в каждой ячейке указано минимальное
  // число операций, необходимых для того,
  // чтобы собрать все шарики в
  // соответствующей коробке.
  return result;
}
