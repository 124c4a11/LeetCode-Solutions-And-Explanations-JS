/**
 * @param {number[][]} grid
 * @return {number[]}
 * 
 * findMissingAndRepeatedValues ищет
 * в квадратной матрице (n × n)
 * повторяющееся значение и отсутствующее
 * значение в диапазоне 1…n².
 * 
 * Возвращает массив из двух чисел:
 * - первый элемент — повторяющееся
 *   значение,
 * - второй — отсутствующее.
 * 
 * Параметры
 * - grid — двумерный массив
 *   (массив массивов) чисел,
 *   представляющий квадратную матрицу
 *   размера n × n. Функция ожидает,
 *   что grid.length = n и каждая строка
 *   содержит n элементов.
 * 
 * Пример:
 *   Для:
 *     grid = [[1,3],[2,2]]
 *   Результат:
 *     [2,4]
 *   Пояснение: 
 *     - n = grid.length = 2
 *     - Диапазон ожидаемых значений:
 *       1..n² → 1..2² → 1..4
 *     - Число 2 повторяется,
 *       а число 4 отсутствует,
 *       поэтому ответ — [2,4].
 */
function findMissingAndRepeatedValues(grid) {

  // Определяем размерность матрицы
  // (количество строк = количество столбцов)
  //
  // В примере grid = [[1,3],[2,2]],
  // значит n = 2
  const n = grid.length;

  // Создаём пустое множество для хранения
  // уникальных чисел, встречающихся
  // в матрице
  const set = new Set();

  // Переменная для хранения повторяющегося
  // числа (по умолчанию 0)
  let repeated = 0;

  // Внешний цикл проходит по строкам
  // матрицы
  for (let r = 0; r < n; r++) {

    // Внутренний цикл проходит по
    // столбцам матрицы
    for (let c = 0; c < n; c++) {

      // Получаем текущее число из ячейки
      // матрицы
      const num = grid[r][c];

      // Если число уже встречалось ранее
      // (есть в множестве), значит оно
      // повторяется - фиксируем его в
      // repeated как повторяющееся
      //
      // Пример для grid = [[1,3],[2,2]]:
      // - grid[0][0] = 1
      //   → множество пустое
      //   → добавляем 1
      //
      // - grid[0][1] = 3
      //   → множество {1}
      //   → добавляем 3
      //
      // - grid[1][0] = 2
      //   → множество {1,3}
      //   → добавляем 2
      //
      // - grid[1][1] = 2
      //   → число 2 уже есть в множестве
      //   → repeated = 2
      if (set.has(num)) repeated = num;

      // Добавляем текущее число в
      // множество set
      // 
      // Если оно уже есть в set,
      // множество не изменится
      set.add(num);
    }
  }

  // Переменная для хранения недостающего
  // числа
  let missing = 0;

  // Перебираем все числа от 1 до n²
  // 
  // Для примера от 1 до 4
  for (let num = 1; num <= n * n; num++) {

    // Если число уже есть в множестве,
    // пропускаем его
    //
    // В нашем примере множество = {1,2,3}
    //
    // Проверка:
    // - num = 1 
    //   → есть в множестве
    //   → пропускаем
    //
    // - num = 2
    //   → есть в множестве
    //   → пропускаем
    //
    // - num = 3
    //   → есть в множестве
    //   → пропускаем
    //
    // - num = 4
    //   → нет в множестве
    //   → это недостающее число
    if (set.has(num)) continue;

    // Если числа нет в множестве,
    // сохраняем его как недостающее
    missing = num;

    // Прерываем цикл, так как
    // недостающее число найдено
    break;
  }

  // Возвращаем массив из двух значений:
  // [повторяющееся число, недостающее число]
  //
  // Для grid = [[1,3],[2,2]]
  // результ [2,4]
  return [repeated, missing]
};
