/**
 * NumArray решает задачу быстрого вычисления суммы
 * элементов произвольного подотрезка (диапазона)
 * исходного массива чисел.
 * 
 * В качестве параметра принимает
 * nums — массив чисел
 * 
 * Предоставляет метод sumRange(left, right),
 * который вычисляет сумму элементов массива nums
 * между индексами left и right включительно при
 * условии left <= right.
 * 
 * Возвращает число — сумму элементов
 * nums[left] + ... + nums[right].
 */
class NumArray {

  /**
   * @param {number[]} nums
   */
  constructor(nums) {

    // Инициализируем массив prefix длиной
    // nums.length + 1
    //
    // Почему длина nums.length + 1:
    // В нулевом элементе будет храниться
    // 0 — «нулевая» префиксная сумма. Тогда
    // префиксная сумма первых k элементов
    // будет лежать в prefix[k]. Это упрощает
    // вычисление сумм отрезков через разность
    // двух префиксных сумм.  
    //
    // Все элементы Int32Array по умолчанию
    // равны 0, поэтому prefix[0] === 0
    // сразу готово.  
    //
    // Особенность типа:
    // Значения хранятся как 32‑битные знаковые
    // целые. При переполнении происходит
    // обёртывание в диапазон Int32. Это важно,
    // если суммы могут выходить за пределы
    // ±2^31−1.
    this.prefix = new Int32Array(nums.length + 1);

    // Цикл поэлементно строит массив
    // префиксных сумм. На каждой итерации
    // вычисляется сумма первых i+1 элементов
    // исходного массива и сохраняется в
    // prefix[i+1].  
    //
    // Почему i + 1:
    //
    // - prefix[0] — сумма нуля элементов,
    //   prefix[1] — сумма nums[0],
    //   prefix[2] — сумма nums[0] + nums[1]
    //   и т.д. Поэтому при обработке nums[i]
    //   результат записывается в ячейку со
    //   сдвигом на 1.
    //
    // - Сдвиг на 1 избавляет от частых ошибок
    //   со смещением индексов и упрощает
    //   реализацию (нет отдельной обработки
    //   первого элемента или left = 0).
    //
    // - Хранение нулевой суммы в позиции 0
    //   устраняет дополнительные условные
    //   проверки при вычислении сумм,
    //   упрощает формулы и избавляет от
    //   специальных случаев для левых границ
    //   (например, left = 0). 
    //
    // - При nums.length = 0 создаётся prefix
    //   длиной 1 с prefix[0] = 0. Формула
    //   prefix[right + 1] - prefix[left]
    //   остаётся корректной для корректных
    //   входных индексов и не требует
    //   специальных условий для пустого
    //   префикса.
    //
    // Выражение this.prefix[i] + nums[i]:
    // Берём накопленную сумму первых i
    // элементов (в prefix[i]) и прибавляем
    // текущий элемент nums[i], получая
    // сумму первых i+1 элементов.  
    //
    // Пример: для nums = [1, 2, 3] после
    // выполнения:
    // - prefix[0] = 0
    // - prefix[1] = 0 + 1 = 1
    // - prefix[2] = 1 + 2 = 3
    // - prefix[3] = 3 + 3 = 6
    // Итог prefix = [0,1,3,6]
    //
    // ---
    //
    // Как это используется для sumRange
    //
    // Чтобы получить сумму элементов
    // от left до right включительно,
    // достаточно взять разность префиксных
    // сумм: prefix[right + 1] - prefix[left].  
    //
    // Для примера prefix = [0,1,3,6]
    // сумма от 1 до 2 (элементы 2 и 3)
    //   = prefix[3] - prefix[1]
    //   = 6 - 1 = 5.
    //
    // ---
    //
    // Сложность и преимущества
    //
    // - Построение массива префиксных сумм
    //   занимает O(n) времени и O(n) памяти.  
    //
    // - После этого любой запрос суммы отрезка
    //   выполняется за O(1) времени
    //   (две операции доступа и вычитание).  
    //
    // - Использование Int32Array даёт экономию
    //   памяти и может быть быстрее для
    //   числовых операций по сравнению с
    //   обычным массивом, но ограничивает
    //   диапазон значений (возможна потеря
    //   данных при выходе за пределы Int32).
    //
    // ---
    //
    // Потенциальные ограничения и альтернативы
    //
    // - Если суммы могут превышать 32‑битный диапазон,
    //   стоит использовать обычный массив Number или
    //   BigInt (в последних — дополнительная сложность
    //   и медленнее).  
    //
    // - Если исходный массив изменяется
    //   (частые обновления), лучше использовать
    //   структуры, поддерживающие обновления:
    //   дерево Фенвика (BIT) или сегментное дерево.
    for (let i = 0; i < nums.length; i++) {

      // Вычисление префиксной суммы на позиции i+1:
      // берём уже накопленную сумму prefix[i] и
      // прибавляем текущий элемент nums[i]
      //
      // Таким образом после завершения цикла
      // prefix[k] будет равен сумме
      // nums[0] + ... + nums[k-1]
      this.prefix[i + 1] = this.prefix[i] + nums[i];
    }
  };

  /** 
   * @param {number} left 
   * @param {number} right
   * @return {number}
   * 
   * Метод sumRange вычисляет сумму элементов
   * исходного массива на замкнутом интервале
   * индексов [left, right].
   * 
   * Метод опирается на предварительно
   * вычисленные префиксные суммы, что
   * обеспечивает время выполнения O(1).
   */
  sumRange(left, right) {

    // Вычисление суммы сегмента производится
    // как разность префиксных сумм:
    //
    // - prefix[right + 1] — сумма первых
    //   right+1 элементов (то есть элементов с
    //   индекса 0 по right),
    //
    // - prefix[left] — сумма первых left
    //   элементов
    //  (элементов с индекса 0 по left-1).
    //
    // Разность даёт искомую сумму от индекса
    // left по индекс right включительно
    // nums[left] + nums[left+1] + ... + nums[right] 
    //
    // Важно, что здесь предполагается корректность
    // входных индексов:
    // 0 <= left <= right < nums.length.
    return this.prefix[right + 1] - this.prefix[left];
  };
}

/** 
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */
