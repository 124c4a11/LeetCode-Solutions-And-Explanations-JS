/**
 * @param {string[]} words
 * @return {boolean}
 * 
 * validWordSquare проверяет, образуют ли строки
 * в массиве words корректный квадрат слов — то
 * есть совпадает ли каждая k‑я строка с k‑м
 * столбцом. 
 * 
 * Параметры:
 * - words — массив строк. Каждая строка
 *   рассматривается как отдельная строка в
 *   воображаемой матрице символов. Функция не
 *   изменяет входной массив и ожидает, что
 *   элементы — строки.
 * 
 * Возвращает:
 * Булево значение (true или false) в зависимости
 * от результата проверки.
 * 
 * 
 * Пример для:
 *   words = [
 *     "abcd",
 *     "bnrt",
 *     "crmy",
 *     "dtye"
 *   ]
 * Результат:
 *   true
 * Пояснение:
 *   1-я строка и 1-й столбец оба читаются как "abcd"
 *   2-я строка и 2-й столбец оба читаются как "bnrt"
 *   3-я строка и 3-й столбец оба читаются как "crmy"
 *   4-я строка и 4-й столбец оба читаются как "dtye"
 *   Следовательно, это корректный квадрат слов
 * 
 * 
 * Пример для:
 *   words = [
 *     "abcd",
 *     "bnrt",
 *     "crm",
 *     "dt"
 *   ]
 * Результат:
 *   true
 * Пояснение:
 *   1-я строка и 1-й столбец оба читаются как "abcd"
 *   2-я строка и 2-й столбец оба читаются как "bnrt"
 *   3-я строка и 3-й столбец оба читаются как "crm"
 *   4-я строка и 4-й столбец оба читаются как "dt"
 *   Следовательно, это корректный квадрат слов
 */
function validWordSquare(words) {

  // Определяем константу ROWS как количество
  // элементов в массиве words — это число строк в
  // предполагаемом квадрате слов.
  const ROWS = words.length;

  // Инициализируем переменную COLS нулём.
  //
  // Она будет использоваться для хранения
  // максимальной длины слова (числа столбцов).
  let COLS = 0;

  // Проходим по каждому элементу массива words.
  //
  // Переменная word на каждой итерации
  // представляет одну строку предполагаемгого
  // квадрата слов
  for (const word of words) {

    // Обновляем COLS до максимума между
    // текущим значением COLS и длиной
    // текущего слова.
    //
    // Math.max гарантирует, что COLS в конце
    // цикла — длина самого длинного слова.
    COLS = Math.max(COLS, word.length);
  }

  // Быстрая валидация: 
  //
  // Если длина первого слова не равна
  // максимальной длине (COLS), значит длина
  // словa первой строки не соответствует
  // длине слова первого столбца, поэтому они
  // не могут образовать корректный квадрат
  // слов
  //
  // В корректном квадрате слов каждая k‑я
  // строка должна совпадать с k‑м столбцом,
  // а значит длина соответствующих строк и
  // столбцов совпадает. То есть длина
  // первого слова-строки должна быть равна
  // длине первого слова-колонки, длина
  // второго слова-строки должна быть равна
  // длине второго слова-колонки и т.д.
  //
  // Также проверяем, что число строк равно
  // числу столбцов (ROWS === COLS), так как
  // квадрат слов требует чтобы количество
  // строк соответствовало количеству
  // символов в слове с максимальной длиной
  // (COLS)
  //
  // Если одно из условий не выполнено,
  // сразу возвращаем false.
  if (
    COLS !== words[0].length
    || ROWS !== COLS
  ) return false;

  // Создаём пустой массив colWords, в который
  // будем собирать строки, полученные из
  // столбцов исходного массива.
  const colWords = [];

  // Внешний цикл по индексам столбцов.
  //
  // Для каждого столбца мы сформируем строку,
  // читаемую сверху вниз.
  for (let c = 0; c < COLS; c++) {

    // colWord временно хранит символы
    // текущего столбца в порядке от верхней
    // строки к нижней.
    //
    // Символы в colWord представляют слово
    // в текущем столбце предполагаемого
    // квадрата слов
    //
    // Используем массив, потому что push
    // эффективнее многократной конкатенации
    // строк.
    const colWord = [];

    // Внутренний цикл проходит по всем
    // строкам, чтобы взять символ из
    // столбца c.
    for (let r = 0; r < ROWS; r++) {

      // Поскольку слова могут иметь
      // разную длину, проверяем,
      // существует ли символ в позиции c
      // для текущей строки r.
      //
      // Это защищает от выхода за
      // границы коротких строк
      if (c < words[r].length) {

        // Если символ существует,
        // добавляем его в массив
        // символов текущего столбца
        colWord.push(words[r][c]);
      }
    }

    // После обхода всех строк для данного
    // столбца объединяем массив символов в
    // строку, которая представляет слово в
    // в текущем столбце, и добавляем её в
    // colWords.
    //
    // join('') собирает символы без
    // разделителя, формируя строку,
    // соответствующую столбцу c.
    colWords.push(colWord.join(''));
  }

  // Сравниваем исходный массив words с
  // полученным массивом colWords поэлементно.
  //
  // Метод every проходит по всем элементам
  // words. Для каждого индекса i проверяется
  // равенство words[i] и colWords[i].
  //
  // Если все пары совпадают, возвращается
  // true — входной массив действительно
  // образует "квадрат слов".
  //
  // В противном случае возвращается false.
  return words.every((w, i) => w === colWords[i]);
}
