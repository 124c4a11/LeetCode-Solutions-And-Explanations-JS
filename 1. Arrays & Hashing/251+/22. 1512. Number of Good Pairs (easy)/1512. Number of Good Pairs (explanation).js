/**
 * @param {number[]} nums
 * @return {number}
 * 
 * numIdenticalPairs считает количество
 * пар индексов (i, j) таких, что i < j
 * и nums[i] === nums[j]. То есть
 * возвращает количество «хороших пар»
 * одинаковых элементов в массиве.
 * 
 * Параметры
 * - nums — массив целых чисел
 *
 * Пример для:
 *   nums = [1,2,3,1,1,3]
 * Результат:
 *   4
 * Пояснение:
 *   Существует 4 хороших пары
 *   c индексами
 *   (0,3), (0,4), (3,4), (2,5)
 */
function numIdenticalPairs(nums) {

  // Инициализируем счетчик result, в
  // котором будем аккумулировать
  // количество найденных хороших пар.
  //
  // Начинаем с 0 потому что до обхода
  // массива пар еще нет.
  let result = 0;

  // Создаём новую Map под названием
  // numFreq для учёта того, сколько
  // раз каждое конкретное число уже
  // встречалось в пройденной части
  // массива (т.е. до текущего
  // элемента).
  //
  // Ключ — число из массива,
  // значение — сколько раз это
  // число уже встречалось при
  // проходе слева направо.
  const numFreq = new Map();

  // Проходим по массиву nums 
  //
  // Для каждого элемента num мы
  // учитываем, сколько таких же
  // элементов уже встречалось
  // ранее.
  for (const num of nums) {

    // Получаем текущее количество
    // ранее встреченных элементов,
    // равных num.
    //
    // Если ключа ещё нет в Map,
    // numFreq.get(num) вернёт
    // undefined, и оператор ??
    // подставит 0.
    const freq = numFreq.get(num) ?? 0;

    // Что делает эта строка
    // - Переменная freq хранит, сколько
    //   раз текущее значение уже
    //   встречалось в пройденной части
    //   массива (т.е. до текущего
    //   индекса).
    //
    // - Когда мы видим новое вхождение
    //   значения, каждый из этих ранее
    //   встреченных элементов образует
    //   с ним пару
    //   (ранний индекс < текущего).
    //
    // - Поэтому количество новых пар,
    //   добавляемых к общему счётчику
    //   result, ровно равно freq
    //
    // - Запись result += freq добавляет
    //   это число новых пар к
    //   накопленному результату.
    //
    // Почему это корректно — инвариант
    // и локальная логика
    // - Инвариант при входе в итерацию:
    //   в numFreq для каждого значения
    //   x хранится число его вхождений
    //   среди элементов с
    //   индексами меньше текущего.
    //   Значит, для текущего элемента
    //   num все возможные пары, где
    //   второй элемент — текущий, и
    //   первый элемент имеет тот же
    //   value, уже перечислены и их
    //   количество равно freq.
    //
    // - Никакая такая пара не будет
    //   учтена дважды, потому что мы
    //   считаем только пары, где второй
    //   элемент — текущий (i < j),
    //   а предыдущие элементы уже
    //   фиксировали порядок.
    //
    // - После добавления freq и
    //   обновления numFreq (увеличения
    //   счёта для num) инвариант
    //   сохраняется для следующей
    //   итерации.
    //
    // Формальная проверка через
    // разбиение по значениям
    // (комбинаторный аргумент)
    // - Пусть для некоторого конкретного
    //   значения v в массиве встретилось
    //   m вхождений (в разных индексах).
    //   Нас интересуют пары индексов
    //   (i, j) с i < j
    //   и nums[i] = nums[j] = v.
    //
    // - Количество таких пар равно числу
    //   способов выбрать 2 индекса из m:
    //   C(m, 2) = m·(m−1)/2.
    //
    // - Алгоритм добавляет для этого
    //   значения при последовательной
    //   обработке вхождений: при k-ом
    //   вхождении (k от 1 до m) он
    //   добавляет k−1 (в нашем
    //   обозначении это freq на момент
    //   к-го вхождения). Сумма по k от
    //   1 до m равна
    //   0 + 1 + 2 + ... + (m−1) = m·(m−1)/2.
    //
    // - Следовательно, суммарный вклад
    //   всех вхождений v в result совпадает
    //   с C(m,2), а суммарно по всем
    //   значениям даёт точное искомое
    //   количество пар. Это доказывает
    //   корректность result += freq
    //
    // Иллюстрация на примере
    // nums = [1,2,3,1,1,3]
    // - Рассмотрим значение 1:
    //   вхождения по порядку — 1-я позиция
    //   (k=1), 4-я (k=2), 5-я (k=3).
    //   - При k=1 freq = 0 → добавлено 0.
    //   - При k=2 freq = 1 → добавлено 1.
    //   - При k=3 freq = 2 → добавлено 2.
    //   - Сумма для 1: 0+1+2 = 3 = C(3,2).
    //
    // - Для значения 3:
    //   вхождения k=1 и k=2
    //   → добавлено 0 и 1
    //   → суммарно 1 = C(2,2) = 1.
    //
    // - Итого:
    //   3 + 1 = 4 — ровно то,
    //   что вычисляет алгоритм.
    result += freq;

    // Обновляем (или создаём) запись
    // в Map:
    // 
    // Увеличиваем частоту числа
    // num на 1, т.е. фиксируем, что
    // встретили ещё один элемент со
    // значением num.
    numFreq.set(num, freq + 1);
  }

  // Пример работы цикла для
  // nums = [1, 2, 3, 1, 1, 3]
  //
  // Исходные значения перед циклом:
  //   result = 0;
  //   numFreq = {} (пустая Map).
  //
  //
  // Шаг 1 — обрабатываем num = 1
  // - Перед вычислением freq: 
  //   result = 0;
  //   numFreq = {}.
  //
  // - Вычисляем 
  //   freq = numFreq.get(1) ?? 0 = 0.
  //
  // - Выполняем 
  //   result += freq
  //   → result = 0 + 0 = 0.
  //
  // - Обновляем частоту:
  //   numFreq.set(1, freq + 1)
  //   → numFreq = {1: 1}
  //
  //
  // Шаг 2 — обрабатываем num = 2
  // - Перед вычислением freq: 
  //   result = 0;
  //   numFreq = {1: 1}.
  //
  // - Вычисляем 
  //   freq = numFreq.get(2) ?? 0 = 0
  //
  // - Выполняем
  //   result += freq
  //   → result = 0 + 0 = 0
  //
  // - Обновляем частоту:
  //   numFreq.set(2, freq + 1)
  //   → numFreq = {1: 1, 2: 1}
  //
  //
  // Шаг 3 — обрабатываем num = 3
  // - Перед вычислением freq: 
  //   result = 0;
  //   numFreq = {1: 1, 2: 1}
  //
  // - Вычисляем 
  //   freq = numFreq.get(3) ?? 0 = 0
  //
  // - Выполняем 
  //   result += freq
  //   → result = 0 + 0 = 0
  //
  // - Обновляем частоту:
  //   numFreq.set(3, freq + 1)
  //   → numFreq = {1: 1, 2: 1, 3: 1}
  //
  //
  // Шаг 4 — обрабатываем num = 1
  // - Перед вычислением freq:
  //   result = 0;
  //   numFreq = {1: 1, 2: 1, 3: 1}
  //
  // - Вычисляем 
  //   freq = numFreq.get(1) ?? 0 = 1
  //
  // - Выполняем 
  //   result += freq
  //   → result = 0 + 1 = 1
  //
  // - Обновляем частоту:
  //   numFreq.set(1, freq + 1)
  //   → numFreq = {1: 2, 2: 1, 3: 1}
  //
  //
  // Шаг 5 — обрабатываем num = 1
  // - Перед вычислением freq:
  //   result = 1;
  //   numFreq = {1: 2, 2: 1, 3: 1}
  //
  // - Вычисляем 
  //   freq = numFreq.get(1) ?? 0 = 2
  //
  // - Выполняем 
  //   result += freq
  //   → result = 1 + 2 = 3
  //
  // - Обновляем частоту:
  //   numFreq.set(1, freq + 1)
  //   → numFreq = {1: 3, 2: 1, 3: 1}
  //
  //
  // Шаг 6 — обрабатываем num = 3
  // - Перед вычислением freq: 
  //   result = 3;
  //   numFreq = {1: 3, 2: 1, 3: 1}
  //
  // - Вычисляем
  //   freq = numFreq.get(3) ?? 0 = 1
  //
  // - Выполняем
  //   result += freq
  //   → result = 3 + 1 = 4
  //
  // - Обновляем частоту:
  //   numFreq.set(3, freq + 1)
  //   → numFreq = {1: 3, 2: 1, 3: 2}
  //
  //
  // После завершения цикла результат
  // result = 4, что соответствует
  // числу пар индексов (i, j) с i < j
  // и одинаковыми значениями в
  // массиве.

  // После прохода по всем элементам
  // возвращаем общее количество хороших
  // пар в массиве
  return result;
};
