/**
 * @param {string} s
 * @return {number}
 * 
 * maxScore для строки, состоящей только из символов
 * '0' и '1', выбирает позицию разбиения на две
 * непустые подстроки так, чтобы количество нулей в
 * левой плюс количество единиц в правой было
 * максимально.  
 * 
 * Параметры
 *   s — строка состоящая из символов '0' и '1'  
 * 
 * Возвращает
 *   число (целое), равное максимальному значению
 *   zeros_left + ones_right по всем допустимым
 *   разбиениям строки s.  
 * 
 * Пример для:
 *   s = "011101"
 * Результат:
 *   5
 * Пояснение:
 *   Все возможные способы разбиения строки s на
 *   две непустые подстроки:
 *   left = "0" и right = "11101", score = 1 + 4 = 5
 *   left = "01" и right = "1101", score = 1 + 3 = 4
 *   left = "011" и right = "101", score = 1 + 2 = 3
 *   left = "0111" и right = "01", score = 1 + 1 = 2
 *   left = "01110" и right = "1", score = 2 + 1 = 3
 */
function maxScore(s) {

  // Инициализация счётчика нулей, которые
  // находятся в левой части текущего разбиения.
  //
  // На старте левая часть содержит только s[0],
  // но счётчики ещё не установлены.
  let zeroCnt = 0;

  // Инициализация счётчика единиц, которые
  // находятся в левой части текущего разбиения.
  //
  // zeroCnt и oneCnt вместе отражают состав
  // левой части при сдвиге границы разбиения.
  let oneCnt = 0;

  // Проверяем первый символ строки s[0], потому
  // что цикл ниже начинает с i = 1, а левая
  // часть при первом рассмотрении разбиения уже
  // содержит s[0].
  //
  // Если первый символ '0', учитываем его в
  // zeroCnt.
  //
  // Если первый символ не '0' (то есть '1'),
  // учитываем его в oneCnt.
  if (s[0] === '0') zeroCnt++;
  else oneCnt++;

  // Инициализируем переменную maxDiff очень
  // маленьким значением (-Infinity), чтобы при
  // первом вызове Math.max любое реальное
  // значение (zeroCnt - oneCnt) заменило её.
  // 
  // maxDiff будет хранить максимум выражения
  // (zeroCnt - oneCnt) для всех рассмотренных
  // позиций разбиения до текущей итерации.
  let maxDiff = -Infinity;

  // Проходим по строке начиная с индекса 1
  // (второй символ).
  //
  // Идея:
  // мы рассматриваем разбиение между символами,
  // и на каждой итерации левая часть содержит
  // символы перед текущим символом s[i]
  // - s[0..i-1], а правая — s[i..end].
  //
  // Почему цикл начинается с i = 1 и не с 0:
  // Если бы цикл начинался с 0, то первая
  // проверка соответствовала бы разбиению до
  // первого символа (пустая левая часть), что
  // запрещено условием задачи (обе части должны
  // быть непустыми). Поэтому корректно
  // стартовать с 1, чтобы левая часть содержала
  // хотя бы один символ, и правая — как минимум
  // один символ.
  //
  // ---
  //
  // Алгоритм сводит задачу максимизации
  // zeros_left + ones_right при разбиении
  // строки на поиск максимума выражения
  // zero_left - one_left, а затем добавляет
  // общее число единиц — Это позволяет
  // избежать повторных подсчётов правой части
  // и получить решение за один проход по
  // строке, что даёт линейный по времени и
  // константный по памяти метод.
  // 
  // ---
  //
  // Основная идея алгоритма
  // Что нужно найти
  //
  // Нужно выбрать позицию разбиения двоичной
  // строки s на две непустые части так,
  // чтобы число нулей в левой части плюс
  // число единиц в правой части было
  // максимально.
  // 
  // ---
  //
  // Ключевое преобразование
  //
  // Вместо того чтобы для каждой позиции
  // пересчитывать отдельно нули слева и
  // единицы справа, алгоритм использует
  // алгебраическое преобразование:
  // - Обозначим totalOnes — общее число
  //   единиц в строке.
  //
  // - Для фиксированной границы:
  //   zeros_left + ones_right
  //   = zeros_left + (totalOnes - ones_left)
  //   = (zeros_left - ones_left) + totalOnes.
  //
  // Следовательно, достаточно найти максимум
  // выражения zeros_left - ones_left по всем
  // допустимым границам, а затем прибавить
  // totalOnes. Это уменьшает задачу к
  // отслеживанию одной разницы при одном
  // проходе по строке.  
  // 
  // ---
  // 
  // Как это реализуется пошагово
  //
  // - Инициализация: считаем первый символ
  //   как принадлежащий левой части (потому
  //   что первая допустимая граница — после
  //   первого символа). Поддерживаем два
  //   счётчика: zeroCnt и oneCnt для левой
  //   части в процессе обхода.
  //
  // - Проход по строке: на каждой итерации
  //   сначала обновляем текущий максимум
  //   maxDiff = max(maxDiff, zeroCnt - oneCnt),
  //   затем сдвигаем границу вправо,
  //   добавляя текущий символ в левую часть
  //   (инкрементируем zeroCnt или oneCnt).
  //
  //   Почему важен такой порядок (сначала
  //   обновление maxDiff, потом счётчиков)
  //   - Если сначала увеличить счётчики, то
  //     мы бы проверяли разрез после
  //     включения s[i] в левую часть (то
  //     есть разрез перед i+1). Но код
  //     намеренно фиксирует значение для
  //     разреза перед текущим символом s[i],
  //     потому что s[0] уже учтён вне цикла
  //     и цикл должен рассматривать все
  //     возможные места разреза между
  //     символами.
  //
  //   - Таким образом цикл перебирает все
  //     допустимые разрезы строки: между
  //     s[0] и s[1], между s[1] и s[2],
  //     ..., между s[n-2] и s[n-1]`.
  //
  // - Финал: после полного прохода oneCnt
  //   равен общему числу единиц totalOnes,
  //   поэтому ответ равен
  //   maxDiff + totalOnes — это и есть
  //   максимальное zeros_left + ones_right.
  // 
  // ---
  // 
  // Почему это эффективно
  // - Время O(n): строка обходится один раз,
  //   каждую границу мы оцениваем за O(1)
  //   операций, поэтому общая сложность
  //   линейная.
  //
  // - Память O(1): нужны только несколько
  //   счётчиков и переменных для хранения
  //   максимума, дополнительных массивов не
  //   требуется.
  // 
  // ---
  // 
  // Интуиция и пример
  //
  // Представьте, что вы идёте слева направо и
  // накапливаете «прибыль» от нулей и «убыток»
  // от единиц в левой части: 
  // profit = zeros_left - ones_left. В любой
  // момент этот profit показывает, насколько
  // выгодно иметь текущую левую часть. Добавив
  // фиксированное количество всех единиц, вы
  // получаете реальную оценку для разбиения.
  // Для s = "011101" такой подход быстро даёт
  // оптимум 5 без пересчётов правой части для
  // каждой границы.  
  // 
  // Важно:
  // Это стандартный приём для задач с суммой двух
  // частей — свести к максимуму разницы и
  // добавить константу, чтобы избежать
  // квадратичных решений.
  for (let i = 1; i < s.length; i++) {

    // На каждой итерации обновляем maxDiff как
    // максимум между текущим maxDiffи текущей
    // разностью zeroCnt - oneCnt, где zeroCnt и
    // oneCnt отражают состав левой части до
    // включения s[i] в левую часть.
    //
    // Эта разность пригодится для вычисления
    // итоговой формулы
    maxDiff = Math.max(maxDiff, zeroCnt - oneCnt);

    // После того как мы учли разбиение перед
    // s[i], добавляем s[i] в левую часть для
    // последующих итераций:
    //
    // Если текущий символ '0', увеличиваем
    // счётчик нулей.
    //
    // Если текущий символ '1', увеличиваем
    // счётчик единиц.
    if (s[i] === '0') zeroCnt++;
    else oneCnt++;
  }

  // Пример работы цикла для s = "011101"
  // 
  // ---
  //
  // Начальное состояние перед входом в цикл
  // Строка: '0 1 1 1 0 1' (индексы 0..5).  
  // Перед циклом мы уже обработали s[0],
  // поэтому 
  //  zeroCnt = 1 
  //  oneCnt = 0
  //  maxDiff = -Infinity
  // 
  // ---
  //
  // Итерация i = 1
  // рассматриваем разрез перед s[1]
  //
  // - Перед обновлением:
  //     zeroCnt = 1
  //     oneCnt = 0  
  //
  // - Вычисляем разность:
  //     zeroCnt - oneCnt = 1 - 0 = 1.  
  //
  // - Обновляем maxDiff: 
  //     maxDiff = max(-Infinity, 1) = 1.  
  //
  // - Теперь включаем s[1] в левую часть:
  //     s[1] — это '1', значит oneCnt
  //     увеличивается: oneCnt = 1.  
  //
  // - После итерации:
  //     zeroCnt = 1
  //     oneCnt = 1
  //     maxDiff = 1
  //
  // ---
  // 
  // Итерация i = 2
  // рассматриваем разрез перед s[2]
  //
  // - Перед обновлением: 
  //     zeroCnt = 1
  //     oneCnt = 1
  //
  // - Разность:
  //     zeroCnt - oneCnt = 0
  //
  // - Обновляем maxDiff:
  //     maxDiff = max(1, 0) = 1
  //     (без изменений).  
  //
  // - Включаем s[2] ('1') в левую часть:
  //     oneCnt = 2  
  //
  // - После итерации:
  //     zeroCnt = 1
  //     oneCnt = 2
  //     maxDiff = 1
  //
  // ---
  // 
  // Итерация i = 3
  // рассматриваем разрез перед s[3]
  //
  // - Перед обновлением:
  //     zeroCnt = 1
  //     oneCnt = 2
  //
  // - Разность:
  //     zeroCnt - oneCnt = -1
  //
  // - Обновляем maxDiff:
  //     maxDiff = max(1, -1) = 1
  //     (без изменений).  
  //
  // - Включаем s[3] ('1') в левую часть:
  //     oneCnt = 3
  //
  // - После итерации:
  //     zeroCnt = 1
  //     oneCnt = 3
  //     maxDiff = 1
  //
  // ---
  // 
  // Итерация i = 4
  // рассматриваем разрез перед s[4]
  //
  // - Перед обновлением:
  //     zeroCnt = 1
  //     oneCnt = 3
  //
  // - Разность:
  //     zeroCnt - oneCnt = -2
  //
  // - Обновляем maxDiff:
  //     maxDiff = max(1, -2) = 1
  //     (без изменений).  
  //
  // - Включаем s[4] ('0') в левую часть:
  //     zeroCnt = 2
  //
  // - После итерации:
  //     zeroCnt = 2
  //     oneCnt = 3
  //     maxDiff = 1
  //
  // ---
  // 
  // Итерация i = 5
  // рассматриваем разрез перед s[5]
  //
  // - Перед обновлением:
  //     zeroCnt = 2
  //     oneCnt = 3
  //
  // - Разность:
  //     zeroCnt - oneCnt = -1
  //
  // - Обновляем maxDiff:
  //     maxDiff = max(1, -1) = 1
  //     (без изменений).  
  //
  // - Включаем s[5] ('1') в левую часть:
  //     oneCnt = 4
  //
  // - После итерации:
  //     zeroCnt = 2
  //     oneCnt = 4
  //     maxDiff = 1
  // 
  // ---
  //
  // Состояние после завершения цикла
  // - oneCnt = 4 (это общее число единиц в
  //   строке)
  //
  // - zeroCnt = 2,
  //
  // -  maxDiff = 1 (максимум зафиксированной
  //    разности `zeroLeft - oneLeft`).
  //
  // Функция возвращает
  // maxDiff + oneCnt = 1 + 4 = 5, что
  // соответствует максимальному значению
  // #0_в_левой + #1_в_правой для всех
  // возможных разбиений строки.

  // После завершения цикла maxDiff содержит
  // максимальную из наблюдаемых разниц
  // (zeroCnt - oneCnt) для левой части перед
  // добавлением соответствующего символа.
  // 
  // oneCnt в этот момент — это общее
  // количество единиц в левой части после
  // включения всех символов, добавленных в
  // левую часть в процессе итераций.
  //
  // Возвращаем сумму:
  // Максимальная разница (вклад левой части)
  // + текущее количество единиц в левой
  // части.
  //
  // Это эквивалентно максимальному значению
  // (нулей в левой части + единиц в правой
  // части) для некоторого разбиения.
  return maxDiff + oneCnt;
}
