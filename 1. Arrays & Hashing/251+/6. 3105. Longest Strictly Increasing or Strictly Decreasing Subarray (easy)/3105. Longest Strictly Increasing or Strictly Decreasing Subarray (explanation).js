/**
 * @param {number[]} nums
 * @return {number}
 * 
 * longestMonotonicSubarray принимает один
 * аргумент nums — массив чисел.
 * 
 * Функция возвращает длину самой длинной
 * подряд идущей монотонной (строго
 * возрастающей или строго убывающей)
 * подпоследовательности внутри nums.
 * 
 * Пример для:
 *   nums = [1,4,3,3,2]
 * Результат:
 *   2
 * Объяснение:
 *   Строго возрастающий подмассив:
 *     [1,4]    
 *   Строго убывающие подмассивы:
 *     [4,3] и [3,2]
 *   Максимальная длинна из всех
 *   подмассивов равна 2.
 */
function longestMonotonicSubarray(nums) {
  // Если массив пуст, возвращаем 0 как
  // длину максимальной
  // подпоследовательности
  if (!nums.length) return 0;

  // Инициализация result как 1:
  // минимально возможная длина монотонного
  // подмассива (если массив не пустой,
  // любой одиночный элемент сам по себе
  // монотонен).
  let result = 1;

  // Счётчик inc хранит длину текущего
  // подряд идущего строго возрастающего
  // сегмента, который закончился на
  // предыдущем (или текущем) индексе.
  //
  // Начинаем с 1, потому что один
  // элемент — это возрастающий сегмент
  // длины 1.
  let inc = 1;

  // Счётчик dec хранит длину текущего
  // подряд идущего строго убывающего
  // сегмента, который закончился на
  // предыдущем (или текущем) индексе.
  //
  // Начинаем с 1, потому что один
  // элемент — это убывающий сегмент
  // длины 1.
  let dec = 1;

  // Проходим по массиву с i = 1 до конца,
  // сравнивая каждый элемент с предыдущим,
  // чтобы понять, продолжается ли рост,
  // спад или есть равенство.
  //
  // Начинаем с i = 1, так как на каждой 
  // итерации идет сравнение с предыдущим
  // элементом
  for (let i = 1; i < nums.length; i++) {

    // Если предыдущий и текущий элементы
    // равны, это прерывает как строго
    // возрастающую, так и строго убывающую
    // последовательность.
    //
    // Оба счётчика сбрасываем в 1, потому
    // что текущий элемент сам по себе
    // представляет подмассив длины 1.
    if (nums[i - 1] === nums[i]) {
      inc = dec = 1;

      // Если текущий элемент больше
      // предыдущего, то продолжается
      // (или начинается) строго
      // возрастающая последовательность.
      //
      // Увеличиваем inc на 1. При этом
      // строго убывающая
      // последовательность прерывается,
      // поэтому сбрасываем dec в 1.
    } else if (nums[i - 1] < nums[i]) {
      inc++;
      dec = 1;

      // В противоположном случае
      // предыдущий элемент больше
      // текущего.
      //
      // Это продолжение (или начало)
      // строго убывающей
      // последовательности, поэтому
      // увеличиваем dec.
      //
      // При этом возрастающая
      // последовательность
      // прерывается, поэтому
      // сбрасываем inc в 1.
    } else {
      inc = 1;
      dec++;
    }

    // После обработки текущего шага
    // обновляем глобальный максимум
    // result:
    //
    // Записываем в result наибольшее
    // из текущих значений
    // result, inc, dec.
    //
    // Это гарантирует, что result
    // всегда содержит длину самой
    // длинной найденной до текущего
    // момента строго возрастающей или
    // строго убывающей подряд идущей
    // подпоследовательности.
    result = Math.max(result, inc, dec);

    // Пример работы цикла для
    // nums = [1, 4, 3, 3, 2]
    //
    // Начальные значения перед циклом:
    // result = 1,
    // inc = 1, 
    // dec = 1
    //
    // Шаг 1 i = 1: 
    // Сравниваем nums[0] = 1
    // и nums[1] = 4  
    // - Условие:
    //     1 < 4 — ветка возрастания.  
    // - Действия:
    //     inc++ → inc = 2;
    //     dec = 1 (сброс).  
    // - Обновление результата:
    //     result = max(1, 2, 1) = 2.  
    // - Значения после шага: 
    //     result = 2,
    //     inc = 2,
    //     dec = 1
    //
    // Шаг 2 i = 2:
    // сравниваем nums[1] = 4
    // и nums[2] = 3:  
    // - Условие:
    //     4 > 3 — ветка убывания.  
    // - Действия:
    //     inc = 1 (сброс);
    //     dec++ → dec = 2.  
    // - Обновление результата:
    //     result = max(2, 1, 2) = 2.  
    // - Значения после шага:
    //     result = 2,
    //     inc = 1, 
    //     dec = 2
    //
    // Шаг 3 i = 3:
    // сравниваем nums[2] = 3
    // и nums[3] = 3):  
    // - Условие:
    //     3 === 3 — ветка равенства.  
    // - Действия:
    //     inc = dec = 1 (оба сбрасываются).  
    // - Обновление результата:
    //     result = max(2, 1, 1) = 2.  
    // - Значения после шага:
    //     result = 2,
    //     inc = 1,
    //     dec = 1
    //
    // Шаг 4 i = 4:
    // сравниваем nums[3] = 3
    // и nums[4] = 2):  
    // - Условие:
    //     3 > 2 — ветка убывания.  
    // - Действия:
    //     inc = 1 (сброс);
    //     dec++ → dec = 2.  
    // - Обновление результата:
    //     result = max(2, 1, 2) = 2.  
    // - Значения после шага:
    //     result = 2,
    //     inc = 1,
    //     dec = 2
    //
    // Итог после завершения цикла:
    //   result = 2
  }

  // Возвращаем итоговое значение
  // — длину наибольшей строго
  // возрастающей или строго
  // убывающей подпоследовательности
  // в массиве
  return result;
}