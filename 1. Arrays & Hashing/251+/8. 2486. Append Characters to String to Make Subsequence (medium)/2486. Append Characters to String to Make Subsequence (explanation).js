/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 * 
 * appendCharacters вычисляет, сколько
 * символов нужно добавить в конец
 * строки s, чтобы строка t стала
 * подпоследовательностью строки s.
 * 
 * Параметры:
 * - s — строка, в которой ищут
 *       символы последовательности t.  
 * - t — строка, которую нужно сделать
 *       подпоследовательностью s.
// 
// Что возвращает:
// Функция возвращает целое число
// — минимальное количество символов
// из конца строки t, которые
// необходимо добавить к s, чтобы t
// полностью встретилась как
// подпоследовательность. Если t уже
// является подпоследовательностью s,
// возвращается 0.
//
// Пример:
//   Для:
//     s = "coaching", t = "coding"
//   Результат:
//     4
//   Объяснение:
//    к  s = "coaching" нужно
//    добавить "ding" из t
//    получаем "coachingding" 
//    "ding".length → 4
 */
function appendCharacters(s, t) {

  // Инициализация указателя j на 0.
  //
  // j будет отслеживать, сколько
  // символов из t уже последовательно
  // совпало с символами в s (то есть
  // прогресс подпоследовательности)
  let j = 0;

  // Пробегаем через все символы строки
  // s слева направо
  for (let i = 0; i < s.length; i++) {

    // Сравниваем текущий символ s[i]
    // с текущим символом t[j].
    //
    // Если они совпадают, это значит,
    // что мы нашли следующий требуемый
    // символ из t, поэтому увеличиваем
    // j, продвигая указатель по
    // строке t
    //
    // j сохраняет информацию о том,
    // сколько символов t уже совпало
    // по порядку.
    //
    // Замечание по поведению при
    // j === t.length:
    // в этом случае
    // t[j] === undefined и сравнение
    // всегда ложно, поэтому j
    // перестанет меняться и цикл
    // просто будет игнорировать
    // оставшиеся символы s.
    if (s[i] === t[j]) j++;
  }

  // Пример работы цикла
  // 
  // 
  // Исходные данные:
  // - s: "coaching"  
  // - t: "coding"  
  // - i — индекс в s
  //      (перебирается циклом)  
  // - j — текущий индекс в t
  //       (указывает на символ,
  //       который мы сейчас
  //        ищем)  
  // - стрелки показывают
  //   позиции указателей:
  //   s с маркером ^ под текущим i
  //   t с маркером ^ под текущим j
  //
  // ---
  // 
  // Шаги выполнения
  // 
  // Шаг 1 (i = 0)
  //   
  //    s: coaching
  //       ^
  //    i=0  j=0
  //    t: coding
  //       ^
  //    t[j] = 'c'  s[i] = 'c'
  //   совпадение → j → 1
  //   
  // 
  // Шаг 2 (i = 1)
  //    
  //    s: coaching
  //        ^
  //    i=1  j=1
  //    t: coding
  //        ^
  //    t[j] = 'o'  s[i] = 'o'
  //    совпадение → j → 2
  // 
  // 
  // Шаг 3 (i = 2)
  // 
  //    s: coaching
  //         ^
  //    i=2  j=2
  //    t: coding
  //         ^
  //    t[j] = 'd'  s[i] = 'a'
  //    не совпадает → j остаётся 2
  // 
  // 
  // Шаг 4 (i = 3)
  //
  //    s: coaching
  //          ^
  //    i=3  j=2
  //    t: coding
  //         ^
  //    t[j] = 'd'  s[i] = 'c'
  //    не совпадает → j остаётся 2
  //
  // 
  // Шаг 5 (i = 4)
  //
  //    s: coaching
  //           ^
  //    i=4  j=2
  //    t: coding
  //         ^
  //    t[j] = 'd'  s[i] = 'h'
  //    не совпадает → j остаётся 2
  //
  // 
  // Шаг 6 (i = 5)
  //
  //    s: coaching
  //            ^
  //    i=5  j=2
  //    t: coding
  //         ^
  //    t[j] = 'd'  s[i] = 'i'
  //    не совпадает → j остаётся 2
  //
  // 
  // Шаг 7 (i = 6)
  //
  //    s: coaching
  //             ^
  //    i=6  j=2
  //    t: coding
  //         ^
  //    t[j] = 'd'  s[i] = 'n'
  //    не совпадает → j остаётся 2
  //
  // 
  // Шаг 8 (i = 7)
  //
  //    s: coaching
  //              ^
  //    i=7  j=2
  //    t: coding
  //         ^
  //    t[j] = 'd'  s[i] = 'g'
  //    не совпадает → j остаётся 2
  //
  // 
  // Итог
  // - По завершении цикла j = 2,
  //   то есть найдены первые два
  //   символа t: 'c' и 'o'.  
  // - Функция вернёт
  //   t.length − j = 6 − 2 = 4.
  //   Нужно добавить 4 символа из
  //   конца t, чтобы t стала
  //   подпоследовательностью s.


  // После прохода по s значение
  // j — количество начальных символов
  // t, которые удалось покрыть в
  // порядке следования (то есть длина
  // совпавшей префиксной
  // подпоследовательности).
  //
  // Возвращаем число символов,
  // которых не хватило: общая длина t
  // минус количество уже найденных (j).
  // Это минимальное число символов,
  // которые нужно "дописать" к s,
  // чтобы t стала
  // подпоследовательностью s.
  return t.length - j;
};