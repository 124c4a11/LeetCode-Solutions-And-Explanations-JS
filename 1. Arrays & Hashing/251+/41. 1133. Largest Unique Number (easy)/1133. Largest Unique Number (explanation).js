/**
 * @param {number[]} nums
 * @return {number}
 * 
 * largestUniqueNumber находит наибольшее число, которое
 * встречается в массиве nums ровно один раз, и
 * возвращает его.
 * 
 * Если таких чисел нет, возвращает -1
 * 
 * Пример для:
 *   nums = [5,7,3,9,4,9,8,3,1]
 * Результат:
 *   8
 * Пояснение:
 *   Максимальное целое число в массиве — 9, но оно
 *   повторяется. Число 8 встречается только один раз,
 *   поэтому оно и является ответом.
 */
function largestUniqueNumber(nums) {

  // Создаём новый пустой Set для хранения чисел,
  // которые на текущем этапе обхода считаются
  // уникальными.
  //
  // Set обеспечивает быстрые операции проверки
  // наличия, добавления и удаления элементов.
  const uniqueSet = new Set();

  // Итерируемся по каждому элементу входного
  // массива nums по порядку
  for (const num of nums) {

    // Проверяем, содержится ли текущее число num
    // в множестве uniqueSet.
    //
    // Операция has выполняется за
    // амортизированное константное время.
    if (uniqueSet.has(num)) {

      // Если число уже есть в множестве, это
      // означает, что мы встретили его второй
      // (или более) раз, поэтому оно перестаёт
      // быть уникальным — удаляем его из
      // множества
      uniqueSet.delete(num);
    } else {

      // Если числа ещё нет в множестве, это
      // первая встреча — добавляем его в
      // множество, чтобы пометить как
      // потенциально уникальное (пока оно не
      // встретится снова)
      uniqueSet.add(num);
    }
  }

  // Инициализация переменной largest значением -1.
  //
  // -1 используется как индикатор отсутствия
  // уникальных чисел, предполагая, что входные числа
  // не могут быть меньше -1 в контексте задачи (или
  // что -1 — корректный "не найдено")
  let largest = -1;

  // Итерируемся по всем элементам множества
  // uniqueSet.
  //
  // В множестве теперь находятся только те числа,
  // которые встретились в исходном массиве ровно
  // один раз.
  for (const num of uniqueSet) {

    // Для каждого уникального числа обновляем
    // значение largest, выбирая максимальное
    // между текущим largest и num.
    //
    // Math.max гарантирует корректную работу даже
    // если largest ещё равен начальному значению
    // -1
    largest = Math.max(largest, num);
  }

  // Возвращаем найденное наибольшее уникальное
  // число.
  //
  // Если уникальных чисел не было, largest
  // по-прежнему равен -1, и функция вернёт -1.
  return largest;
}
