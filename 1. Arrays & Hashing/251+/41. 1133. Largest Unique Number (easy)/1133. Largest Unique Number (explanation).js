/**
   * @param {number[]} nums
   * @return {number}
   * 
   * largestUniqueNumber находит наибольшее число, которое
   * встречается в массиве nums ровно один раз, и
   * возвращает его.
   * 
   * Если таких чисел нет, возвращает -1
   * 
   * Пример для:
   *   nums = [5,7,3,9,4,9,8,3,1]
   * Результат:
   *   8
   * Пояснение:
   *   Максимальное целое число в массиве — 9, но оно
   *   повторяется. Число 8 встречается только один раз,
   *   поэтому оно и является ответом.
   */
function largestUniqueNumber(nums) {

  // Создаём новую Map для хранения соответствия
  // «число → количество вхождений».
  const numToFreq = new Map();

  // Запускаем цикл по всем элементам входного массива
  // nums
  for (const num of nums) {
    numToFreq.set(num, (numToFreq.get(num) ?? 0) + 1);
  }

  // Инициализация переменной largest значением -1.
  //
  // -1 используется как индикатор отсутствия
  // уникальных чисел, предполагая, что входные числа
  // не могут быть меньше -1 в контексте задачи (или
  // что -1 — корректный "не найдено")
  let largest = -1;

  // Перебираем пары [ключ, значение] в Map.
  //
  // При итерации Map возвращает массивы [key, value].
  for (const [num, freq] of numToFreq) {

    // Если частота больше 1, число не уникально
    // — пропускаем его с помощью continue, не
    // выполняя дальнейших действий в теле цикла.
    if (freq > 1) continue;

    // Если число уникально (freq === 1), обновляем
    // largest:
    //
    // Выбираем максимальное между текущим largest
    // и текущим числом num.
    largest = Math.max(largest, num);
  }

  // Возвращаем значение largest:
  //
  // Либо наибольшее уникальное число, либо -1,
  // если уникальных чисел не было.
  return largest;
}
