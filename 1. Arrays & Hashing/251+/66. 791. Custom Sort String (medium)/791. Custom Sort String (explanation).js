/**
 * @param {string} order
 * @param {string} s
 * @return {string}
 * 
 * customSortString(order, s) переставляет символы строки
 * s так, чтобы символы,  перечисленные в строке order,
 * шли в том же относительном порядке, а все остальные
 * символы из s добавлялись после них.
 * 
 * Возвращает новую строку с результатом.
 * 
 * Параметры: 
 * - order — строка. Задаёт пользовательский порядок букв
 *   (уникальные строчные латинские буквы).
 * 
 * - s — исходная строка, символы которой нужно
 *   переставить в соответствии с order.
 * 
 * 
 * Пример для:
 *   order = "cba",
 *   s = "abcd"
 * Результат:
 *   "cbad"
 * Пояснение:
 *   "a", "b", "c" присутствуют в order, поэтому порядок
 *   "a", "b", "c" в результате должен быть "c", "b", "a".
 * 
 *   Поскольку "d" не встречается в order, оно может
 *   находиться в любой позиции в возвращаемой строке.
 * 
 *   "dcba", "cdba", "cbda" также являются допустимыми
 *   результатами.
 */
function customSortString(order, s) {

  // Создаём массив фиксированной длины 26 типа
  // Int32Array для хранения частот букв латинского
  // алфавита 'a'..'z'.
  //
  // Использование Int32Array экономит память и даёт
  // быстрый доступ по индексу.
  //
  // Индекс массива соответствует букве:
  // 0 → 'a', 1 → 'b', ..., 25 → 'z'. 
  //
  // Значение — частота вхождения этой буквы в строке s.
  //
  // Все элементы инициализируются нулём.
  const sCharToFreq = new Int32Array(26);

  // Итерация по каждому символу входной строки s.
  for (const char of s) {

    // Получаем числовой код символа (UTF-16/Unicode),
    // вычитаем 97 (код 'a') чтобы получить индекс в
    // диапазоне 0..25.
    //
    // s.codePointAt(i) возвращает числовой код
    // Unicode символа в позиции i.
    //
    // Для строчных латинских букв код 'a' равен 97,
    // поэтому вычитание 97 даёт индекс для каждой 
    // буква в диапазоне 0..25, где
    // 0 → 'a', 1 → 'b', ..., 25 → 'z'.
    //
    // Затем увеличиваем соответствующий счётчик в
    // массиве частот.
    sCharToFreq[char.codePointAt(0) - 97]++;
  }

  // Создаём массив result для накопления фрагментов
  // результирующей строки.
  //
  // Использование массива и последующий join
  // эффективнее многократной конкатенации строк.
  const result = [];

  // Проходим по каждому символу в строке order, чтобы
  // сначала добавить буквы в требуемом порядке.
  for (const char of order) {

    // Вычисляем индекс буквы в массиве
    // частот по коду символа аналогично предыдущему
    // шагу.
    //
    // Здесь также предполагается, что символы в
    // order — строчные латинские буквы.
    const i = char.codePointAt(0) - 97;

    // Добавляем в массив result строку, состоящую из
    // повторений текущего символа char, количество
    // повторений равно ранее подсчитанной частоте
    // sCharToFreq[i].
    result.push(char.repeat(sCharToFreq[i]));

    // Обнуляем счётчик для этой буквы, чтобы
    // исключить её из последующей фазы добавления
    // оставшихся букв.
    //
    // Это предотвращает дублирование символов,
    // которые уже были размещены в соответствии с
    // order.
    sCharToFreq[i] = 0;
  }

  // Проходим по всем возможным индексам букв от 0 до 25,
  // чтобы добавить те символы из s, которые не были
  // перечислены в order.
  // 
  // Это гарантирует, что все символы из s попадут в
  // результат.
  for (let i = 0; i < 26; i++) {

    // Если для текущего индекса нет оставшихся символов
    // (значение 0), пропускаем итерацию.
    // 
    // Оператор continue ускоряет цикл, избегая лишних
    // операций.
    if (!sCharToFreq[i]) continue;

    // Восстанавливаем символ из его числового индекса:
    //
    // Прибавляем 97 чтобы получить код 'a'..'z', затем
    // создаём строку из этой кодовой точки. 
    //
    // String.fromCodePoint корректно обрабатывает
    // Unicode.
    const char = String.fromCodePoint(i + 97);

    // Добавляем в результат повторяющийся символ char
    // столько раз, сколько осталось в sCharToFreq[i].
    // 
    // Это помещает все оставшиеся буквы в алфавитном
    // порядке (по возрастанию индекса i).
    result.push(char.repeat(sCharToFreq[i]));

    // Обнуляем счётчик после добавления, что делает
    // состояние массива частот чистым, чтобы явно
    // показать, что все экземпляры учтены.
    // (необязательно для результата, но логично)
    sCharToFreq[i] = 0;
  }

  // Объединяем все элементы массива result в одну строку
  // без разделителя и возвращаем её.
  //
  // Итоговая строка содержит сначала символы в порядке,
  // заданном order, затем все остальные символы из s в
  // алфавитном порядке.
  return result.join('');
}
