/**
 * @param {number[]} nums
 * @return {boolean}
 * 
 * isMonotonic проверяет, монотонен ли массив
 * чисел.
 * 
 * Массив считается монотонным, если он либо
 * неубывает (каждое следующее значение >=
 * предыдущего), либо невозрастает (каждое
 * следующее значение <= предыдущего).
 * 
 * Функция возвращает true, если массив
 * монотонен, и false, если нет.
 * 
 * Параметры:
 * - nums — массив чисел.
 * 
 * Примеры использования:
 * - isMonotonic([1, 2, 2, 3])
 *   возвращает true.
 * 
 * - isMonotonic([5, 4, 4, 1])
 *   возвращает true.
 * 
 * - isMonotonic([1, 3, 2])
 *   возвращает false.
 */
function isMonotonic(nums) {

  // Быстрая проверка тривиальных случаев:
  // Массивы длины 0, 1 или 2 всегда
  // считаются монотонными, поскольку два
  // элемента не могут одновременно
  // образовать и возрастание и убывание
  // в разных местах.
  //
  // Для nums = [1, 3, 2] длина = 3, поэтому
  // это условие не выполнится и исполнение
  // продолжится.
  if (nums.length <= 2) return true;

  // Инициализация флага isInc = true:
  // 
  // Предположение, что до текущего момента
  // массив может быть неубывающим.
  //
  // "Неубывающий" означает, что для всех
  // соседних пар nums[i-1] <= nums[i]
  // (строгое равенство разрешено).
  let isInc = true;

  // Инициализация флага isDec = true:
  // 
  // Предположение, что до текущего момента
  // массив может быть невозрастающим.
  //
  // "Невозрастающий" означает, что для всех
  // соседних пар nums[i-1] >= nums[i]
  // (строгое равенство разрешено).
  let isDec = true;

  // Запуск цикла по индексам массива,
  // начиная с 1.
  // 
  // Начинаме с 1, чтобы иметь возможность
  // на каждой итерации сравнивать предыдущий
  // элемент nums[i - 1] с текущим nums[i].
  //
  // Проход по всем парам соседних элементов
  // последовательно проверяет признаки
  // возрастания и убывания.
  for (let i = 1; i < nums.length; i++) {

    // Если предыдущий элемент строго меньше
    // текущего (nums[i - 1] < nums[i]),
    // значит в этой паре наблюдается
    // возрастание. Это нарушает условия 
    // невозрастания, поэтому устанавливаем
    // isDec = false, так как массив уже не
    // может быть полностью невозрастающим.
    //
    // Для nums = [1, 3, 2]:
    // - i = 1:
    //   nums[0] = 1 < nums[1] = 3
    //   → обнаружено возрастание
    //   → isDec становится false.
    //
    // - i = 2:
    //   nums[1] = 3 < nums[2] = 2
    //   → условие ложно
    //   → isDec остаётся false.
    if (nums[i - 1] < nums[i]) isDec = false;

    // Если предыдущий элемент строго больше
    // текущего (nums[i - 1] > nums[i]),
    // значит в этой паре наблюдается
    // убывание. Это нарушает условия
    // неубывания, поэтому устанавливаем
    // isInc = false, так как массив уже не
    // может быть полностью неубывающим.
    //
    // Для nums = [1, 3, 2]:
    // - i = 1:
    //   nums[0] = 1 > nums[1] = 3
    //   → условие ложно,
    //   → isInc остаётся true.
    //
    // - i = 2:
    //   nums[1] = 3 > nums[2] = 2
    //   → обнаружено убывание
    //   → isInc становится false.
    if (nums[i - 1] > nums[i]) isInc = false;

    // Если в какой-то момент оба флага стали
    // false, значит в массиве присутствуют
    // и возрастания, и убывания в разных
    // местах — однозначно не монотонный
    // массив. В этом случае можно сразу
    // вернуть false, прервав дальнейшие
    // проверки.
    //
    // Для nums = [1, 3, 2]:
    // - i = 1:
    //   isInc = true,
    //   isDec = false
    //   → не оба false
    //   → продолжаем.
    //
    // - i = 2:
    //   isInc = false,
    //   isDec = false
    //   → оба false
    //   → возвращаем false
    if (!isInc && !isDec) return false;
  }

  // Если цикл завершился без того, чтобы оба
  // флага одновременно стали false, значит
  // массив либо полностью неубывающий
  // (isInc = true), либо полностью
  // невозрастающий (isDec = true),
  // либо все элементы равны (оба флага
  // останутся true). В этих случаях
  // возвращаем true.
  //
  // Для nums = [1, 3, 2] исполнение не
  // дойдёт до этой строки, потому что на
  // шаге i = 2 было возвращено false.
  return true;
};
