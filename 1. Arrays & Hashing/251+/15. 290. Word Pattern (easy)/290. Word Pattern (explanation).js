/**
 * @param {string} pattern
 * @param {string} s
 * @return {boolean}
 * 
 * wordPattern проверяет, соответствует ли
 * заданный шаблон pattern
 * последовательности слов в строке s
 * в смысле взаимно-однозначного
 * соответствия (биекция). То есть каждому
 * символу шаблона соответствует ровно
 * одно слово, и одному и тому же слову
 * соответствует только один символ.
 * 
 * Возвращает true, если соответствие
 * соблюдено для всех позиций, или false,
 * если найдено несоответствие, или длины
 * шаблона и списка слов различаются.
 * 
 * Параметры
 * - pattern — строка, представляющая
 *   шаблон символов. Каждый символ
 *   шаблона должен соответствовать
 *   одному слову в строке s.
 * 
 * - s — строка, содержащая слова,
 *   разделённые пробелами 
 * 
 * Пример:
 *   Для:
 *     pattern = "abba",
 *     s = "dog cat cat dog"
 * 
 *   Результат:
 *     true
 *   
 *   Пояснение:
 *     Биекция может быть установлена
 *     так:
 *       'a' сопоставляется с "dog".
 *       'b' сопоставляется с "cat".
 */
function wordPattern(pattern, s) {

  // Разбиваем строку s по пробелам на
  // массив слов.
  // 
  // Пример:
  // Для s = "dog cat cat dog"
  // получим ["dog","cat","cat","dog"].
  const words = s.split(' ');

  // Сравниваем количество символов в
  // pattern и количество слов в words.
  //
  // Если они не равны, то
  // сопоставление невозможно, потому
  // что каждому символу должен
  // соответствовать ровно один
  // элемент.
  //
  // Для примера:
  // pattern.length = 4,
  // words.length = 4 — условие
  // выполнено и работа функции
  // продолжается.
  if (pattern.length !== words.length) {
    return false;
  }

  // Создаём Map, в котором
  // ключ — символ шаблона,
  // значение — слово из строки s.
  //
  // Для примера:
  // после первого шага charToWord
  // может содержать {'a' => 'dog'}
  // и затем
  // {'a' => 'dog', 'b' => 'cat'}.
  const charToWord = new Map();

  // Создаём обратный Map, где
  // ключ — слово из s,
  // значение — символ шаблона.
  //
  // Это нужно, чтобы гарантировать
  // биективность (один символ — одно
  // слово и одно слово — один символ).
  //
  // Без этого возможна ситуация,
  // когда разным символам
  // сопоставляется одно и то же слово.
  //
  // Для примера:
  // wordToChar будет содержать
  // {'dog' => 'a', 'cat' => 'b'}.
  const wordToChar = new Map();

  // Проходим в цикле по индексам
  // символов шаблона
  // (и по соответствующим словам
  // одновременно).
  for (let i = 0; i < pattern.length; i++) {

    // Получаем текущий символ шаблона
    // по индексу i.
    const char = pattern[i];

    // Получаем слово из массива words
    // на той же позиции i.
    const word = words[i];

    // Проверяем, что пока что нет
    // сопоставления ни в charToWord
    // для текущего символа, ни в
    // wordToChar для текущего слова.
    // Это означает, что этот символ
    // и это слово ещё не связаны.
    //
    // Используется сочетательная
    // проверка: если оба отсутствуют,
    // можно установить новое
    // соответствие.
    //
    // Для примера:
    //  - i=0: 
    //    'a' и 'dog' отсутствуют
    //     → создаём 'a'=>'dog'
    //             и 'dog'=>'a'
    //
    //  - i=1: 
    //    'b' и 'cat' отсутствуют
    //    → создаём 'b'=>'cat'
    //            и 'cat'=>'b'
    //
    //  - i=2:
    //    'b' и 'cat' присутствуют
    //     → не заходим в этот блок,
    //       идёт проверка
    //       согласованности
    //
    //  - i=3:
    //    'a' и 'dog' присутствуют
    //    → не заходим в этот блок,
    //      идёт проверка
    //      согласованности
    if (
      !charToWord.has(char)
      && !wordToChar.has(word)
    ) {

      // Устанавливаем сопоставление
      // символа к слову.
      //
      // После этой операции
      // для i=0 'a' => 'dog',
      // для i=1 'b' => 'cat'.
      charToWord.set(char, word);

      // Устанавливаем обратное
      // сопоставление слова к символу.
      //
      // Это обеспечивает проверку на
      // ситуацию, когда два разных
      // символа пытаются ссылаться
      // на одно слово.
      //
      // После этой операции
      // для i=0 'dog' => 'a',
      // для i=1 'cat' => 'b'.
      wordToChar.set(word, char);

      // continue пропускает оставшуюся
      // часть тела цикла и переходит к
      // следующей итерации, потому что
      // для только что созданного
      // сопоставления дополнительной
      // проверки не требуется.
      continue;
    }

    // Если хотя бы одно из сопоставлений
    // уже присутствует, нужно убедиться
    // в их согласованности.
    //
    // Берём существующее значение
    // charToWord.get(char) и
    // существующее значение
    // wordToChar.get(word) и сравниваем
    // с текущими значениями.
    // Оба направления должны совпадать.
    //
    // Для примера:
    //
    //  - i=2:
    //    char = 'b',
    //    word = 'cat'
    //    charToWord.get('b') === 'cat'
    //    wordToChar.get('cat') === 'b'
    //    → OK
    //
    //  - i=3:
    //    char = 'a'
    //    word = 'dog'
    //    charToWord.get('a') === 'dog'
    //    wordToChar.get('dog') === 'a'
    //    → OK
    //
    // Если хотя бы одно из сравнений
    // не выполняется, значит шаблон
    // нарушен (несовместимость) и
    // возвращаем false.
    if (
      charToWord.get(char) !== word
      || wordToChar.get(word) !== char
    ) return false;
  }

  // Если цикл завершился без конфликтов
  // сопоставлений, значит каждый символ
  // шаблона соответствует ровно одному
  // слову и каждое слово соответствует
  // ровно одному символу — шаблон
  // выполнен, возвращаем true.
  //
  // Для примера 
  // pattern = "abba"
  // s = "dog cat cat dog"
  // функция вернёт true.
  return true;
};
