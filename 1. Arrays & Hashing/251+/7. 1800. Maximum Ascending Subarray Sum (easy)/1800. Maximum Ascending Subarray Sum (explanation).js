/**
 * @param {number[]} nums
 * @return {number}
 * 
 * maxAscendingSum возвращает максимальную
 * сумму элементов подряд идущей строго
 * возрастающей подпоследовательности
 * (подмассива) внутри переданного массива.
 * При этом последовательность считается
 * прерванной, если текущий элемент меньше
 * или равен предыдущему, и тогда сумма
 * для новой последовательности начинается
 * заново.
 * 
 * Параметры:
 *   nums — массив чисел (Array of Number). 
 * 
 * Пример:
 *   Для:
 *     nums = [10,20,30,5,10,50]
 *   Результат: 
 *     65
 *   Объяснение:
 *     [5,10,50] — восходящий подмассив
 *     с максимальной суммой 65.   
 */
function maxAscendingSum(nums) {

  // Инициализируем result значением
  // первого элемента массива.
  //
  // Это гарантия корректности на случай,
  // если все остальные суммы будут меньше
  // первого элемента или массив длины 1.
  let result = nums[0];

  // Создаётся локальная переменная
  // currSum и инициализируется первым
  // элементом массива nums[0].
  //
  // Инициализация первым элементом
  // массива nums[0] допустима, так как
  // цикл по nums начинается с nums[1]
  //
  // currSum аккумулирует сумму
  // текущей рассматриваемой строго
  // возрастающей подпоследовательности,
  // то есть суммы последовательных
  // элементов, где каждый следующий
  // больше предыдущего.
  let currSum = nums[0];

  // Цикл for перебирает массив
  // начиная со второго элемента
  // (индекс 1) до последнего.
  //
  // Перебор по индексам начиная со
  // второго элемента позволяет
  // сравнивать текущий элемент с
  // предыдущим для проверки строгого
  // возрастания.
  for (let i = 1; i < nums.length; i++) {

    // Проверяем, не прерывается ли
    // строгое возрастание между
    // предыдущим и текущим
    // элементами.
    //
    // Условие nums[i - 1] >= nums[i]
    // означает, что текущий элемент
    // не больше предыдущего, то есть
    // последовательность не строго
    // возрастающая и нужно начать
    // новую последовательность.
    if (nums[i - 1] >= nums[i]) {

      // Если последовательность
      // прервалась, сбрасываем
      // currSum в 0.
      //
      // Сброс в 0 выбран потому,
      // что дальше мы сразу
      // добавляем текущий элемент
      // к currSum, и это
      // эквивалентно началу новой
      // последовательности с этого
      // элемента.
      currSum = 0;
    }

    // К текущей (возможно только что
    // сброшенной) сумме добавляется
    // значение текущего элемента
    // nums[i].
    //
    // Если currSum был сброшен, после
    // сложения currSum будет равен
    // nums[i], иначе — продолжается
    // накопление.
    currSum += nums[i];

    // Обновляем result максимумом
    // между текущим result и currSum.
    //
    // Таким образом result всегда
    // содержит наибольшую сумму из
    // всех просмотренных возрастающих
    // подпоследовательностей.
    result = Math.max(result, currSum);
  }

  // Возвращаем result — максимальную
  // найденную сумму строго
  // возрастающей непрерывной
  // подпоследовательности.
  return result;
};