/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 * 
 * canPlaceFlowers принимает два параметра:
 *  flowerbed — массив из 0 и 1,
 *    где 0 означает пустой участок,
 *    1 — уже занятый цветком;
 *  n — количество дополнительных цветов,
 *    которые нужно попытаться посадить.
 * 
 * Функция вернёт true, если можно
 * расположить не менее n цветов с учётом
 * правила:
 * запрещено размещать соседние цветы
 * (т.е. между любыми двумя цветами
 * должен быть хотя бы один 0).
 * 
 * Пример для:
 *   flowerbed = [1,0,0,0,1]
 *   n = 1
 * 
 * Результат:
 *   true
 */
function canPlaceFlowers(flowerbed, n) {

  // Инициализация счётчика подряд
  // идущих пустых ячеек empty.
  //
  // Здесь учитывается особая логика
  // для левой границы: если первая
  // ячейка пуста (0), её считаем как
  // виртуально "свободную соседнюю"
  // позицию слева, что даёт возможность
  // посадить цветок в первой ячейке
  // без дополнительной проверки левого
  // соседа.
  //
  // Пример:
  // если flowerbed начинается с 0,
  // empty = 1, иначе 0.
  let empty = flowerbed[0] === 0 ? 1 : 0;

  // Итерируем по каждой ячейке грядки
  for (let f of flowerbed) {

    // Если текущая ячейка занята (1)
    // — значит последовательность
    // предыдущих пустых ячеек завершилась.
    if (f === 1) {

      // Мы встретили конец серии пустых
      // участков (если они были перед
      // текущим 1), поэтому вычисляем,
      // сколько новых цветов можно было
      // разместить в этой серии.
      //
      // 
      // Когда мы доходим до существующего
      // цветка, все пустые клетки,
      // накопленные в empty, идут в блок,
      // который ограничен слева либо
      // предыдущей занятой клеткой, либо
      // началом массива (учтённым через
      // initial empty), а справа — текущей
      // единицей. Правой границе нельзя
      // ставить цветок, поэтому одну
      // позицию из пустого блока
      // отбрасываем, а оставшиеся позиции
      // дают floor((empty - 1)/2)
      // возможных посадок.
      // 
      // 
      // Пошаговое разложение выражения
      // 
      // - empty - 1  
      //   Убирает одну пустую позицию,
      //   прилегающую к найденной единице.
      //   Эта прилегающая позиция не может
      //   быть использована для посадки,
      //   потому что рядом уже стоит цветок.
      // 
      // - Math.max(0, empty - 1)
      //   Гарантирует, что если после
      //   вычитания получается
      //   отрицательное значение
      //   (последовательность слишком
      //   коротка), мы заменим его на 0
      //   и не создадим отрицательное
      //   число посадок.
      // 
      // - ... / 2
      //   Каждая новая посадка требует
      //   двух пустых ячеек между уже
      //   стоящими цветами (одна слева,
      //   одна справа), поэтому количество
      //   возможных посадок в отрезке
      //   равно длине доступной части,
      //   делённой на 2.
      // 
      // - Math.floor(...)
      //   Берёт целую часть результата
      //   деления, потому что нельзя
      //   посчитать дробную (нецелую)
      //   посадку.
      // 
      // - n -= ...
      //   Уменьшает требуемое число
      //   посадок на количество,
      //   которое реально можно
      //   разместить в текущем блоке
      //   пустых клеток.
      //
      // 
      // Быстрая проверка на примере
      // из запроса
      // 
      // Для flowerbed = [1,0,0,0,1]
      // при подходе к правой единице
      // накопленное empty = 3.  
      //
      // Вычисляем:
      // Math.max(0, 3 - 1) = 2
      //  → Math.floor(2 / 2) = 1.  
      //
      // Это означает, что в этом блоке
      // пустых клеток перед правой
      // единицей можно посадить ровно
      // 1 цветок, и этот результат
      // вычитается из n.
      n -= Math.floor(Math.max(0, empty - 1) / 2);

      // Сброс счётчика подряд идущих
      // пустых ячеек, потому что
      // встретился занятый слот (1),
      // и дальнейший подсчёт пустот
      // начинается заново после этого
      // занятого слота.
      empty = 0;
    } else {

      // Если текущая ячейка пуста (0),
      // увеличиваем текущую серию
      // подряд идущих пустых ячеек.
      empty++;
    }
  }

  // После выхода из цикла остаётся
  // последняя серия пустых ячеек,
  // которая может заканчиваться
  // правой границей массива.
  //
  // 
  // Эта строка обрабатывает
  // последнюю последовательность
  // подряд идущих пустых ячеек,
  // которая остаётся после прохода
  // по всему массиву flowerbed.
  // Она уменьшает требуемое
  // количество посадок n на число
  // цветов, которые можно посадить
  // в этой конечной пустой секции,
  // при условии правила: нельзя
  // ставить цветы в соседние клетки.
  // 
  // Почему деление на 2 и
  // округление вниз
  // - В последовательности пустых
  //   ячеек без ограничений
  //   (например, 0000...) между
  //   двумя посаженными растениями
  //   обязательно должна быть по
  //   крайней мере одна пустая ячейка.
  //   Это значит, что каждые две
  //   доступные пустые позиции дают
  //   возможность посадить максимум
  //   один цветок. Формула
  //   "каждые 2 → 1" эквивалентна
  //   целочисленному делению длины
  //   последовательности на 2.
  //
  // - Округление вниз (Math.floor)
  //   необходимо, потому что дробные
  //   посадки невозможны: если
  //   осталось 3 пустых клетки,
  //   можно поставить только
  //   1 цветок, не 1.5.
  // 
  // Почему здесь нет вычитания 1
  // (в отличие от предыдущей
  // формулы
  // Math.max(0, empty - 1) / 2)
  // - Внутри цикла, когда
  //   последовательность пустых
  //   ячеек
  //   заканчивается встречей
  //   занятой ячейки 1, правая
  //   граница секции закрыта
  //   занятым слотом. Тогда один
  //   край секции (сосед к 1)
  //   делает одну из пустых
  //   позиций непригодной для
  //   посадки, поэтому
  //   используется empty - 1
  //   перед делением.
  //
  // - Для последней секции
  //   в конце массива правая
  //   граница — не занятая
  //   ячейка, а конец массива.
  //   Конец рассматривается
  //   как «виртуально свободный»
  //   край, то есть нет
  //   дополнительного занятого
  //   соседа справа, который бы
  //   «отнимал» одну позицию.
  //   Поэтому для секции в конце
  //   массива формула проще:
  //   empty / 2.
  n -= Math.floor(empty / 2);

  // Возвращаем true если после
  // распределения n стало <= 0
  // (все необходимые цветы
  // размещены), иначе false.
  //
  // Логика:
  // если n стало <= 0, значит
  // у нас  достаточно
  // свободных мест для посадки
  // n цветов.
  return n <= 0;
};