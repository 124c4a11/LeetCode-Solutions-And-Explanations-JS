/**
 * @param {string} text
 * @return {number}
 * 
 * maxNumberOfBalloons рассчитывает, сколько
 * раз можно полностью составить слово
 * "balloon" из букв заданной строки. 
 * 
 * Возвращает число представляющее
 * максимальное количество полных слов,
 * которое можно собрать из имеющихся букв.
 * 
 * Параметры
 * - text — строка, в котором функция ищет
 *   буквы для составления слова "balloon".
 * 
 * Пример:
 *   Для:
 *      text = "nlaebolko"
 *   Результат:
 *     1
 */
function maxNumberOfBalloons(text) {

  // Создаём Map  под названием для
  // хранения счётчиков букв, которые
  // нужны для составления слова
  // "balloon".
  // 
  // Инициализируем только нужные буквы
  // значением 0.
  //
  // Использование Map здесь даёт быстрые
  // операции поиска и установки по ключу.
  const balloonMap = new Map([
    ['b', 0],
    ['a', 0],
    ['l', 0],
    ['o', 0],
    ['n', 0]
  ]);

  // Итерация по каждому символу входной
  // строки text.
  for (const char of text) {

    // Проверка:
    // Содержит ли balloonMap текущий
    // символ char.
    //
    // Это фильтр:
    // Если символ не входит в набор
    // букв, необходимых для "balloon",
    // мы его не учитываем и пропускаем
    // итерацию.
    if (!balloonMap.has(char)) continue

    // Если символ присутствует как
    // ключ в balloonMap, увеличиваем
    // его счётчик на 1.
    //
    // balloonMap.get(char) получает
    // текущее значение, затем set
    // записывает новое значение.
    balloonMap.set(char, balloonMap.get(char) + 1);
  }

  // После подсчёта всех букв
  // возвращаем максимально возможное
  // количество слов "balloon", которое
  // можно составить из имеющихся букв.
  //
  // Для этого берём минимум по
  // ограничивающим буквам:
  //
  // 'b' и 'a' и 'n' используются по 1
  // на слово,
  //
  // l' и 'o' используются по 2 на слово,
  // поэтому делим их счётчики на 2 и
  // округляем вниз.
  //
  // Деление на 2 переводит количество
  // найденных таких букв в число
  // возможных слов, которые можно
  // собрать, если считать только по
  // этой букве.
  //
  // Деление может дать дробное число,
  // но количество полных слов должно
  // быть целым. Math.floor отбрасывает
  // дробную часть и возвращает
  // количество полностью собранных пар
  // букв. Это предотвращает ошибочное
  // учёное допущение, что, например,
  // 3 буквы l дают 1.5 слова — на самом
  // деле дают только 1 полное слово.
  //
  // Примеры
  //
  // - Если найдено l = 0 
  //   → Math.floor(0 / 2) = 0
  //   → нельзя составить слово по
  //     букве l.  
  //
  // - Если найдено l = 1
  //   → Math.floor(1 / 2) = 0
  //   → одна l - не хватает для
  //     полного слова.  
  //
  // - Если найдено l = 2 
  //   → Math.floor(2 / 2) = 1 
  //   → ровно одна пара l 
  //   → возможно одно слово.  
  //
  // - Если найдено l = 3 
  //   → Math.floor(3 / 2) = 1 
  //   → ровно одна пара l 
  //   → возможно одно слово.  
  //   → остаётся одна лишняя l,
  //     но она не даёт второго
  //     полного слова.  
  //
  // - Если найдено l = 4 
  //   → Math.floor(4 / 2) = 2 
  //   → две полные пары l 
  //   → возможно два слова.  
  return Math.min(

    // Количество доступных букв 'b'
    balloonMap.get('b'),

    // Количество доступных букв 'a'
    balloonMap.get('a'),

    // Для 'l' требуется 2 буквы на
    // слово, поэтому используем
    // Math.floor(count / 2)
    Math.floor(balloonMap.get('l') / 2),

    // Для 'o' также требуется 2
    // буквы на слово
    Math.floor(balloonMap.get('o') / 2),

    // Количество доступных букв 'n'
    balloonMap.get('n')
  );

  // Пример для text = "nlaebolko"
  //
  //
  // Начальное состояние balloonMap
  //
  // balloonMap:
  // { b: 0, a: 0, l: 0, o: 0, n: 0 }
  //
  // ---
  //
  // Итерация 1 — символ 'n'
  //
  // - Обработка:
  //   'n' присутствует в карте,
  //   увеличиваем счётчик n на 1.
  // - после 'n':
  //   { b: 0, a: 0, l: 0, o: 0, n: 1 }
  //
  // ---
  //
  // Итерация 2 — символ 'l'
  //
  // - Обработка:
  //   'l' присутствует в карте,
  //   увеличиваем счётчик l на 1.
  // - после 'l':
  //   { b: 0, a: 0, l: 1, o: 0, n: 1 }
  //
  // ---
  //
  // Итерация 3 — символ 'a'
  //
  // - Обработка:
  //   'a' присутствует в карте,
  //   увеличиваем счётчик a на 1.
  // - после 'a':
  //   { b: 0, a: 1, l: 1, o: 0, n: 1 }
  //
  // ---
  //
  // Итерация 4 — символ 'e'
  //
  // - Обработка:
  //   'e' не в карте,
  //   пропускаем (continue).
  //   Счётчики не меняются.
  // - после 'e' (пропуск):
  //   { b: 0, a: 1, l: 1, o: 0, n: 1 }
  //
  // ---
  //
  // Итерация 5 — символ 'b'
  //
  // - Обработка:
  //   'b' присутствует в карте,
  //   увеличиваем счётчик b на 1.
  // - после 'b':
  //   { b: 1, a: 1, l: 1, o: 0, n: 1 }
  //
  // ---
  //
  // Итерация 6 — символ 'o'
  //
  // - Обработка:
  //   'o' присутствует в карте,
  //   увеличиваем счётчик o на 1.
  // - после первого 'o':
  //   { b: 1, a: 1, l: 1, o: 1, n: 1 }
  //
  // ---
  //
  // Итерация 7 — символ 'l' (второй раз)
  //
  // - Обработка:
  //   'l' присутствует в карте,
  //   увеличиваем счётчик l на 1.
  // - после второго 'l':
  //   { b: 1, a: 1, l: 2, o: 1, n: 1 }
  //
  // ---
  //
  // Итерация 8 — символ 'k'
  //
  // - Обработка: 'k' не в карте,
  //   пропускаем. Счётчики не меняются.
  // - после 'k' (пропуск):
  //   { b: 1, a: 1, l: 2, o: 1, n: 1 }
  //
  // ---
  //
  // Итерация 9 — символ 'o' (второй раз)
  //
  // - Обработка: 'o' присутствует в карте,
  //   увеличиваем счётчик o на 1.
  // - финальное состояние:
  //   { b: 1, a: 1, l: 2, o: 2, n: 1 }
  //
  // ---
  //
  // Вычисление итогового результата
  //
  // - Подсчёты по буквам:
  //   - b = 1
  //   - a = 1
  //   - l = 2 → Math.floor(2 / 2) = 1
  //   - o = 2 → Math.floor(2 / 2) = 1
  //   - n = 1
  // - Итоговое значение:
  //   Math.min(1, 1, 1, 1, 1) = 1
  //
  // Ответ функции
  // для text = "nlaebolko" → 1.
};
