/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 * 
 * canConstruct проверяет, можно ли составить строку
 * ransomNote, используя символы из строки magazine.
 * 
 * Параметры
 * - ransomNote — строка. Целевая заметка, которую
 *   нужно составить (искомая последовательность
 *   символов).  
 * 
 * - magazine — строка. Набор доступных символов, из
 *   которых можно брать буквы для составления
 *   ransomNote.
 * 
 * Пример 1:
 *   ransomNote = "aa"
 *   magazine = "ab"
 * Результат:
 *   false
 * 
 * Пример 2:
 *   ransomNote = "aa"
 *   magazine = "aab"
 * Результат:
 *   true
 */
function canConstruct(ransomNote, magazine) {

  // Сравниваем длины входных строк чтобы быстро
  // исключить невозможный вариант:
  //
  // Если требуемых символов в ransomNote больше,
  // чем всего доступно в magazine, дальнейшая
  // проверка бессмысленна.
  //
  // Немедленно возвращаем false, чтобы избежать
  // лишней работы.
  if (ransomNote.length > magazine.length) {
    return false;
  }

  // Создаём массив фиксированной длины 26 для
  // подсчёта частот букв в magazine.
  //
  // Индекс каждого элемента будет
  // соответствовать одной букве английского
  // алфавита:
  // индекс 0 — 'a', 1 — 'b', ..., 25 — 'z'
  //
  // По умолчанию значения всеx элементов равны 0
  //
  // Используется Int32Array для эффективности по
  // памяти и скорости. 
  //
  // Предполагается, что символы — латинские
  // строчные буквы a–z. Для других символов
  // индекс может выйти за пределы индексов 0–25.
  const magazineCharFreq = new Int32Array(26);

  // Итерация по каждому символу в строке magazine
  // для подсчёта сколько раз встречается каждая
  // буква в нем
  for (const char of magazine) {

    // Для текущего символа вычисляем его код
    // с помощью char.charCodeAt(0).
    //
    // Кодовая точка ASCII/UTF-16 для 'a'
    // равна 97, поэтому вычитаем 97, чтобы
    // получить индекс 0 для 'a'.
    //
    // Например, для 'c'
    // char.charCodeAt(0) = 99,
    // 99 - 97 = 2, то есть индекс 2.
    //
    // Затем по этому индексу в массиве
    // увеличиваем счетчик количества вхождений
    // текущего символа на 1.
    magazineCharFreq[char.charCodeAt(0) - 97]++;
  }

  // Создаём массив фиксированной длины 26 для
  // подсчёта частот букв в magazine.
  //
  // Индекс каждого элемента будет
  // соответствовать одной букве английского
  // алфавита:
  // индекс 0 — 'a', 1 — 'b', ..., 25 — 'z'
  //
  // По умолчанию значения всеx элементов равны 0
  //
  // Используется Int32Array для эффективности по
  // памяти и скорости. 
  //
  // Предполагается, что символы — латинские
  // строчные буквы a–z. Для других символов
  // индекс может выйти за пределы индексов 0–25
  const ransomCharFreq = new Int32Array(26);

  // Итерация по каждому символу в ransomNote.
  // 
  // Цель — проверять по мере подсчёта количества
  // вхождений каждого символа в ransomNote, не
  // превышает ли его количество в ransomNote
  // количества в magazine
  // 
  // Как только какой-то символ встречается в
  // ransomNote чаще, чем в magazine, возвращаем
  // false - в magazine недостаточно символов,
  // чтобы составить ransomNote
  for (const char of ransomNote) {

    // Вычисляем индекс буквы в диапазоне 0..25
    // по той же формуле: код символа минус 97.
    const i = char.charCodeAt(0) - 97;

    // Увеличиваем счётчик вхождения текущего
    // символа в массиве ransomCharFreq.
    ransomCharFreq[i]++

    // Если текущий символ встречается в
    // ransomNote чаще, чем в magazine,
    // возвращаем false - в magazine
    // недостаточно символов, чтобы составить
    // ransomNote
    if (ransomCharFreq[i] > magazineCharFreq[i]) {
      return false;
    }
  }

  // Если цикл завершился без досрочного возврата
  // false, значит в magazine достаточно букв, чтобы
  // составить ransomNote - возвращаем true.
  return true;
}
