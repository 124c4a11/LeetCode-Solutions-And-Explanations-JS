/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 * 
 * isIsomorphic проверяет являются ли строки
 * s и t изоморфными.
 * 
 * Строки являются изоморфными если:
 * - Длины строк равны;
 * - Каждому символу из s соответствует ровно
 *   один символ в t;
 * - Два разных символа в s не могут
 *   соответствовать одному и тому же символу
 *   в t; и сопоставление должно быть обратимо
 *   (биекция).
 * 
 * Пример истинности:
 *   s = "egg", t = "add" - g соответствует d,
 *   e соответствует a; соответствие сохраняет
 *   порядок и повторяемость символов.
 * 
 * Пример ложности:
 *   s = "foo", t = "bar" — символ o в s дважды
 *   должен соответствовать одному и тому же
 *   символу в t, но в t соответствующие символы
 *   разные, значит не изоморфны.
 *
 * Параметры:
 *   s — первая строка (последовательность символов).
 *   t — вторая строка той же длины, что и s,
 *       которую нужно проверить на изоморфизм.
 */
function isIsomorphic(s, t) {

  // Для каждой позиции i проверяется:
  // "Есть ли в части строки справа от i ещё повтор
  // этого символа?" — и сравнивается ответ
  // и позиция повторения в s и в t. 
  // Если ответы (позиции) везде совпадают, строки
  // рассматриваются как изоморфные.
  // Если для какого‑то i эти позиции различаются,
  // функция сразу возвращает false, означая,
  // что шаблоны повторения символов в строках не
  // совпадают.
  //
  //
  // Почему сравнение позиций следующего вхождения
  // работает для проверки изоморфности
  //
  // - s.indexOf(s[i], i + 1) возвращает индекс
  //   первого вхождения символа s[i] в s строго
  //   правее позиции i либо -1, если такого
  //   вхождения нет.  
  // - Аналогично для t.indexOf(t[i], i + 1).  
  // - Если для каждой позиции i оба результата
  //   равны (оба -1, или оба указывают на один и
  //   тот же относительный индекс), значит
  //   структура повторов символов в s и в t
  //   совпадает: символы, которые повторяются в s,
  //   повторяются в тех же местах относительно
  //   i в t, и символы, которые не повторяются,
  //   также отсутствуют дальше в обеих строках.
  //   Это обеспечивает согласованность отображения
  //   символов s → t по всей строке.
  //
  //
  // Интерпретация проверок
  //
  // - Для позиции, где символ не повторяется дальше,
  //   оба indexOf дадут -1.  
  // - Для позиции, где символ повторяется, indexOf
  //   вернёт индекс следующего повтора; равенство
  //   этих индексов для s и t означает, что повторы
  //   происходят в тех же относительных местах.  
  // - Если где‑то один символ повторяется, а другой
  //   нет, или повторы происходят в разных местах,
  //   сравнение обнаружит несоответствие и функция
  //   вернёт false.
  for (let i = 0; i < s.length; i++) {

    // Если позиции следующих вхождений не
    // совпадают (включая случай, когда один из
    // них -1, а другой нет), это означает, что
    // шаблоны повторов символов различаются,
    // значит строки не изоморфны.
    //
    // Немедленно возвращаем false, прерывая
    // проверку.
    if (
      s.indexOf(s[i], i + 1)
      !== t.indexOf(t[i], i + 1)
    ) return false;

    // Визуализация каждого шага для
    // s = "egg",
    // t = "add"
    //
    // Исходные строки:
    // - s = "egg" (индексы 0:'e', 1:'g', 2:'g')  
    // - t = "add" (индексы 0:'a', 1:'d', 2:'d')
    //
    // Шаг i = 0:
    // - s[i] = 'e';
    //   t[i] = 'a'.
    // - s.indexOf('e', 1)
    //   - ищем 'e' в s, начиная с индекса 1.
    //   - В s больше нет 'e',
    //   - результат = -1.
    // - t.indexOf('a', 1)
    //   - ищем 'a' в t, начиная с индекса 1
    //   - В t больше нет 'a',
    //   - результат = -1
    // - Сравнение:
    //     -1 !== -1 → false,
    //     то есть не возвращаем false,
    //     они равны, продолжаем.
    //
    // Шаг i = 1:
    // - s[i] = 'g';
    //   t[i] = 'd'.
    // - s.indexOf('g', 2)
    //   - ищем 'g' в s, начиная с индекса 2.
    //   - В s есть 'g' на индексе 2,
    //   - результат = 2.
    // - t.indexOf('d', 2)
    //   - ищем 'd' в t, начиная с индекса 2.
    //   - В t есть 'd' на индексе 2,
    //   - результат = 2.
    // - Сравнение:
    //     2 !== 2 → false,
    //     они равны, продолжаем.
    //
    // Шаг i = 2:
    // - s[i] = 'g';
    //   t[i] = 'd'.
    // - s.indexOf('g', 3)
    //   - ищем 'g' в s, начиная с индекса 3.
    //   - Индекс 3 вне строки, вхождений нет,
    //   - результат = -1.
    // - t.indexOf('d', 3)
    //   - ищем 'd' в t, начиная с индекса 3.
    //   - Вхождений нет,
    //   - результат = -1.
    // - Сравнение:
    //     -1 !== -1 → false,
    //     они равны.
    //
    // После последнего шага цикл завершён,
    // не было return false, значит функция
    // вернёт true: строки имеют одинаковую
    // структуру повторений и потому изоморфны.
  }

  // Если ни на одной итерации не сработал return false,
  // значит для всех позиций относительные позиции
  // следующих вхождений совпадают
  //
  // Для примера
  // "egg" и "add" функция вернёт true
  return true;
}
