/**
 * StringIterator - класс реализующий структуру данных для
 * итератора сжатой строки. Заданная сжатая строка имеет вид,
 * где каждая буква сопровождается положительным целым
 * числом, представляющим количество таких букв в исходной
 * несжатой строке.
 * 
 * Методы:
 * - char next() - Возвращает следующий символ, если исходная
 *   строка содержит несжатые символы, в противном случае
 *   возвращает пробел.
 * 
 * - boolean hasNext() - Возвращает true, если в исходной
 *   строке есть хоть одна буква, которую необходимо
 *   распаковать, в противном случае возвращает false.
 */
class StringIterator {
  /**
   * @param {string} compressedString
   */
  constructor(compressedString) {

    // Сохраняем ссылку на исходную сжатую строку.
    // 
    // Используется для последовательного разбора
    this.str = compressedString;

    // Сохраняем длину строки в отдельном поле, чтобы не
    // вычислять её повторно при каждой проверке границ
    this.n = this.str.length;

    // Индекс текущей позиции в строке.
    // 
    // Указывает на следующий необработанный символ в
    // this.str
    //
    // Начинается с 0 — до первого вызова next() мы ещё
    // ничего не прочитали.
    this.i = 0;

    // Счётчик оставшихся повторений текущего символа,
    // который ещё нужно вернуть.
    //
    // Хранит целое число >= 0.
    // 
    // Когда равен 0 — нужно разобрать следующий блок
    // (символ + число).
    this.num = 0;

    // Текущий символ (буква), который возвращается при
    // вызове next() до тех пор, пока num > 0.
    //
    // Инициализируется пробелом как безопасное значение
    // по умолчанию.
    // 
    // Реальное значение устанавливается при разборе.
    this.char = ' ';
  }

  /**
   * @return {character}
   * 
   * Метод возвращает следующий символ развернутой
   * последовательности. 
   * 
   * Если нет следующего символа — возвращает ' ' (пробел)
   * согласно контракту.
   */
  next() {

    // Если нет следующего символа (ни в текущем блоке,
    // ни в оставшейся части строки), возвращаем пробел
    // по контракту
    if (!this.hasNext()) return ' ';

    // Если текущий счётчик повторений равен нулю, значит
    // нужно прочитать новый блок из строки: 
    // сначала букву, затем число (возможно многозначное).
    if (this.num === 0) {

      // Берём символ по текущему индексу и сразу
      // инкрементируем индекс, чтобы следующий символ
      // в строке указывал на начало числа повторов.
      this.char = this.str[this.i++];

      // Цикл собирает последовательность цифр,
      // представляющих количество повторов.
      // 
      // Условия: 
      // 1. this.i < this.n — не вышли за пределы
      //    строки;  
      //
      // 2. !isNaN(this.str[this.i]) — текущий символ
      //    является цифрой.
      //
      //    isNaN('0') === false, поэтому отрицание
      //    !isNaN(...) истинно для цифр.
      while (
        this.i < this.n
        && !isNaN(this.str[this.i])
      ) {

        // Обновляем накопленное число:
        //
        // Сдвигаем предыдущие цифры влево (умножение на 10)
        // и добавляем значение текущей цифры.
        //
        // Number(...) преобразует строчный символ цифры в
        // числовое значение, затем индекс увеличивается,
        // чтобы перейти к следующему символу.
        this.num = this.num * 10 + Number(this.str[this.i++]);
      }
    }

    // После того как убедились, что у нас есть текущий символ и
    // счётчик num > 0, уменьшаем счётчик на единицу, потому что
    // собираемся вернуть один экземпляр символа.
    //
    // Важно:
    // Декремент происходит после возможного разбора числа,
    // поэтому корректно работает даже для многозначных чисел и
    // для случая, когда число было только что прочитано.
    this.num--;

    // Возвращаем текущий символ.
    //
    // Если число было 1, то после декремента num станет 0, и
    // при следующем вызове next() будет произведён разбор
    // следующего блока.
    return this.char;
  }

  /**
   * @return {boolean}
   * 
   * Метод проверяет, остались ли ещё символы для итерации.
   * 
   * Возвращает true, если либо в исходной строке ещё есть
   * необработанные символы (this.i !== this.n), либо если в
   * текущем блоке ещё остались повторы (this.num !== 0).
   */
  hasNext() {

    // Возвращаем true, если индекс ещё не достиг конца строки
    // или если в текущем блоке ещё есть повторы
    return this.i !== this.n || this.num !== 0;
  }
}

/**
 * Your StringIterator object will be instantiated and called as such:
 * var obj = new StringIterator(compressedString)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */
