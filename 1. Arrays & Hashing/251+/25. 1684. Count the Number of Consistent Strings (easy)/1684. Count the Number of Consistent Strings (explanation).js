/**
 * @param {string} allowed
 * @param {string[]} words
 * @return {number}
 * 
 * countConsistentStrings подсчитывает, сколько слов
 * из массива words полностью состоят только из
 * символов, разрешённых в строке allowed. Иначе
 * говоря, слово считается «согласованным», если
 * каждый его символ присутствует в allowed.
 * 
 * Параметры:
 * - allowed — строка (например, "ab", "abc" и т.п.).
 *   Предполагается, что она содержит строчные
 *   латинские буквы a–z. Каждая буква, встречающаяся
 *   в этой строке, считается разрешённой.
 * 
 * - words — массив строк. Каждое значение массива
 *   интерпретируется как слово, которое нужно
 *   проверить на то, что все его символы находятся
 *   в allowed.
 * 
 * Функция возвращает целое число — количество слов
 * из words, все символы которых содержатся в
 * allowed.
 * 
 * Пример для:
 *   allowed = "ab",
 *   words = ["ad","bd","aaab","baa","badab"]
 * Результат:
 *   2
 * Пояснение:
 *   Строки "aaab" и "baa" согласованы, так как
 *   они содержат только символы 'a' и 'b'.
 */
function countConsistentStrings(allowed, words) {

  // Создаём TypedArray Int32Array длиной 26,
  // где индекс каждого элемента будет
  // соответствовать одной букве английского
  // алфавита:
  // индекс 0 — 'a', 1 — 'b', ..., 25 — 'z'.
  //
  // Значения: каждый элемент содержит целое
  // число, фактически используемое как булев
  // флаг:
  //   0 — соответствующая буква НЕ разрешена
  //   (не встречалась в allowed).
  //
  //   1 — соответствующая буква разрешена
  //   (в allowed была записана эта буква).
  //
  // Использование Int32Array даёт компактное
  // представление и быстрый доступ по индексу.
  //
  // По умолчанию все элементы равны 0
  // (неразрешены).
  const charAllowed = new Int32Array(26);

  // Проходим по каждому символу в строке
  // allowed
  for (const char of allowed) {

    // Для текущего символа вычисляем его код
    // с помощью char.charCodeAt(0).
    //
    // Кодовая точка ASCII/UTF-16 для 'a'
    // равна 97, поэтому вычитаем 97, чтобы
    // получить индекс 0 для 'a'.
    //
    // Например, для 'c'
    // char.charCodeAt(0) = 99,
    // 99 - 97 = 2, то есть индекс 2.
    //
    // Затем по этому индексу в массиве
    // charAllowed записываем 1, что помечает
    // букву как разрешённую.
    charAllowed[char.charCodeAt(0) - 97] = 1;
  }

  // Инициализируем переменную result общим
  // количеством слов из массива words.
  //
  // Эта переменная будет уменьшаться на 1
  // для каждого слова, которое содержит хотя
  // бы один запрещённый символ.
  //
  // В итоге останется число «совместимых» слов.
  let result = words.length;

  // Проходим по каждому слову в массиве words
  for (const word of words) {

    // Для текущего слова проходим по каждой
    // букве (символу) этого слова
    for (const char of word) {

      // Для каждой буквы вычисляем её индекс
      // как char.charCodeAt(0) - 97 и
      // проверяем charAllowed[index].
      //
      // Если значение в charAllowed равно
      // 0 (false), значит буква не содержится
      // в allowed — слово несовместимо.
      if (!charAllowed[char.charCodeAt(0) - 97]) {

        // Если найден запрещённый символ,
        // уменьшаем счётчик result на 1,
        // потому что текущий символ слова не
        // соответствует символам allowed.
        result--;

        // Прерываем внутренний цикл по символам
        // слова, потому что достаточно одной
        // запрещённой буквы, чтобы исключить
        // слово
        //
        // Управление возвращается во внешний
        // цикл по словам.
        break;
      }
    }
  }

  // Возвращаем итоговое число слов, не содержащих
  // запрещённых символов — то есть совместимых со
  // строкой allowed.
  return result;
};
