/**
 * @param {character[][]} picture
 * @return {number}
 * 
 * findLonelyPixel подсчитывает количество «одиноких» чёрных
 * пикселей в изображении, представленного матрицей.
 * 
 * Пиксель считается одиноким, если он равен 'B' и при этом
 * в его строке ровно один чёрный пиксель, и в его столбце
 * ровно один чёрный пиксель.
 * 
 * Параметры
 * - picture — двумерный массив (матрица) значений, где
 *   каждая ячейка picture[r][c] — символ 'B' или 'W'.
 *   - 'B' - черный пиксель
 *   - 'W' - белый пиксель
 * 
 * 
 * Пример для:
 *   picture = [
 *     ["W","W","B"],
 *     ["W","B","W"],
 *     ["B","W","W"]
 *   ];
 * Результат:
 *   3
 * Пояснение:
 *   Все три буквы «B» — это одиночные чёрные пиксели.
 */
function findLonelyPixel(picture) {

  // Определяем число строк в входном изображении.
  // 
  // Используется для границ циклов и выделения массивов
  // счётчиков
  const ROWS = picture.length;

  // Определяем число столбцов по длине первой строки.
  // 
  // Предполагается, что все строки имеют одинаковую длину
  const COLS = picture[0].length;

  // Создаём массив фиксированной длины ROWS для хранения
  // количества чёрных пикселей в каждой строке.
  //
  // Индекс - номер строки
  //
  // Значение - количество черных пикселей в этой строке
  //
  // Int32Array экономичнее по памяти и гарантирует
  // целочисленные операции.
  // 
  // Все элементы инициализируются нулями.
  const rowToBlackPixelCnt = new Int32Array(ROWS);

  // Аналогично создаём массив для подсчёта чёрных пикселей
  // в каждом столбце.
  //
  // Индекс - номер столбца
  //
  // Значение - количество черных пикселей в этом столбце
  const colToBlackPixelCnt = new Int32Array(COLS);

  // Проходим по всем строкам матрицы
  for (let r = 0; r < ROWS; r++) {

    // Проходим по всем столбцам текущей строки r.
    for (let c = 0; c < COLS; c++) {

      // Проверяем, является ли текущая ячейка чёрным
      // пикселем.
      // 
      // Если нет — пропускаем дальнейшие действия в
      // этой итерации.
      if (picture[r][c] !== 'B') continue;

      // Если пиксель чёрный, увеличиваем счётчик чёрных
      // пикселей для строки r на единицу.
      // 
      // Это позволяет в дальнейшем быстро узнать,
      // сколько чёрных пикселей в каждой строке без
      // повторного сканирования.
      rowToBlackPixelCnt[r]++;

      // Увеличиваем счётчик чёрных пикселей для столбца
      // c на единицу.
      colToBlackPixelCnt[c]++;
    }
  }

  // Инициализируем переменную для накопления результата
  // — количества "одиноких" чёрных пикселей
  let result = 0;

  // Снова проходим по всем строкам, чтобы проверить каждую
  // ячейку на условие одиночного чёрного пикселя.
  for (let r = 0; r < ROWS; r++) {

    // Проходим по всем столбцам текущей строки r.
    for (let c = 0; c < COLS; c++) {

      // Проверяем три условия одновременно:
      // 1. значение текущей ячейки 'B';
      //
      // 2. в строке r ровно один чёрный пиксель 
      //    (значит этот 'B' — единственный в строке);
      // 
      // 3. в столбце c ровно один чёрный пиксель
      //    (значит этот 'B' — единственный в столбце).
      //
      // Только при выполнении всех трёх условий этот
      // пиксель считается "одиноким".
      //
      // Увеличиваем счётчик результата на 1 для каждого
      // найденного одиночного чёрного пикселя.
      if (
        picture[r][c] === 'B'
        && rowToBlackPixelCnt[r] === 1
        && colToBlackPixelCnt[c] === 1
      ) result++;
    }
  }

  // Возвращаем итоговое количество одиночных чёрных пикселей.
  //
  // Временная сложность алгоритма O(ROWS * COLS) из‑за двух
  // полных проходов по матрице.
  //
  // Пространственная сложность O(ROWS + COLS) для массивов
  // подсчёта.
  return result;
}
