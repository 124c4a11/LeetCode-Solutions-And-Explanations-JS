/**
 * @param {number} n
 * @return {boolean}
 * 
 * confusingNumber проверяет, является ли число
 * confusing — то есть при повороте каждой цифры
 * на 180° число остаётся валидным, но
 * становится другим числом.
 * 
 * Параметры:
 * - n — ожидается целое число или строка,
 *   содержащая цифры.
 * 
 * Возвращаемое значение: 
 * - true, если число валидно при повороте и
 *   при этом меняется
 * 
 * - false в остальных случаях (недопустимые
 *   цифры или остаётся тем же).
 * 
 * 
 * Основная идея:
 * Функция заменяет каждую цифру на её
 * «перевернутый» эквивалент
 * (0→0, 1→1, 6→9, 8→8, 9→6), затем
 * разворачивает полученную последовательность
 * символов и сравнивает с исходным числом. 
 * 
 * Если результат валиден и отличается от
 * исходного — число считается confusing.  
 * 
 * 
 * Валидация цифр:
 * Если в числе встречается цифра, у которой
 * нет корректного перевёрнутого эквивалента
 * (2, 3, 4, 5, 7), функция немедленно
 * возвращает false — число невалидно для
 * поворота.
 * 
 * 
 * Пример для:
 *   n = 69
 * Резульат:
 *   false
 * Пояснение:
 *   '6'→'9', '9'→'6' → собрали '96',
 *   затем разворот → '69'.
 *   Результат равен исходному `69`, значит не
 *   confusing → возвращает **false**.
 * 
 * 
 * Пример для:
 *   n = 6
 * Резальтат:
 *   true
 * Пояснение:
 *   '6'→'9', разворот не меняет один символ
 *   → получаем `9` ≠ `6` → true (confusing).  
 * 
 * 
 * Пример для:
 *   n = 11
 * Резульат:
 *   false
 * Пояснение:
 *   '1'→'1','1'→'1' → разворот даёт 11
 *   = исходному 11 → false.  
 * 
 * 
 * Пример для:
 *   n = 2
 * Результат:
 *   false
 * Пояснение: 
 *   '2' не поддерживается → функция сразу
 *   возвращает **false**.  
 * 
 * 
 * Пример для:
 *   n = 10
 * Результат:
 *   true
 * Пояснение:
 *   '1'→'1','0'→'0' → после разворота '01'
 *   → Number('01') даёт 1, сравнение с 10
 *   даёт 1 !== 10 → true 
 */
function confusingNumber(n) {

  // Создаём Map, где
  // - ключ — символ цифры в исходном
  //   числе,
  //
  // - значение — символ после поворота на
  //   180 градусов; пример: '6' → '9'
  const invertMap = new Map([

    // '0' при повороте остаётся '0'.
    //
    // Пример:
    // цифра 0 в числе 10 остаётся 0
    ['0', '0'],

    // '1' при повороте остаётся '1'.
    //
    // Пример:
    // 11 → после поворота 11
    ['1', '1'],

    // '6' при повороте становится '9'.
    //
    // Пример:
    // 6 → 9
    ['6', '9'],

    // '8' при повороте остаётся '8'.
    //
    // Пример:
    // 8 → 8
    ['8', '8'],

    // '9' при повороте становится '6'.
    //
    // Пример:
    // 9 → 6
    ['9', '6'],
  ]);

  // Инициализация переменной rotatedNumber
  // пустой строкой.
  //
  // В ней по мере обхода цифр будет
  // накапливаться строка из "перевернутых"
  // символов в том порядке, в котором они
  // встречаются в исходном числе.
  //
  // Пример для n = 69:
  // После цикла rotatedNumber будет равна
  // '96' (до разворота).
  let rotatedNumber = '';

  // Преобразование входного значения n в
  // строку и итерация по каждому символу
  // (по каждой цифре).
  //
  // Это позволяет корректно обрабатывать
  // как числовой, так и строковый ввод.
  //
  // Пример:
  // String(106) → "106", итерация по
  // '1', '0', '6'.
  for (const char of String(n)) {

    // Проверка: 
    // Если текущий символ char
    // отсутствует в invertMap, значит
    // цифра не поддерживается для
    // "переворота".
    //
    // В этом случае функция немедленно
    // возвращает false, потому что число
    // нельзя корректно "перевернуть".
    //
    // Пример для n = 2 (или "2"):
    // '2' нет в invertMap, функция вернёт
    // false.
    if (!invertMap.has(char)) {
      return false;
    }

    // Получение соответствующей
    // "перевернутой" строки-цифры из
    // invertMap и добавление её в конец
    // rotatedNumber.
    //
    // Здесь мы не делаем разворот порядка
    // — просто заменяем каждую цифру на её
    // перевёрнутый эквивалент.
    //
    // Пример для n = 69:
    //   Сначала ch = '6' 
    //     → invertMap['6'] = '9'
    //     → rotatedNumber = '9'
    //   Затем ch = '9' 
    //     → invertMap['9'] = '6'
    //     → rotatedNumber = '96'
    rotatedNumber += invertMap.get(char);
  }

  // После завершения цикла rotatedNumber содержит
  // последовательность "перевернутых" символов в
  // исходном порядке.
  //
  // Чтобы смоделировать поворот всего числа на 180
  // градусов, нужно ещё развернуть порядок символов.
  //
  // Для этого строка разбивается на массив символов,
  // массив разворачивается, затем снова собирается
  // в строку.
  //
  // Пример для rotatedNumber = '96' (до разворота):
  // После split/reverse/join получится '69'.
  rotatedNumber = rotatedNumber
    .split('')
    .reverse()
    .join('');

  // Преобразование rotatedNumber в число с помощью
  // Number() и сравнение с исходным n.
  //
  // Возвращается:
  // - true, если полученное число НЕ равно исходному
  //   n (то есть число "сбивает с толку" — меняется
  //   при повороте),
  //
  // - false, если равно (число при повороте остаётся
  //   тем же) или если ранее была недопустимая цифра
  //   (уже возвращено false).
  //
  // Важно:
  // Number() удаляет ведущие нули, поэтому для входов
  // с ведущими нулями
  // (например, "10" → Number('01') → 1) сравнение
  // может учитывать это поведение.
  //
  // Примеры:
  // - n = 69:
  //   rotatedNumber после всех операций = '69',
  //   → Number('69') = 69
  //   → 69 !== 69
  //   → false.
  //
  // - n = 11:
  //   rotatedNumber = '11',
  //   → Number('11') = 11
  //   → 11 !== 11
  //   → false.
  //
  // - n = 10: 
  //   rotatedNumber до разворота = '01',
  //   → после разворота = '10',
  //   → Number('10') = 10
  //   → 10 !== 10
  //   → false.
  //
  // - n = 2: 
  //   функция вернёт false раньше, потому что '2'
  //   не поддерживается.
  return Number(rotatedNumber) !== n;
}
