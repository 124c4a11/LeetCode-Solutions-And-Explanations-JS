/**
 * @param {string[]} names
 * @param {number[]} heights
 * @return {string[]}
 * 
 * sortPeople принимает два массива одинаковой длины:
 * names (строки) и heights (числа) и возвращает новый
 * массив имён, упорядоченных по убыванию
 * соответствующих значений роста из массива heights
 * 
 * Пример для:
 *   names = ["Mary","John","Emma"]
 *   heights = [180,165,170]
 * Результат:
 *   ["Mary","Emma","John"]
 * Пояснение:
 *   Mary самая высокая, затем идут Emma и John.
 */
function sortPeople(names, heights) {

  // Создаём новый массив индексов той же длины,
  // что и names, используя map.
  //
  // Первый аргумент колбэка (_) игнорируется,
  // второй (i) — текущий индекс.
  //
  // Результатом будет массив
  // [0, 1, 2, ..., n-1].
  const indices = names.map((_, i) => i);

  // Сортируем массив индексов по соответствующим
  // значениям в heights в порядке убывания.
  //
  // Компаратор получает два индекса a и b и
  // сравнивает heights[b] и heights[a], возвращая
  // положительное/отрицательное/нулевое число,
  // что приводит к упорядочиванию индексов так,
  // чтобы более высокий рост шёл раньше.
  indices.sort((a, b) => heights[b] - heights[a]);

  // Преобразуем отсортированные индексы обратно в
  // массив имён в новом порядке.
  //
  // map проходит по каждому индексу i из indices
  // и возвращает соответствующее имя names[i].
  //
  // В результате возвращается новый массив имён,
  // отсортированный по убыванию роста
  return indices.map((i) => names[i]);
}
