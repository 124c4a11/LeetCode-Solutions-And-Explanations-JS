/**
 * @param {string[]} strings
 * @return {string[][]}
 * 
 * groupStrings группирует строки по их относительным сдвигам
 * символов (циклическим сдвигам по алфавиту) и возвращает
 * массив групп — каждая группа содержит строки с одинаковой
 * последовательностью сдвигов.
 * 
 * Параметры:
 *   strings — итерируемый набор строк (обычно массив)
 * 
 * Пример для:
 *   strings = ["abc","bcd","acef","xyz","az","ba","a","z"]
 * Результат:
 *   [["acef"],["a","z"],["abc","bcd","xyz"],["az","ba"]]
 */
function groupStrings(strings) {

  // Вложенная функция getHash вычисляет уникальную
  // строковую метку (хеш) для каждой входной строки,
  // основанную на относительных сдвигах между соседними
  // символами в алфавите.
  //
  // Это позволяет группировать строки, которые являются
  // циклическими сдвигами друг друга по символам.
  //
  // Хеш — строка, представляющая последовательность
  // разностей кодовых точек между соседними символами,
  // приведённых по модулю 26 (чтобы учесть циклический
  // переход от z к a).
  function getHash(string) {

    // Массив hash будет накапливать символы,
    // представляющие разности между соседними
    // символами исходной строки.
    //
    // Используем массив, потому что push эффективнее
    // многократной конкатенации строк.
    const hash = [];

    // Проходим по символам строки, начиная с индекса 1,
    // чтобы сравнивать каждый символ с предыдущим.
    //
    // Если строка пустая или длина 1, цикл не
    // выполнится и hash останется пустым.
    for (let i = 1; i < string.length; i++) {

      // Получаем числовые коды символов в позициях
      // i и i-1.
      //
      // codePointAt корректно работает с
      // Unicode-кодовыми точками (включая суррогатные
      // пары), что делает функцию более надёжной для
      // символов за пределами BMP по сравнению с
      // charCodeAt. Также codePointAt является более
      // производительным в стравнении с charCodeAt.
      //
      // Вычисляем разницу между кодами текущего и
      // предыдущего символов.
      //
      // Добавляем 26 и берём по модулю 26, чтобы
      // получить циклическую разность в диапазоне
      // 0..25.
      //
      // Это важно для случаев, когда сдвиг "заходит"
      // за пределы 'z' и должен циклически переходить
      // к 'a'.
      const diff = (string.codePointAt(i) - string.codePointAt(i - 1) + 26) % 26;

      // Преобразуем числовую разницу в символ:
      //
      // Прибавляем код буквы 'a' и создаём символ из
      // полученной кодовой точки.
      //
      // Такой подход кодирует каждую разницу как
      // букву от 'a' до 'z', что даёт компактную и
      // читаемую метку.
      //
      // diff содержит циклическое значение в
      // диапазоне 0..25, что соответствует 26
      // соответствующих сдвигам по алфавиту.
      //
      // Чтобы преобразовать diff в код символа в
      // диапозоне от 'a' до 'z' (97..122),
      // добавляем к нему код символа 'a'
      // ('a'.codePointAt(0) = 97)
      //
      // Затем полученный код преобразуем в символ
      // при промощи String.fromCodePoint
      hash.push(String.fromCodePoint(diff + 'a'.codePointAt(0)));
    }

    // Визуализация работы цикла для:
    //
    // - string = "abc"
    //
    // ---
    //
    // **Исходные значения перед циклом**
    //
    // - string = "abc"
    //
    // - string.length = 3
    //
    // - hash = []
    //
    // ---
    //
    // Шаг 1: i = 1
    //
    // - Текущие символы
    //   - string.codePointAt(i)
    //     → string.codePointAt(1)
    //     — код символа 'b' = 97 (код 'a') + 1 = 98
    //       (обычно записывают как 98).
    //
    //   - string.codePointAt(i - 1)
    //     → string.codePointAt(0)
    //     — код символа 'a' = 97
    //
    //
    // - Вычисление diff
    //   - Подставляем в формулу:  
    //     diff = (98 - 97 + 26) % 26
    //     Сначала 98 - 97 = 1
    //     Затем 1 + 26 = 27
    //     Наконец 27 % 26 = 1
    //
    //   - diff = 1 (в диапазоне 0..25).
    //
    //
    // - Преобразование в символ
    //   - 'a'.codePointAt(0) = 97
    //
    //   - diff + 'a'.codePointAt(0) = 1 + 97 = 98  
    //
    //   - String.fromCodePoint(98)
    //     → символ с кодом 98 → 'b'
    //
    //
    // - Изменение hash
    //   - Выполняется hash.push('b')
    //
    //   - hash теперь = ['b']
    //
    // ---
    //
    // Шаг 2: i = 2
    //
    // - Текущие символы
    //   - string.codePointAt(2)
    //     — код символа 'c' = 99
    //
    //   - string.codePointAt(1)
    //     — код символа 'b' = 98
    //
    //
    // - Вычисление diff
    //   - diff = (99 - 98 + 26) % 26
    //     99 - 98 = 1
    //     1 + 26 = 27
    //     27 % 26 = 1.  
    //
    //   - diff = 1
    //
    //
    // - Преобразование в символ
    //   - diff + 'a'.codePointAt(0) = 1 + 97 = 98
    //
    //   - String.fromCodePoint(98) → 'b'
    //
    //
    // - Изменение hash
    //   - hash.push('b')
    //
    //   - hash теперь = ['b', 'b']
    //
    // ---
    //
    // После завершения цикла
    // - Цикл остановился, потому что i достиг
    //   string.length (далее i = 3 не
    //   выполняется).  
    //
    // - getHash вернёт hash.join('')
    //   → ['b','b'].join('') → "bb"
    //
    // Ключевые замечания
    // - Операция (+26) % 26 обеспечивает
    //   циклический сдвиг: при переходе
    //   от 'z' к 'a' разница не станет
    //   отрицательной, а попадёт в диапазон
    //   0..25
    //
    // - Если строка длины 0 или 1, цикл не
    //   выполнится и hash` останется пустым,
    //   getHash вернёт пустую строку.

    // Объединяем массив символов в одну строку.
    // Для пустой или односимвольной строки
    // вернётся пустая строка, что корректно
    // группирует все односимвольные строки
    // вместе (они имеют одинаковую
    // последовательность разностей — пустую).
    return hash.join('');
  }

  // Map используется для группировки:
  // ключ — хеш (последовательность разностей),
  // значение — массив строк с таким хешем.
  //
  // Map предпочтительнее обычного объекта, потому
  // что гарантирует порядок вставки и не
  // конфликтует с прототипными свойствами.
  const groups = new Map();

  // Проходим по каждой строке из входного массива
  // strings.
  for (const string of strings) {

    // Вычисляем хеш для текущей строки.
    //
    // Для строк разной длины хешы будут разной
    // длины, поэтому строки разной длины не
    // попадут в одну группу, даже если их
    // относительные сдвиги совпадают частично.
    const hash = getHash(string);

    // Если в Map ещё нет массива для этого хеша,
    // создаём новый пустой массив и сохраняем
    // его под этим ключом.
    //
    // Это отложенная инициализация группы
    // — экономит память, создавая массив только
    // при необходимости.
    if (!groups.has(hash)) {
      groups.set(hash, []);
    }

    // Получаем массив по ключу hash и добавляем
    // в него текущую строку.
    //
    // get(hash) возвращает тот же массив,
    // который мы либо только что создали, либо
    // создали ранее.
    groups.get(hash).push(string);
  }

  // Пример работы цикла для:
  // - strings = ["abc","bcd","acef","xyz","az","ba","a","z"]
  //
  // ----
  //
  // Начальное состояние
  // - strings = ["abc","bcd","acef","xyz","az","ba","a","z"]
  //
  // - groups = Map {} (пустая)
  //
  // ---
  //
  // Итерация 1
  //
  // - string = "abc"
  //
  // - hash = getHash("abc") → "bb"  
  //   (пояснение: разницы между соседними буквами:
  //   a → b = 1 → 'b',
  //   b → c = 1 → 'b'
  //   → объединение "bb")
  //
  // - groups до = {} (пусто)
  //
  // - проверка:
  //   groups.has("bb") → false
  //
  // - действие:
  //   groups.set("bb", []) создаёт новую запись
  //
  // - добавление:
  //   groups.get("bb").push("abc")
  //
  // - groups после = { "bb" → ["abc"] }
  //
  // ---
  //
  // Итерация 2
  //
  // - string = "bcd"
  //
  // - hash = getHash("bcd") → "bb"  
  //   (разницы:
  //    b → c = 1 → 'b',
  //    c → d = 1 → 'b'
  //    → "bb")
  //
  // - groups до = { "bb" → ["abc"] }
  //
  // - проверка:
  //   groups.has("bb") → true
  //
  // - действие:
  //   не создаём новую запись
  //
  // - добавление:
  //   groups.get("bb").push("bcd")
  //
  // - groups после = { "bb" → ["abc","bcd"] }
  //
  // ---
  //
  // Итерация 3
  //
  // - string = "acef"
  //
  // - hash = getHash("acef") → "bdf"
  //   (разницы:
  //    a → c = 2 → 'c' ? — но в коде diff 2
  //    → String.fromCodePoint(2 + 'a') = 'c'
  //      последовательность даёт символы,
  //      итоговая строка "bdf" в терминах сдвигов
  //      важен уникальный хеш)
  //
  // - groups до = { "bb" → ["abc","bcd"] }
  //
  // - проверка:
  //   groups.has("bdf") → false
  //
  // - действие:
  //   groups.set("bdf", [])
  //
  // - добавление:
  //   groups.get("bdf").push("acef")
  //
  // - groups после = {
  //     "bb"  → ["abc","bcd"],
  //     "bdf" → ["acef"]
  //   }
  //
  // ---
  //
  // Итерация 4
  //
  // - string = "xyz"
  //
  // - hash = getHash("xyz") → "bb"  
  //   (разницы:
  //    x → y = 1 → 'b',
  //    y → z = 1 → 'b'
  //    → "bb")
  //
  // - groups до = {
  //     "bb"  → ["abc","bcd"],
  //     "bdf" → ["acef"]
  //   }
  //
  // - проверка:
  //   groups.has("bb") → true
  //
  // - действие:
  //   не создаём новую запись
  //
  // - добавление: 
  //   groups.get("bb").push("xyz")
  //
  // - groups после = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"]
  //   }
  //
  // ---
  //
  // Итерация 5
  //
  // - string = "az"
  //
  // - hash = getHash("az") → "z" 
  //   ? → на практике getHash для двухсимвольной строки
  //   вычисляет один символ:  
  //   a → z разница
  //   = (code('z') - code('a') + 26) % 26 = 25
  //   → 25 + code('a')
  //   → код символа, соответствующего смещению 25,
  //   то есть 'z'  
  //
  //   Итого hash = "z"
  //
  // - groups до = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"]
  //   }
  //
  // - проверка:
  //   groups.has("z") → false
  //
  // - действие:
  //   groups.set("z", [])
  //
  // - добавление:
  //   groups.get("z").push("az")
  //
  // - groups после = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az"]
  //   }
  //
  // ---
  //
  // Итерация 6
  //
  // - string = "ba"
  //
  // - hash = getHash("ba") → вычисление: 
  //   b → a
  //   = (code('a') - code('b') + 26) % 26
  //   = (-1 + 26) % 26 = 25
  //   → символ 'z'  
  //
  //   Итого hash = "z" (тот же хеш, что и у `"az"`,
  //   потому что сдвиг циклический).
  //
  // - groups до = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az"]
  //   }
  //
  // - проверка:
  //   groups.has("z") → true
  //
  // - действие:
  //   не создаём новую запись
  //
  // - добавление:
  //   groups.get("z").push("ba")
  //
  // - groups после = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az","ba"]
  //   }
  //
  // ---
  //
  // Итерация 7
  //
  // - string = "a"
  //
  // - hash = getHash("a") → "" (пустая строка)  
  //   (пояснение: строка длины 1 не имеет соседних пар,
  //   цикл внутри getHash не выполняется, hash остаётся
  //   пустым и join('') даёт "").
  //
  // - groups до = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az","ba"]
  //   }
  //
  // - проверка:
  //   groups.has("") → false
  //
  // - действие:
  //   groups.set("", [])
  //
  // - добавление:
  //   groups.get("").push("a")
  //
  // - groups после = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az","ba"],
  //     ""    → ["a"]
  //   }
  //
  // ---
  //
  // Итерация 8
  //
  // - string = "z"
  //
  // - hash = getHash("z") → "" (пустая строка),
  //   по той же причине, что и для "a"
  //
  // - groups до = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az","ba"],
  //     ""    → ["a"]
  //   }
  //
  // - проверка:
  //   groups.has("") → true
  //
  // - действие:
  //   не создаём новую запись
  //
  // - добавление: 
  //   groups.get("").push("z")
  //
  // - groups после = {
  //     "bb"  → ["abc","bcd","xyz"],
  //     "bdf" → ["acef"],
  //     "z"   → ["az","ba"],
  //     ""    → ["a","z"]
  //   }
  //
  // ---
  //
  // Итоговое состояние groups
  // - "bb"  → ["abc","bcd","xyz"]
  // - "bdf" → ["acef"]
  // - "z"   → ["az","ba"]
  // - ""    → ["a","z"]
  //
  // Возвращаемое значение функции
  // Array.from(groups.values()) даст массив групп
  // (порядок групп соответствует внутреннему
  // порядку Map):
  // [["abc","bcd","xyz"], ["acef"], ["az","ba"], ["a","z"]]
  //
  // ---
  //
  // Ключевые замечания
  // - Строки считаются эквивалентными и попадают в одну
  //   группу, если последовательности циклических сдвигов
  //   между соседними символами совпадают (то есть
  //   getHash даёт одинаковую строку).
  //
  // - Двухсимвольные строки дают хеш длины 1.
  //   Односимвольные строки дают пустой хеш "", поэтому
  //   все односимвольные строки группируются вместе.
  //
  // - Порядок элементов внутри каждой группы
  //   соответствует порядку их появления во входном
  //   массиве strings

  // Преобразуем коллекцию значений Map (массивы
  // сгруппированных строк) в обычный массив и возвращаем
  // его.
  //
  // Array.from(groups.values()) сохраняет порядок групп
  // в порядке первого появления их ключей.
  return Array.from(groups.values());
}
