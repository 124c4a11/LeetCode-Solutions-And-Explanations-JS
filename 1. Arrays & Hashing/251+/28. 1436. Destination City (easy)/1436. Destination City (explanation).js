/**
 * @param {string[][]} paths
 * @return {string}
 * 
 * destCity находит и возвращает конечный город
 * — тот город-прибытие, который нигде не
 * встречается как город-отправления.
 * 
 * Параметры:
 * - paths — массив путей. Каждый элемент
 *   — массив из двух строк
 *   [город-отправления, город-прибытия].
 * 
 * Пример для:
 *   paths = [["B","C"],["D","B"],["C","A"]]
 * Резульат:
 *   "A"
 * Пояснение:
 *   Все возможные поездки: 
 *     "D" → "B" → "C" → "A".
 *     "B" → "C" → "A".
 *     "C" → "A".
 *     "A".
 *   Очевидно, город назначения — "A".
 */
function destCity(paths) {

  // Создаём новое множество (Set) для хранения
  // всех городов-источников (первая позиция
  // каждого подмассива).
  const sourceSet = new Set();

  // Запускаем цикл for..of для
  // последовательного обхода каждого маршрута из
  // массива paths.
  //
  // Каждый элемент path — это сам массив из двух
  // строк: [source, destination].
  //
  // Не используем деструктуризацию внути 
  // for (const [src] of paths), чтобы ускорить
  // работу кода
  for (const path of paths) {

    // Из текущего маршрута извлекаем
    // город-источник (нулевой индекс).
    //
    // Добавляем его во множество sourceSet,
    // чтобы затем быстро проверять, является ли
    // какой-либо город источником.
    sourceSet.add(path[0]);
  }

  // Запускаем второй цикл по тому же массиву
  // paths для проверки городов-назначений.
  //
  // Логика разнесена в два прохода:
  // сначала собираем все источники, затем ищем
  // назначение, отсутствующее в наборе
  // источников.
  //
  // Не используем деструктуризацию внути 
  // for (const [_, dst] of paths), чтобы
  // ускорить работу кода
  for (const path of paths) {

    // Берём город-назначение (элемент path[1])
    // и проверяем, содержится ли он в наборе
    // источников.
    //
    // Если destination НЕ находится в sourceSet,
    // значит из него никто не уезжает — это
    // искомый конечный город.
    //
    // Немедленно возвращаем найденный конечный
    // город как результат работы функции.
    //
    // Возврат происходит при первом таком
    // совпадении. Предполагается, что входные
    // данные корректны и имеют единственную
    // конечную точку.
    if (!sourceSet.has(path[1])) return path[1];
  }
};
