/**
 * @param {number} rowIndex
 * @return {number[]}
 * 
 * getRow строит и возвращает массив, представляющий
 * строку треугольника Паскаля с индексом rowIndex
 * (нулевая строка = [1]).
 * 
 * Параметры:
 * - rowIndex — целое число (>= 0), индекс нужной
 *   строки треугольника Паскаля.
 * 
 * Пример для:
 *   rowIndex = 3
 * Результат:
 *   [1,3,3,1]
 */
function getRow(rowIndex) {

  // Создаётся константа row и инициализируется
  // массивом с одним элементом 1.
  //
  // Этот элемент соответствует первому
  // биномиальному коэффициенту C(n,0) = 1
  // — первый (нулевой) элемент любой строки
  // треугольника Паскаля.
  const row = [1];

  // Цикл for, где i пробегает значения от 1 до
  // rowIndex включительно.
  //
  // Каждый шаг цикла рассчитывает и добавляет
  // в конец массива следующий коэффициент ряда,
  // используя уже вычисленный предыдущий
  // коэффициент (последний элемент массива row)
  //
  // Цикл выполняет rowIndex итераций, добавляя
  // элементы C(n,1), C(n,2), ..., C(n,rowIndex)
  //
  // Цикл начинается с i = 1, так как первый
  // элемент уже задан. Массив row
  // инициализируется как [1], что
  // соответствует биномиальному коэффициенту
  // C(n,0). Поэтому нет смысла повторно
  // вычислять i = 0.
  for (let i = 1; i <= rowIndex; i++) {

    // Вставка следующего элемента в массив row
    // через метод push.
    //
    // Передаваемое выражение вычисляет следующий
    // коэффициент как целое число c округлением
    // вниз, чтобы избежать дробных погрешностей
    // при арифметике с плавающей точкой.
    row.push(
      Math.floor(

        // Выражение вычисляет следующий элемент
        // строки (биномиальный коэффициент)
        // через предыдущий, используя
        // мультипликативную формулу для
        // сочетаний: если предыдущий элемент
        // равен C(n, k-1), то следующий элемент
        // равен C(n, k). В коде это записано как  
        //   next = prev * (n - k + 1) / k
        // где
        //   n = rowIndex
        //   k = i
        //   prev = row.at(-1)
        //
        // ---
        //
        // row.at(-1)  
        //   Это способ взять последний
        //   добавленный элемент массива row, то
        //   есть предыдущий вычисленный
        //   коэффициент. Если в терминах
        //   сочетаний это C(n, k-1), то
        //   row.at(-1) = prev = C(n,k-1).
        // 
        // (rowIndex - i + 1)  
        //   Это числитель дроби в формуле.
        //   Переписано в терминах n и k:
        //   (n - k + 1). Он отражает, сколько
        //   «вариантов» остаётся для умножения
        //   при переходе от C(n,k-1) к C(n,k)
        // 
        // / i  
        //   Деление на текущее значение счётчика
        //   i (в терминах сочетаний это k)
        //   — нормировка: в формуле биномиальных
        //   коэффициентов на каждом шаге нужно
        //   разделить на номер позиции, чтобы
        //   получить корректное целое значение.
        //
        // ---
        //
        // Почему это корректно для треугольника
        // Паскаля биномиальных коэффициентов  
        //
        // Формула использует рекуррентную связь
        // между соседними коэффициентами в одной
        // строке: чтобы получить C(n,k),
        // достаточно знать C(n,k-1) и умножить
        // на отношение (n-k+1)/k. Это экономит
        // вычисления факториалов и даёт
        // последовательный способ получить всю
        // строку, начиная с 1.
        row.at(-1) * (rowIndex - i + 1) / i
      ),
    );
  }

  // Пошаговый пример работы цикла при
  // rowIndex = 3
  //
  // 
  // Начальное состояние:
  //   - rowIndex = 3
  //   - row = [1]
  // 
  //
  // i = 1:
  //   - row.at(-1) = 1
  //   - Вычисляем множитель:
  //     (rowIndex - i + 1) = (3 - 1 + 1) = 3
  //   - Формула:
  //     Math.floor(1 * 3 / 1) = Math.floor(3) = 3
  //   - После push:
  //     row = [1, 3]
  // 
  // i = 2:
  //   - row.at(-1) = 3
  //   - Множитель:
  //     (3 - 2 + 1) = 2
  //   - Формула:
  //     Math.floor(3 * 2 / 2) = Math.floor(3) = 3
  //   - После push:
  //     row = [1, 3, 3]
  // 
  // i = 3:
  //    - row.at(-1) = 3
  //    - Множитель:
  //      (3 - 3 + 1) = 1
  //    - Формула:
  //      Math.floor(3 * 1 / 3) = Math.floor(1) = 1
  //    - После push:
  //      row = [1, 3, 3, 1]
  // 
  //
  // Результат:
  // Функция вернёт [1, 3, 3, 1], что соответствует
  // 3-й строке треугольника Паскаля (биномиальные
  // коэффициенты для n = 3).

  // Возвращаем массив row, который после
  // выполнения цикла содержит элементы строки
  // треугольника Паскаля для заданного rowIndex:
  // [C(n,0), C(n,1), ..., C(n,n)].
  return row;
};
