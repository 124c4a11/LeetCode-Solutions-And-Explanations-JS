/**
 * @param {string[]} sentence1
 * @param {string[]} sentence2
 * @param {string[][]} similarPairs
 * @return {boolean}
 * 
 * areSentencesSimilar проверяет, считаются ли два предложения
 * похожими по словарю соответствий. Она сравнивает слова по
 * позициям: каждое слово в sentence1 должно либо точно
 * совпадать с соответствующим словом в sentence2, либо быть
 * помечено как похожее на него в списке пар similarPairs.
 * 
 * Возвращает логическое значение — true, если все позиции
 * совместимы, и false в противном случае.
 * 
 * Параметры
 * - sentence1 — массив строк. Первое предложение, представлено
 *   как последовательность слов в порядке их следования.  
 * 
 * - sentence2 — массив строк. Второе предложение, представлено
 *   аналогично первому.  
 * 
 * - similarPairs — массив пар (двухэлементных массивов) строк.
 *   Каждая пара имеет вид [word, similarWord] и обозначает,
 *   что word и similarWord считаются похожими.
 * 
 * 
 * Пример для:
 *   sentence1 = ["great","acting","skills"]
 *   sentence2 = ["fine","drama","talent"]
 *   similarPairs = [
 *     ["great","fine"],
 *     ["drama","acting"],
 *     ["skills","talent"]
 *   ]
 * Результат:
 *   true
 * Пояснение:
 *   Оба предложения имеют одинаковую длину, и каждое слово i
 *   в предложении 1 также похоже на соответствующее слово в
 *   предложении 2. 
 */
function areSentencesSimilar(sentence1, sentence2, similarPairs) {

  // Проверка на равенство длин массивов слов:
  // Если длины различаются, сравнение по позициям
  // невозможно.
  //
  // Это быстрый фильтр, позволяющий избежать лишенной смысла
  // дальнейшей работы.
  //
  // Сразу возвращаем false: предложения не могут быть
  // попозиционно похожи при разной длине.
  if (sentence1.length !== sentence2.length) {
    return false;
  }

  // Создаём Map для хранения соответствия:
  // - ключ — слово,
  // - значение — Set похожих слов.
  //
  // Map обеспечивает быстрый доступ по ключу.
  // Set предотвращает дублирование похожих слов.
  const wordToSimilarWords = new Map();

  // Итерация по массиву пар похожих слов. 
  //
  // Каждая пара распаковывается в переменные word и
  // similarWord.
  for (const [word, similarWord] of similarPairs) {

    // Если для текущего слова ещё не создано множество
    // похожих слов, создаём новый Set и сохраняем в Map.
    //
    // Это гарантирует, что последующие добавления будут
    // происходить в существующем множестве.
    if (!wordToSimilarWords.has(word)) {
      wordToSimilarWords.set(word, new Set());
    }

    // Добавляем похожее слово в множество для ключевого
    // слова.
    //
    // Set автоматически игнорирует повторные добавления
    // одного и того же похожего слова.
    wordToSimilarWords.get(word).add(similarWord);


    // Обеспечиваем симметричность отношения похожести:
    // создаём множество для похожего слова, если его
    // нет, чтобы можно было искать в обе стороны
    //
    // Это важно, потому что входные пары могут быть
    // направленными, а мы хотим считать похожесть
    // двунаправленной.
    if (!wordToSimilarWords.has(similarWord)) {
      wordToSimilarWords.set(similarWord, new Set());
    }

    // Добавляем исходное слово в множество для
    // похожего слова, делая отношение симметричным
    // (если пары заданы как неориентированные)
    wordToSimilarWords.get(similarWord).add(word);
  }

  // Проходим по всем индексам предложений.
  //
  // Длины равны, поэтому безопасно использовать одну
  // границу.
  for (let i = 0; i < sentence1.length; i++) {

    // Если слова на текущей позиции полностью
    // совпадают, то они считаются похожими без
    // дополнительной проверки в Map.
    //
    // Это покрывает случаи, когда слова идентичны
    // по написанию и регистру.
    //
    // continue пропускает оставшуюся часть тела
    // цикла и переходит к следующей итерации,
    // экономя дополнительные проверки для
    // совпадающих слов.
    if (sentence1[i] === sentence2[i]) {
      continue;
    }

    // Проверяем, существует ли в Map запись для
    // слова из первого предложения и содержит ли
    // это множество слово из второго предложения 
    //
    // Optional chaining предотвращает ошибку при
    // отсутствии Set
    //
    // Если найдено соответствие в множестве
    // похожих слов, считаем слова совместимыми и
    // переходим к следующей итерации
    if (
      wordToSimilarWords
        .get(sentence1[i])
        ?.has(sentence2[i])
    ) continue;

    // Если ни прямого совпадения, ни записи о
    // похожести не обнаружено, предложения не
    // считаются похожими — возвращаем false
    return false;
  }

  // Если цикл завершился без возврата false, это
  // означает, что для каждой позиции либо слова
  // совпадали, либо были помечены как похожие в
  // словаре similarPairs.
  //
  // Возвращаем true, подтверждая, что предложения
  // считаются похожими по заданным правилам.
  return true;
}
