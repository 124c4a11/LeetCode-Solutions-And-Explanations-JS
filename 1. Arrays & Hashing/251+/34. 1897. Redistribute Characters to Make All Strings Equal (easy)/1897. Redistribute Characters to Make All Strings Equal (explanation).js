/**
 * @param {string[]} words
 * @return {boolean}
 * 
 * makeEqual проверяет, можно ли перераспределить
 * все буквы из массива слов так, чтобы каждое
 * слово получилось одинаковым набором букв. 
 * 
 * Параметры:
 * - words — массив строк. Ожидается, что строки
 *   состоят из строчных латинских букв a–z.
 * 
 * Возвращает:
 *  - true означает, что для каждой буквы общее
 *    количество её вхождений можно равномерно
 *    распределить между всеми словами, то есть
 *    существует способ переставить
 *    (или перераспределить) буквы так, чтобы
 *    каждое слово содержало одинаковый набор
 *    букв в одинаковых количествах, что 
 *    позволит получить одинаковые слова.
 * 
 *  - false означает, что хотя бы одна буква
 *    имеет такое общее количество вхождений,
 *    которое нельзя разделить поровну между
 *    словами, поэтому одинаковые слова
 *    получить невозможно.
 * 
 * Пример для:
 *   words = ["abc","aabc","bc"]
 * Результат:
 *   true
 * Объяснение:
 *   Переместите первую 'a' в words[1] в начало
 *   words[2], чтобы получить words[1] = "abc"
 *   и words[2] = "abc".
 * 
 *   Все строки теперь равны "abc", поэтому
 *   возвращаем true.
 * 
 * Пример 2 для:
 *   words = ["ab","a"]
 * Результат:
 *   false
 * Объяснение:
 *   Невозможно сделать все строки одинаковыми
 *   с помощью этой операции.
 */
function makeEqual(words) {

  // Создаём массив фиксированной длины 26 для
  // подсчёта частот букв латинского алфавита
  // a..z.
  //
  // Int32Array хранит 32-битные целые числа в
  // виде непрерывного буфера, что экономит
  // память и быстрее при числовых операциях.
  //
  // Инициализация нулями по умолчанию.
  // 
  // Индексы 0..25 соответствуют буквам
  // 'a'..'z'.
  const charFreq = new Int32Array(26);

  // Внешний цикл перебирает каждое слово из
  // входного массива words.
  for (const word of words) {

    // Внутренний цикл перебирает каждый
    // символ строки word.
    for (const char of word) {

      // Получаем числовой код символа и
      // приводим его к индексу 0..25
      // вычитанием 97 (код 'a').
      //
      // char.charCodeAt(0) возвращает
      // целое >=0.
      // 
      // Вычитание 97 предполагает, что
      // вход содержит только строчные
      // латинские буквы.
      //
      // Увеличиваем соответствующий
      // счётчик частоты на 1.
      charFreq[char.charCodeAt(0) - 97]++;
    }
  }

  // После подсчёта частот всех букв
  // проходим по каждому элементу массива
  // charFreq.
  //
  // Цель — проверить, можно ли разделить
  // количество каждой буквы поровну между
  // всеми словами.
  for (const freq of charFreq) {

    // Проверяем, делится ли суммарная
    // частота данной буквы на количество
    // слов без остатка.
    //
    // Если частота буквы не кратна числу
    // слов, то невозможно распределить
    // эту букву поровну между всеми
    // словами, следовательно, нельзя
    // получить одинаковые слова путём
    // перераспределения букв — функция
    // возвращает false.
    if (freq % words.length !== 0) {
      return false;
    }
  }

  // Если для всех букв частоты делятся
  // на количество слов, значит можно
  // распределить буквы так, что каждое
  // слово получит одинаковый набор букв,
  // и, следовательно, возможно составить
  // одинаковые слова — возвращаем true.
  return true;
}
