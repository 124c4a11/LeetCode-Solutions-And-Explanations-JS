/**
 * @param {string} s
 * @param {number[][]} shift
 * @return {string}
 * 
 * stringShift принимает строку и набор инструкций сдвига,
 * вычисляет суммарный сдвиг по всем инструкциям,
 * нормализует его в диапазон длины строки и возвращает
 * новую строку, полученную циклическим сдвигом исходной
 * строки на этот суммарный сдвиг.  
 * 
 * Параметры
 * - s — входная строка
 * 
 * - shift — массив инструкций сдвига, где каждая
 *   инструкция ожидается в виде пары/массива 
 *   [direction, amount]:  
 *   - direction — флаг направления
 *     - 0 - left shift
 *     - 1 - right shift
 * 
 *   - amount — величина сдвига (ожидается число).  
 * 
 * Возвращает
 * Итоговую строку после применения всех сдвигов
 * 
 * Пример для:
 *   s = "abc"
 *   shift = [[0,1],[1,2]]
 * Результат:
 *   "cab"
 */
function stringShift(s, shift) {

  // Получаем длину входной строки и сохраняем в
  // константу n.
  //
  // Это значение используется для нормализации
  // сдвига и для операций slice.
  const n = s.length;

  // Инициализация аккумулятора netLeftShift,
  // который будет хранить суммарный сдвиг влево
  // (может быть отрицательным до нормализации)
  let netLeftShift = 0;

  // Проходим по каждой операции сдвига в массиве
  // shift.
  //
  // Ожидается, что каждая операция — это массив
  // вида [direction, amount].
  for (const move of shift) {

    // Если первый элемент пары truthy (равен 1),
    // это интерпретируется как правый сдвиг.
    //
    // Внутри алгоритма правый сдвиг преобразуется
    // в эквивалентный левый сдвиг с отрицательным
    // знаком, поэтому здесь знак количества
    // инвертируется при помощи умножения на -1:
    // move[1] *= -1.
    //
    // Важно:
    // Этот оператор изменяет сам массив shift
    // (мутация move[1]), но это безопасно, если
    // shift не требуется в исходном виде после
    // вызова функции.
    if (move[0]) move[1] *= -1

    // Добавление (возможно отрицательного)
    // значения текущей операции в общий суммарный
    // сдвиг.
    //
    // После этой строки netLeftShift отражает
    // накопленный эффект всех обработанных
    // операций.
    netLeftShift += move[1];
  }

  // Нормализация суммарного сдвига в диапазон
  // [0, n-1] с корректной обработкой отрицательных
  // значений.
  //
  // Выражение ((netLeftShift % n) + n) % n
  // обеспечивает положительный остаток при любом
  // netLeftShift, даже если netLeftShift
  // отрицателен или превышает n по модулю.
  //
  // Это важно, чтобы корректно определить, на
  // сколько символов сдвинуть строку влево в
  // циклическом смысле.
  //
  // 1. netLeftShift % n даёт остаток от деления
  //    (может быть отрицательным),
  //
  // 2. добавление n гарантирует положательное
  //    значение,
  //
  // 3. повторное взятие по модулю n приводит к
  //    корректному значению сдвига влево в
  //    пределах длины строки.
  netLeftShift = ((netLeftShift % n) + n) % n;

  // Выполнение циклического левого сдвига строки
  // на netLeftShift символов:
  //
  // Берём подстроку от netLeftShift до конца и
  // дописываем в конец подстроку от начала до
  // netLeftShift
  s = s.slice(netLeftShift) + s.slice(0, netLeftShift);

  // Возвращаем итоговую строку после применения
  // всех сдвигов
  return s;
}
