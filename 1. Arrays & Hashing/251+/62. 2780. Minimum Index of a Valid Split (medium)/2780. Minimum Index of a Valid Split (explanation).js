/**
 * @param {number[]} nums
 * @return {number}
 * 
 * minimumIndex принимает один параметр
 * — массив чисел nums — и возвращает минимальный
 * индекс i, при котором в левой части [0..i] и в
 * правой части [i+1..n-1] один и тот же элемент
 * является доминантным (мажоритарным - встречается
 * более чем в половине элементов каждой части).
 * 
 * Если такого индекса нет, функция возвращает -1
 * 
 * Пример для:
 *   nums = [1,2,2,2]
 * Результат:
 *   2
 * Пояснение:
 *   Мы можем разделить массив на позиции 2,
 *   получив массивы [1,2,2] и [2].
 * 
 *   В массиве [1,2,2] элемент 2 является
 *   доминирующим, так как он встречается два
 *   раза и 2 * 2 > 3.
 * 
 *   В массиве [2] элемент 2 является доминирующим,
 *   так как он встречается один раз и 1 * 2 > 1.
 * 
 *   Оба массива [1,2,2] и [2] имеют тот же
 *   доминирующий элемент, что и nums, поэтому это
 *   допустимое разбиение.
 * 
 *   Можно сказать, что индекс 2 — минимальный
 *   индекс допустимого разбиения.
 */
function minimumIndex(nums) {

  // Сохраняем длину входного массива в константу
  // n.
  //
  // Это избавляет от повторных обращений к
  // nums.length
  const n = nums.length;

  // Инициализируем переменную majority, которая
  // будет хранить текущего кандидата на
  // мажоритарный элемент.
  //
  // Начальное значение 0 — просто заглушка.
  // Реальное значение будет установлено в
  // цикле.
  let majority = 0;

  // Инициализируем счётчик cnt, используемый в
  // алгоритме Бойера — Мура.
  //
  // Он показывает относительную "весовую"
  // разницу между кандидатом и остальными
  // элементами.
  let cnt = 0;

  // Проходим по всем элементам массива nums,
  // чтобы найти кандидата на мажоритарный
  // элемент.
  //
  // Алгоритм Бойера — Мура гарантирует, что
  // если в массиве есть элемент, встречающийся
  // > n/2 раз, то после этого прохода
  // переменная majority будет содержать именно
  // этот элемент.
  for (const num of nums) {

    // Если счётчик равен нулю, текущий элемент
    // становится новым кандидатом.
    //
    // Это означает, что предыдущий кандидат
    // "уравновесился" с другими элементами и
    // можно начать считать заново.
    if (cnt === 0) majority = num;

    // Обновляем счётчик:
    // 
    // Если текущий элемент равен кандидату,
    // увеличиваем счётчик, иначе уменьшаем.
    //
    // Таким образом мы "компенсируем"
    // вхождения кандидата и других элементов.
    cnt += num === majority ? 1 : -1;
  }

  // После первого прохода majority — кандидат
  // на глобальный мажоритарный элемент.
  //
  // Теперь подготовим счётчики для прохода по
  // индексам и проверки условия для каждой
  // границы.
  //
  // leftMajorityCnt будет считать, сколько
  // раз кандидат встречается в левой части
  // при текущем i.
  let leftMajorityCnt = 0;

  // rightMajorityCnt изначально равен общему
  // числу вхождений кандидата в массив.
  //
  // Для этого используем фильтрацию массива
  // и подсчёт длины результата.
  //
  // Это даёт нам количество кандидатов в
  // правой части до начала итерации по
  // индексам.
  let rightMajorityCnt = nums.filter(
    (x) => x === majority
  ).length;

  // Проходим по всем индексам массива от
  // 0 до n-1, рассматривая границу после
  // индекса i.
  //
  // Для каждого i левая часть включает
  // элементы с индексами 0..i,
  // правая — i+1..n-1.
  for (let i = 0; i < n; i++) {

    // Если текущий элемент равен
    // кандидату, то при переходе границы
    // через этот элемент одно вхождение
    // кандидата переходит из правой
    // части в левую.
    if (nums[i] === majority) {

      // Увеличиваем счётчик в левой
      // части, так как текущее вхождение
      // кандидата nums[i] теперь 
      // принадлежит левой части.
      leftMajorityCnt++;

      // Уменьшаем счётчик в правой
      // части, так как текущее
      // вхождение кандидата "ушло"
      // влево.
      rightMajorityCnt--;
    }

    // Вычисляем длину левой части при
    // текущем i: элементы с 0 по i
    // включительно.
    const leftLen = i + 1;

    // Вычисляем длину правой части
    // при текущем i: элементы
    // с i+1 по n-1.
    const rightLen = n - i - 1;

    // Проверяем условие мажоритарности в
    // обеих частях одновременно:
    // — в левой части кандидат должен
    //   встречаться более чем в половине
    //   элементов левой части, то есть
    //   leftMajorityCnt * 2 > leftLen;
    //
    // — в правой части кандидат должен
    //   встречаться более чем в половине
    //   элементов правой части, то есть
    //   rightMajorityCnt * 2 > rightLen.
    //
    // Обратите внимание:
    // Если rightLen равен 0
    // (то есть i = n-1), условие
    // rightMajorityCnt * 2 > 0 означает,
    // что правая часть пуста и
    // мажоритарность в ней не может быть
    // выполнена, поэтому такой i
    // автоматически не будет принят (что
    // логично, так как правая часть
    // должна существовать).
    //
    // Если оба условия выполняются,
    // возвращаем текущий индекс i.
    //
    // Это будет минимальный индекс,
    // удовлетворяющий условию, поскольку
    // мы идём слева направо.
    if (
      leftMajorityCnt * 2 > leftLen
      && rightMajorityCnt * 2 > rightLen
    ) return i;
  }

  // Если ни один индекс не удовлетворил
  // условию, возвращаем -1.
  //
  // Это означает, что не существует
  // границы, при которой в обеих частях
  // один и тот же элемент является
  // мажоритарным.
  return -1;
}
