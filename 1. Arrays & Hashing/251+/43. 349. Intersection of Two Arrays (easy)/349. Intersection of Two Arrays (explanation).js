/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 * 
 * intersection возвращает массив уникальных значений,
 * которые присутствуют одновременно в двух входных
 * массивах.
 * 
 * Она принимает два массива — nums1 и nums2
 * 
 * Пример для:
 *   nums1 = [1,2,2,1]
 *   nums2 = [2,2]
 * Результат:
 *   [2]
 */
function intersection(nums1, nums2) {

  // Создаём Set на основе массива nums1.
  //
  // Это задаёт начальную коллекцию элементов, по
  // которой будем проверять принадлежность
  // элементов из nums2.
  //
  // Set обеспечивает O(1) среднее время проверки
  // наличия элемента и автоматически устраняет
  // дубликаты из nums1.
  const nums1Set = new Set(nums1);

  // Инициализируем пустой массив для накопления
  // результата.
  //
  // В этот массив будут добавляться только те
  // элементы, которые встречаются и в nums1,
  // и в nums2, причём каждый элемент
  // добавляется не более одного раза благодаря
  // последующему удалению из Set.
  const result = [];

  // Проходим по каждому элементу второго
  // массива nums2 в порядке их появления.
  //
  // Порядок добавления в result будет
  // соответствовать первому вхождению каждого
  // общего элемента в nums2.
  for (const num of nums2) {

    // Проверяем, содержится ли текущий
    // элемент num в множестве nums1Set.
    //
    // Если элемента нет (либо он изначально
    // отсутствовал в nums1, либо уже был
    // найден и удалён), то пропускаем
    // текущую итерацию и переходим к
    // следующему элементу nums2.
    if (!nums1Set.has(num)) continue;


    // Если элемент присутствует в nums1Set,
    // добавляем его в результирующий массив.
    //
    // Это гарантирует, что result содержит
    // только общие элементы.
    result.push(num);

    // Удаляем элемент из nums1Set сразу
    // после добавления в result.
    //
    // Это предотвращает повторное
    // добавление одного и того же значения,
    // если оно встречается в nums2 несколько
    // раз.
    nums1Set.delete(num);
  }

  // Возвращаем массив result, содержащий
  // уникальные элементы, присутствующие в
  // обоих входных массивах.
  //
  // Временная сложность алгоритма примерно
  // O(n + m), где n — длина nums1, m — длина
  // nums2.
  //
  // Дополнительная память — O(n) для хранения
  // Set (в худшем случае все элементы nums1
  // уникальны).
  return result;
}
