/**
 * @param {number[]} arr
 * @return {number}
 * 
 * findLucky принимает один параметр arr — массив чисел,
 * и возвращает наибольшее счастливое число из массива.
 * 
 * Счастливое число — это число, частота которого в
 * массиве равна его значению. 
 * 
 * Если таких чисел нет, функция возвращает -1.
 * 
 * Пример для:
 *   arr = [1,2,2,3,3,3]
 * Результат:
 *   3
 * Пояснение:
 *   1, 2 и 3 — все счастливые числа, возвращаем
 *   наибольшее из них - 3.
 */
function findLucky(arr) {

  // Создаём пустую коллекцию Map, где ключом будет
  // конкретное число из массива,
  // а значением — количество его вхождений.
  const numFreq = new Map();

  // Запускаем цикл по элементам входного массива
  // arr и для каждого уникального значения из arr
  // подсчитываем количество его вхождений,
  // сохраняя результаты в numFreq
  //
  // Пример map после цилкла:
  // { 1 => 1, 2 => 2, 3 => 3 }
  for (const num of arr) {

    // Получаем текущую сохранённую частоту для
    // числа num из Map.
    //
    // Если числа в Map ещё нет, numFreq.get(num)
    // вернёт undefined.
    //
    // Оператор nullish coalescing ?? заменяет
    // undefined на 0, чтобы корректно
    // инкрементировать счётчик.
    //
    // Затем к текущей частоте прибавляется 1,
    // и новое значение записывается обратно в Map
    // по ключу num.
    //
    // Таким образом после завершения цикла numFreq
    // будет содержать точный подсчёт вхождений
    // каждого числа.
    numFreq.set(num, (numFreq.get(num) ?? 0) + 1);
  }

  // Инициализируем переменную result значением -1.
  //
  // Это значение означает "не найдено подходящее
  // число" и будет возвращено, если ни одно число
  // не удовлетворяет условию.
  let result = -1;

  // Проходим по всем парам ключ/значение внутри
  // numFreq и пытаемся найти максимальное
  // "счастливое" число.
  // 
  // Метод forEach вызывает callback для каждой
  // пары.
  //
  // Параметры callback:
  //   freq (значение в Map)
  //   num (ключ в Map)
  numFreq.forEach((freq, num) => {

    // Сравниваем само число (num) и количество
    // его вхождений (freq).
    //
    // Условие true означает, что число
    // встречается в массиве ровно столько раз,
    // чему равно само число.
    //
    // Это и есть критерий "счастливого" числа
    // в этой задаче.
    if (num === freq) {

      // Если найдено "счастливое" число,
      // обновляем result так, чтобы
      // сохранить максимальное из найденных.
      result = Math.max(result, num);
    }

    // Пример работы цилка для:
    //   arr = [1,2,2,3,3,3]
    //   numFreq = { 1 => 1, 2 => 2, 3 => 3 }
    //
    // Проверка условий в Map.forEach
    // - Пара (num = 1, freq = 1)
    //     - Условие num === freq
    //       выполнено (1 === 1)
    //     - result = Math.max(-1, 1) → 1
    //
    // - Пара (num = 2, freq = 2)
    //     - Условие выполнено (2 === 2)
    //     - result = Math.max(1, 2) → 2
    //
    // - Пара (num = 3, freq = 3)
    //     - Условие выполнено (3 === 3)
    //     - result = Math.max(2, 3) → 3
    //
    // Возврат значения
    // - Функция возвращает result = 3
  });

  // Возвращаем итоговое значение:
  // либо наибольшее найденное "счастливое"
  // число, либо -1, если таких чисел нет.
  return result;
}
