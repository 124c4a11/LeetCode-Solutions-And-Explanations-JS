/**
 * @param {number[]} nums
 * @return {number}
 * 
 * specialArray принимает один аргумент — массив чисел nums
 * и возвращает целое число x такое, что ровно x элементов
 * массива больше или равны x, либо -1, если такого x не
 * существует.
 * 
 * Пример для:
 *   nums = [1, 2, 4, 5, 6]
 * Результат:
 *   3
 * Пояснение:
 *   Есть 3 значения (4, 5, 6), которые больше или равны 3.
 */
function specialArray(nums) {

  // Получаем длину входного массива и сохраняем в
  // константу n.
  //
  // Это верхняя граница для возможного значения x:
  // если x > n, то не может быть ровно x элементов >= x,
  // потому что в массиве всего n элементов. Поэтому
  // достаточно рассматривать x в диапазоне [0, n].
  const n = nums.length;

  // Создаём типизированный массив Int32Array длиной n+1
  // для подсчёта частот.
  //
  // valueCounts имеет длину n + 1, потому что индексы
  // 0..n-1 хранят количество элементов, точно равных
  // этим значениям, а дополнительный индекс n служит
  // как корзина для всех элементов, больших или равных
  // n. Это позволяет корректно и безопасно учитывать
  // числа > n и проверять все возможные значения x
  // от 0 до n
  //  
  // ---
  //
  // valueCounts — структура и общий смысл
  // 
  // valueCounts — это массив счётчиков длиной n + 1,
  // где n — длина входного массива nums. Он служит
  // для компактного представления распределения
  // значений из nums так, чтобы быстро можно было
  // узнать, сколько элементов массива равны
  // конкретному числу или больше либо равны
  // некоторому порогу.
  // 
  // ---
  // 
  // Что означает индекс в valueCounts
  // 
  // - Индекс i (0 ≤ i < n) — соответствует числу i.
  //   Ячейка valueCounts[i] хранит количество
  //   элементов входного массива, которые ровно
  //   равны i.  
  //
  // - Индекс n — специальная корзина для всех
  //   значений, которые больше или равны n. То есть
  //   valueCounts[n] содержит количество элементов
  //   num таких, что num >= n
  // 
  // ---
  // 
  // Что означает значение в каждой ячейке
  // 
  // - Значение valueCounts[i] — целое число, равное
  //   числу элементов, попавших в корзину i  
  //   - Для i < n это количество элементов, точно
  //     равных i
  //
  //   - Для i === n это количество элементов,
  //     больше или равных n
  //
  // - После заполнения массива суммарное количество
  //   по всем ячейкам равно n (длина исходного
  //   массива).
  // 
  // ---
  // 
  // Почему используется такая схема
  // 
  // В задаче нужно быстро узнать для каждого i
  // количество элементов, больших или равных i.
  // Если у нас есть valueCounts, то при обратном
  // проходе по индексам накопление сумм
  // valueCounts[i]
  //   + valueCounts[i+1]
  //   + ... + valueCounts[n] даёт ровно количество
  // элементов >= i. Это позволяет проверить условие
  // totalRight === i за линейное время без
  // сортировки.
  // 
  // ---
  // 
  // Наглядный пример
  // 
  // Пусть nums = [3, 5, 0, 3, 4],
  // тогда n = 5 и valueCounts имеет длину 6
  // (индексы 0..5).
  // 
  // - Подсчёт по элементам:
  //   - 0 → valueCounts[0] = 1
  //   - 3 → valueCounts[3] = 2
  //   - 4 → valueCounts[4] = 1
  //   - 5 → valueCounts[5] = 1 (так как 5 ≥ n,
  //     попадает в корзину n)
  //   - остальные ячейки — 0
  // 
  // Итоговый valueCounts (индекс:значение):  
  //  0:1; 1:0; 2:0; 3:2; 4:1; 5:1
  // 
  // При обратном проходе:
  // - Для i = 5:
  //   totalRight = valueCounts[5] = 1
  //   → количество элементов ≥ 5 равно 1.
  //
  // - Для i = 4:
  //   totalRight = 1 + valueCounts[4] = 2
  //   → количество элементов ≥ 4 равно 2.
  //
  // - Для i = 3: 
  //   totalRight = 2 + valueCounts[3] = 4
  //   → количество элементов ≥ 3 равно 4.
  //
  // - И т.д.
  const valueCounts = new Int32Array(n + 1);

  // Итерация по каждому элементу входного массива
  // nums.
  //
  // Цель — заполнить valueCounts так, чтобы затем
  // можно было быстро подсчитать, сколько
  // элементов >= некоторого i, суммируя счётчики
  // от i до n.
  for (const num of nums) {

    // Вычисляем индекс i как минимум между
    // текущим числом и n.
    // 
    // Это гарантирует, что все значения больше n
    // попадут в корзину с индексом n
    const i = Math.min(num, n);

    // Увеличиваем счётчик для соответствующего
    // индекса i на единицу.
    //
    // Таким образом valueCounts[k] в конце цикла
    // будет равен количеству элементов массива,
    // которые равны k для k < n, и количеству
    // элементов >= n для k === n.
    valueCounts[i]++;

    // Пример работы цикла для:
    //
    // - nums = [1, 2, 4, 5, 6]
    //
    // ---
    //
    //  Исходные данные
    //
    // - nums = [1, 2, 4, 5, 6]
    //
    // - n = nums.length = 5  
    //
    // - valueCounts = [0, 0, 0, 0, 0, 0]
    //   (индексы от 0 до 5)
    //
    // ---
    //
    // Шаг 1 (num = 1)
    //
    // - Вычисляем 
    //   i = Math.min(num, n)
    //     = Math.min(1, 5) = 1
    //
    // - Увеличиваем 
    //   valueCounts[1]++  
    //
    // - После этого
    //   valueCounts = [0, 1, 0, 0, 0, 0]
    //
    // ---
    //
    // Шаг 2 (num = 2)
    //
    // - Вычисляем 
    //   i = Math.min(num, n)
    //     = Math.min(2, 5) = 2  
    //
    // - Увеличиваем
    //   valueCounts[2]++  
    //
    // - valueCounts = [0, 1, 1, 0, 0, 0]
    //
    // ---
    //
    // Шаг 3 (num = 4)
    //
    // - Вычисляем
    //   i = Math.min(4, 5) = 4  
    //
    // - Увеличиваем
    //   valueCounts[4]++  
    //
    // - valueCounts = [0, 1, 1, 0, 1, 0]
    //
    // ---
    //
    // Шаг 4 (num = 5)
    //
    // - Вычисляем
    //   i = Math.min(5, 5) = 5  
    //
    // - Увеличиваем
    //   valueCounts[5]++  
    //
    // - valueCounts = [0, 1, 1, 0, 1, 1]
    //
    // ---
    //
    // Шаг 5 (num = 6)
    //
    // - Вычисляем
    //   i = Math.min(6, 5) = 5  
    //
    // - Увеличиваем 
    //   valueCounts[5]++
    //
    // - valueCounts = [0, 1, 1, 0, 1, 2]
    //
    // ---
    //
    // Итог после завершения цикла
    //
    // - valueCounts = [0, 1, 1, 0, 1, 2]  
    //
    // Это значит:  
    // - 0 элементов равны 0  
    // - 1 элемент равен 1  
    // - 1 элемент равен 2  
    // - 0 элементов равны 3  
    // - 1 элемент равен 4  
  }

  // Инициализируем аккумулятор totalRight нулём.
  //
  // В дальнейшем при обратном проходе по
  // индексам он будет хранить количество
  // элементов, значение которых >= текущего
  // рассматриваемого индекса i (то есть
  // суммарное количество справа).
  let totalRight = 0;

  // Обратный проход по индексам от n до 0
  // включительно.
  //
  // Идея:
  // На шаге с индексом i после добавления
  // valueCounts[i] переменная totalRight
  // будет равна количеству элементов массива
  // nums, которые >= i.
  for (let i = n; i >= 0; i--) {

    // Добавляем к totalRight количество
    // элементов, равных текущему i.
    //
    // После этой операции totalRight равен
    // количеству элементов массива, значение
    // которых >= i.
    totalRight += valueCounts[i];

    // Если количество элементов с 
    // значением >= i равно самому i, то
    // найдено требуемое значение x = i.
    //
    // Возвращаем найденное значение
    // немедленно, так как задача требует
    // любое такое x (они уникальны в данном
    // контексте).
    //
    // Заметьте:
    // Проверка выполняется для i от n вниз,
    // поэтому при нескольких возможных
    // значениях будет возвращено наибольшее
    // из них. Однако по свойствам задачи
    // одновременно могут существовать не
    // более одного целого x,
    // удовлетворяющего условию.
    if (totalRight === i) return totalRight;

    // Пример работы цикла для 
    //
    // - nums = [1, 2, 4, 5, 6]
    //
    // ---
    // 
    // Мы уже знаем, что после первого цикла
    // состояние массива счётчиков:  
    //
    // - valueCounts = [0, 1, 1, 0, 1, 2]  
    //   (где индекс 5 хранит все значения ≥ 5).  
    //
    // - n = 5.  
    //
    // ---
    //
    // Исходные данные
    //
    // - totalRight = 0 (начальное значение)  
    //
    // - Цикл идёт от `i = 5` вниз до `i = 0`  
    //
    // ---
    //
    // Шаг 1 (i = 5)
    //
    // - Перед шагом:
    //   totalRight = 0
    //
    // - Прибавляем 
    //   valueCounts[5] = 2
    //   → totalRight = 0 + 2 = 2  
    //
    // - Проверка:
    //   if (totalRight === i)
    //   → 2 === 5
    //   → условие не выполняется  
    //
    // ---
    //
    // Шаг 2 (i = 4)
    //
    // - Перед шагом:
    //   totalRight = 2  
    //
    // - Прибавляем
    //   valueCounts[4] = 1
    //   → totalRight = 2 + 1 = 3  
    //
    // - Проверка:
    //   if (totalRight === i)
    //   → 3 === 4
    //   → условие не выполняется  
    //
    // ---
    //
    // Третий шаг цикла (i = 3)
    //
    // - Перед шагом:
    //   totalRight = 3  
    //
    // - Прибавляем
    //   valueCounts[3] = 0
    //   → totalRight = 3 + 0 = 3
    //
    // - Проверка:
    //   if (totalRight === i)
    //   → 3 === 3
    //   → условие выполняется
    //
    // - Функция возвращает 3
    //   и цикл завершается  
    //
    // ---
    //
    // Итог
    // Для массива nums = [1, 2, 4, 5, 6]
    // функция завершает работу на шаге
    // i = 3 и возвращает значение 3.  
  }

  // Если цикл завершился и ни для какого i
  // условие не выполнилось, возвращаем -1,
  // что означает отсутствие целого x, для
  // которого ровно x элементов массива >= x.
  return -1;
}
