/**
 * @param {number[]} nums
 * @return {number[]}
 * 
 * findErrorNums решает задачу, где изначально множество
 * содержит числа от 1 до n, но из‑за ошибки одно число
 * оказалось продублировано, а другое исчезло.
 * 
 * На вход подаётся массив nums с этой «повреждённой»
 * версией множества, и нужно вернуть повторяющееся и
 * отсутствующее числа в массиве вида
 * [duplicate, missing].  
 * 
 * 
 * Пример для:
 *   nums = [1,2,2,4]
 * Результат:
 *   [2,3]
 *
 *
 * Пример для:
 *   nums = [1,1]
 * Результат:
 *   [1,2]
 */
function findErrorNums(nums) {

  // Создаём массив result длины 2 для хранения ответа:
  // - result[0] — найденное повторяющееся число,
  // - result[1] — найденное отсутствующее число.
  //   Инициализируем нулями, чтобы иметь предсказуемое
  //   значение.
  const result = [0, 0];

  // Проходим по каждому элементу входного массива nums
  //
  // Цикл помечает встреченные числа в массиве nums,
  // инвертируя знак элемента по индексу absNum - 1.
  // Если при попытке пометить элемент он уже
  // отрицательный, значит соответствующее число уже
  // встречалось — это дубликат, который записывается
  // в result[0].
  //
  // Важно:
  // В теле цикла мы будем изменять элементы массива
  // nums (помечать их отрицательными), поэтому далее
  // берём абсолютное значение текущего элемента,
  // чтобы корректно работать с уже помеченными
  // элементами.
  for (const num of nums) {

    // Берём абсолютное значение текущего элемента
    // num и сохраняем в absNum.
    //
    // Абсолютное значение нужно, потому что в
    // предыдущих итерациях мы могли инвертировать
    // знак элементов массива nums, и текущий элемент
    // может быть отрицательным.
    const absNum = Math.abs(num);

    // Обращаемся к элементу массива nums по индексу
    // absNum - 1 (соответствие значения индексу).
    //
    // Если значение на этой позиции уже отрицательное,
    // это означает, что ранее мы уже встречали число
    // absNum, то есть текущее значение absNum
    // — повтор.
    //
    // Используем absNum - 1 потому что индексы в
    // JavaScript‑массиве начинаются с нуля
    // 
    // Числа в задаче лежат в диапазоне 1..n, а
    // индексы массива — в диапазоне 0..n-1. Вычитая 1
    // из absNum, мы переводим значение числа в
    // соответствующий нулевой индекс:
    //   число 1 → индекс 0,
    //   число 2 → индекс 1,
    //   число 3 → индекс 2
    //   и т.д.  
    // 
    // Дополнительно absNum берётся через Math.abs,
    // чтобы корректно работать с уже помеченными
    // (отрицательными) элементами: даже если элемент
    // в массиве стал отрицательным, Math.abs(num)
    // вернёт исходное положительное значение для
    // вычисления правильного индекса.
    if (nums[absNum - 1] < 0) {

      // Записываем повторяющееся число в result[0].
      //
      // Здесь мы сохраняем само значение (absNum),
      // а не индекс, потому что числа в массиве
      // нумеруются от 1 до n.
      result[0] = absNum;
    } else {

      // Если значение на позиции absNum - 1
      // положительное, помечаем его как посещённое,
      // умножая на -1.
      // 
      // Это in-place пометка, позволяющая не
      // использовать дополнительную память.
      //
      // После этого позиция станет отрицательной и
      // сигнализирует о том, что соответствующее
      // число уже встречалось.
      nums[absNum - 1] *= -1;
    }

    // Пример работы цикла для nums = [1,2,2,4]
    //
    // ---
    //
    // Начальное состояние перед циклом:  
    //   nums = [1, 2, 2, 4]`  
    //   result = [0, 0]`
    //
    // ---
    // 
    // Шаг 1 (первый элемент массива):  
    // - Текущее значение num = 1. 
    //
    // - Вычисляем absNum = Math.abs(num) = 1  
    //
    // - Проверяем 
    //     nums[absNum - 1]
    //     → nums[0] равно 1 (положительное).  
    //
    // - Действие: 
    //     помечаем число 1 как встреченное,
    //     умножая nums[0] на -1  
    //
    // - Состояние после шага: 
    //     nums = [-1, 2, 2, 4],
    //     result = [0, 0]
    //
    // ---
    // 
    // Шаг 2 (второй элемент массива):
    // - Текущее значение num = 2  
    //
    // - Вычисляем absNum = 2  
    //
    // - Проверяем 
    //     nums[absNum - 1]
    //     → nums[1] равно 2 (положительное).  
    //
    // - Действие: 
    //     помечаем число 2 как встреченное,
    //     умножая nums[1] на -1.  
    //
    // - Состояние после шага:
    //     nums = [-1, -2, 2, 4],
    //     result = [0, 0]
    // 
    // ---
    //
    // Шаг 3 (третий элемент массива):
    // - Текущее значение num = 2 (в исходном
    //   массиве третий элемент тоже 2).  
    //
    // - Вычисляем absNum = 2.  
    //
    // - Проверяем 
    //     nums[absNum - 1]
    //     → nums[1] равно -2 (уже отрицательное).  
    //
    // - Поскольку элемент по этому индексу уже
    //   отрицательный, это означает, что число 2
    //   встречалось ранее — фиксируем дубликат:
    //     result[0] = 2
    //
    // - Массив не меняется на этом шаге.  
    //
    // - Состояние после шага:
    //     nums = [-1, -2, 2, 4],
    //     result = [2, 0]
    //
    // ---
    // 
    // Шаг 4 (четвёртый элемент массива):
    // - Текущее значение num = 4
    //
    // - Вычисляем absNum = 4
    //
    // - Проверяем 
    //     nums[absNum - 1]
    //     → nums[3] равно 4 (положительное).  
    //
    // - Действие:
    //     помечаем число 4 как встреченное,
    //     умножая nums[3] на -1  
    //
    // - Состояние после шага:
    //     nums = [-1, -2, 2, -4],
    //     result = [2, 0]
    // 
    // ---
    //
    // Итог после завершения цикла:
    // - Массив nums = [-1, -2, 2, -4]
    //
    // - Положительный элемент nums[2] = 2
    //   указывает, что число 3
    //   (индекс 2 → i+1 = 3) не
    //   встречалось.
    //
    // - Полный ответ будет сформирован как
    //   result = [2, 3] — 2 повторяется,
    //   3 отсутствует.
  }

  // Второй проход по массиву nums:
  // Теперь положительные элементы указывают
  // на те индексы, которые не были помечены
  // как посещённые — то есть соответствующие
  // числа отсутствуют.
  for (let i = 0; i < nums.length; i++) {

    // Условие состоит из двух частей:
    // 1. nums[i] > 0 — позиция i не была
    //    помечена (значение осталось
    //    положительным), значит число i+1
    //    не встречалось.
    //
    // 2. i + 1 !== result[0]
    //    - это защитный приём, который
    //    исключает ситуацию, когда по
    //    какой‑то причине мы могли бы
    //    присвоить отсутствующим то же
    //    самое значение, что и дубликат.
    // 
    //    Иначе говоря, она гарантирует,
    //    что в результате два числа будут
    //    разными: 
    //      один — повтор,
    //      другой — отсутствующий.
    //
    //    В корректной задаче это не
    //    должно происходить
    if (
      nums[i] > 0
      && i + 1 !== result[0]
    ) {

      // Записываем отсутствующее число
      // (индекс + 1) в result[1].
      //
      // Используем i + 1, потому что
      // индексы массива начинаются с 0,
      // а значения в задаче — с 1.
      result[1] = i + 1;

      // Как только найдено отсутствующее
      // число, возвращаем результат
      // — дальнейный перебор не нужен.
      return result;
    }

    // Пример работы второго цикла для
    //   nums = [-1, -2, 2, -4]
    //
    //---
    // 
    // Исходное состояние перед циклом: 
    //   nums = [-1, -2, 2, -4]
    //   result = [2, 0]
    // 
    // ---
    //
    // Шаг i = 0:  
    // - Проверяем условие: 
    //     nums[0] > 0
    //     → -1 > 0 — ложь.
    //
    // - Так как первое условие ложно,
    //   тело if не выполняется,
    //   result не меняется.  
    //
    // - Состояние после шага:
    //     nums = [-1, -2, 2, -4],
    //     result = [2, 0]
    // 
    // ---
    //
    // Шаг i = 1:
    // - Проверяем условие:
    //     nums[1] > 0
    //     → -2 > 0 — ложь.
    //
    // - Тело if не выполняется,
    //   result остаётся прежним. 
    // 
    // - Состояние после шага:
    //     nums = [-1, -2, 2, -4],
    //     result = [2, 0]
    // 
    // ---
    //
    // Шаг i = 2:
    // - Проверяем условие:
    //     nums[2] > 0
    //     → 2 > 0 — истина.  
    //
    // - Дополнительная проверка:
    //     i + 1 !== result[0]
    //     → 3 !== 2 — истина.  
    //
    // - Оба условия выполнены, поэтому
    //   выполняется тело if: 
    //     присваиваем `result[1] = i + 1`,
    //     то есть `result[1] = 3`,
    //     и выполняем `return result`.  
    //
    // - Перед возвратом состояние:
    //     nums = [-1, -2, 2, -4],
    //     result = [2, 3]
    //
    // ---
    // 
    // Шаг i = 3:
    // - Не выполняется, так как функция
    //   уже вернула результат на
    //   предыдущем шаге.
    // 
    // ---
    //
    // Итог: 
    // Цикл находит первый индекс i, где
    // nums[i] > 0 и i + 1 не равен найденному
    // дубликату, записывает i + 1 в result[1]
    // и сразу возвращает [2, 3] — повторяющееся
    // число 2 и отсутствующее число 3.
  }

  // Если цикл завершился без раннего return
  // (например, в редких крайних случаях),
  // возвращаем массив result, который может
  // содержать найденный повтор и/или 0 для
  // отсутствующего.
  return result;
}
