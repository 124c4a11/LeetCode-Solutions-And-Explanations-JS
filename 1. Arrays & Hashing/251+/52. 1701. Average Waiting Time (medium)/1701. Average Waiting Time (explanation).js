/**
 * @param {number[][]} customers
 * @return {number}
 * 
 * averageWaitingTime моделирует ресторан с одним поваром,
 * который готовит заказы по очереди в том порядке, в
 * котором они заданы в массиве. Для каждого клиента
 * считается время от его прибытия до момента, когда его
 * заказ полностью готов. Затем возвращается среднее по
 * всем клиентам.
 * 
 * Параметры:
 * - customers — массив массивов, где каждый элемент имеет
 *   вид [arrival, time], где arrival — время прибытия
 *   клиента (число), а time — время приготовления его
 *   заказа (число).  
 * 
 * - arrival в исходной задаче гарантированно не убывает
 *   по мере индексов (отсортирован по неубыванию)
 *   функция корректно работает и без этого предположения,
 *   если порядок задан явно.
 * 
 * 
 * Пример для:
 *   customers = [[1,2],[2,5],[4,3]]
 * Результат:
 *   5.0`
 * Пояснение:
 *   Суммарные времена клиентов равны 2, 6, 7,
 *   а среднее (2+6+7) / 3 = 5
 */
function averageWaitingTime(customers) {

  // Инициализация переменной currEndTime значением 0.
  //
  // Эта переменная моделирует момент времени, когда
  // текущий (последний обработанный) заказ будет
  // завершён.
  //
  // Интерпретация:
  // - если currEndTime <= arrival следующего клиента,
  //   то повар свободен к моменту прихода клиента
  //
  // - если currEndTime > arrival, то новый клиент
  //   будет ждать до currEndTime.
  let currEndTime = 0;

  // Инициализация аккумулятора totalWaitingTime
  // значением 0.
  //
  // Эта переменная аккумулирует суммарное время,
  // которое все клиенты провели в системе (время от
  // прибытия до полного завершения их заказа). 
  let totalWaitingTime = 0;

  // Итерация по каждому элементу входного массива
  // customers.
  //
  // Не используем деструктуризацию элементов массива
  // для ускорения работы кода
  for (const customer of customers) {

    // Извлечение времени прибытия из текущей записи.
    const arrival = customer[0];

    // Извлечение времени приготовления заказа из
    // текущей записи.
    const order = customer[1];

    // Обновление времени окончания обслуживания для
    // текущего клиента.
    //
    // Math.max(currEndTime, arrival) выбирает момент,
    // когда фактически начнётся обслуживание этого
    // клиента:
    // — если currEndTime > arrival, то повар всё ещё
    //   занят предыдущими заказами, и новый заказ
    //   начнётся в currEndTime
    //
    // — если currEndTime <= arrival, повар свободен и
    //   начнёт готовить сразу при arrival
    //
    // Затем к моменту начала прибавляется время
    // приготовления order, получая момент завершения
    // currEndTime.
    //
    // Это корректно моделирует последовательную
    // обработку заказов одним поваром/кассой.
    currEndTime = Math.max(currEndTime, arrival) + order;

    // Накопление времени, проведённого текущим клиентом
    // в системе.
    //
    // currEndTime - arrival — это полное время от
    // прихода клиента до завершения его заказа,
    // включающее как ожидание в очереди (если оно было),
    // так и время приготовления.
    //
    // Это значение добавляется к общему суммарному
    // времени ожидания totalWaitingTime.
    totalWaitingTime += currEndTime - arrival;
  }

  // Возврат среднего времени ожидания всех клиентов.
  //
  // Вычисляется как суммарное время ожидания, делённое
  // на количество клиентов customers.length.
  //
  // Результат — число с плавающей точкой (если
  // суммарное время не кратно количеству клиентов).
  //
  // Важное замечание по устойчивости:
  // Если customers.length === 0, то произойдёт деление
  // на ноль, что в JavaScript даст значение Infinity
  // или NaN. При необходимости следует добавить
  // проверку на пустой массив.
  return totalWaitingTime / customers.length;
}
