/**
 * @param {string[]} words
 * @return {string[]}
 * 
 * commonChars находит символы, которые встречаются во
 * всех строках переданного массива, учитывая
 * количество повторов.
 * 
 * Параметры:
 * - words — массив строк.
 * 
 * Возвращаемое значение
 *   Массив строк, где каждая строка — это один символ
 *   (например, "a", "b"). Если общих символов нет,
 *   возвращается пустой массив.
 * 
 * 
 * Пример для:
 *   words = ["bella","label","roller"]
 * Результат:
 *   ["e","l","l"]
 * 
 * 
 * Пример для:
 *   words = ["cool","lock","cook"]
 * Результат:
 *   ["c","o"]
 */
function commonChars(words) {

  // Создаём пустой массив result для накопления
  // найденных общих символов.
  //
  // В него будут добавляться символы в том порядке,
  // в котором они встречаются в первой строке.
  const result = [];

  // Проходим по каждому символу первой строки
  // массива words[0].
  for (const char of words[0]) {

    // Проверяем, содержится ли текущий символ char
    // во всех строках массива words.
    //
    // Метод every возвращает true только если для
    // каждой строки w функция w.includes(char)
    // возвращает true.
    if (words.every((w) => w.includes(char))) {

      // Если символ есть во всех строках, добавляем
      // его в массив result.
      //
      // Это обеспечивает учёт кратности символов:
      // каждый раз, когда символ подтверждён во
      // всех строках, он добавляется в результат и
      // затем удаляется из строк, чтобы не
      // обрабатываться повторно.
      result.push(char);

      // После добавления символа мы удаляем первое
      // вхождение этого символа из каждой строки
      // массива words.
      //
      // Для этого используется words.map, который
      // создаёт новый массив строк, где каждая
      // строка заменена на результат
      // w.replace(char, "").
      //
      // replace с первым аргументом-строкой удаляет
      // только первое совпадение, что позволяет
      // корректно учитывать кратность символов:
      // если символ встречается дважды в одной
      // строке, он может быть найден и добавлен в
      // result дважды, но только если в каждой
      // итерации все строки содержат ещё одно
      // вхождение.
      //
      // Обратите внимание:
      // Здесь мы переназначаем переменную words на
      // новый массив. Исходный массив, переданный
      // в функцию, не модифицируется (мы не меняем
      // его элементы на месте), но ссылка words
      // внутри функции теперь указывает на новый
      // массив.
      words = words.map((w) => w.replace(char, ""));
    }
  }

  // Возвращаем массив result, содержащий общие
  // символы (с учётом кратности) в порядке их
  // появления в первой строке.
  return result;
}
