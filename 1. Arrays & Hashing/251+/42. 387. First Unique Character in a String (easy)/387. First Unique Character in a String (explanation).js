/**
 * @param {string} s
 * @return {number}
 * 
 * firstUniqChar ищет первый символ в строке s, который
 * встречается ровно один раз, и возвращает его индекс.
 * 
 * Если такого символа нет — возвращает -1.
 * 
 * Она принимает  параметр s — строку (в контексте
 * задачи предполагаются строчные английские буквы).
 * 
 * 
 * Пример для:
 *   s = "leetcode"
 * Результат:
 *   0
 * Пояснение:
 *   Символ l на индексе 0 — первый символ, который не
 *   встречается ни в каком другом индексе.
 */
function firstUniqChar(s) {

  // Получаем длину строки s и сохраняем в
  // переменной n.
  //
  // Это значение используется как "граница" или
  // "сигнал", что уникальный символ пока не найден.
  const n = s.length;

  // Задаём строку со всеми буквами английского
  // алфавита в нижнем регистре.
  //
  // Перебор будет идти именно по этим буквам,
  // чтобы проверить каждую из них в строке s.
  const letters = "abcdefghijklmnopqrstuvwxyz";

  // Инициализируем переменную result значением n.
  //
  // Это означает, что пока уникальный символ не
  // найден, результат равен длине строки.
  //
  // Если в итоге result останется равным n,
  // значит уникальных символов нет.
  //
  // Если уникальные символы существуют, то
  // значение result будет изменено на индекс
  // первого уникального символа в строке s
  let result = n;

  // Запускаем цикл по всем буквам алфавита.
  // i — индекс текущей буквы в строке letters.
  for (let i = 0; i < letters.length; i++) {

    // Находим индекс первого вхождения
    // текущей буквы letters[i] в строке s.
    //
    // Если буква отсутствует, indexOf вернёт -1.
    const firstNdx = s.indexOf(letters[i]);

    // Проверяем три условия:
    // 1. firstNdx !== -1 → буква действительно
    //    встречается в строке.
    // 
    // 2. firstNdx === s.lastIndexOf(letters[i])
    //    → буква встречается ровно один раз,
    //      потому что индекс первого и
    //      последнего вхождения совпадает.
    //
    // 3. firstNdx < result → найденный индекс
    //    меньше текущего результата, то есть
    //    буква встречается раньше, чем
    //    предыдущая найденная уникальная.
    //
    // Если все условия выполнены, обновляем
    // result на индекс этой буквы.
    //
    // Таким образом, мы всегда сохраняем
    // минимальный индекс уникального символа.
    if (
      firstNdx !== -1
      && firstNdx === s.lastIndexOf(letters[i])
      && firstNdx < result
    ) result = firstNdx;
  }

  // После завершения цикла проверяем:
  //
  // Если result осталось равным n, значит
  // уникальных символов не найдено
  // → возвращаем -1.
  //
  // Иначе возвращаем найденный индекс первой
  // уникальной буквы.
  return result === n ? -1 : result;
}
