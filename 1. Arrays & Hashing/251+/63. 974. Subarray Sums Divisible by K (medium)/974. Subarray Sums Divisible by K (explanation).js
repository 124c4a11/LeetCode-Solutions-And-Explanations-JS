/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 * 
 * subarraysDivByK считает количество непрерывных
 * подмассивов массива nums, сумма элементов
 * которых делится на k без остатка. 
 * 
 * Параметры:
 * - nums — массив целых чисел. Массив может
 *   содержать положительные и отрицательные
 *   числа.  
 * 
 * - k — целое число (обычно положительное)
 *   — модуль, по которому проверяется делимость
 *   сумм подмассивов.  
 * 
 * Возвращаемое значение:
 * Целое число — количество непустых подмассивов
 * nums[i..j], сумма элементов которых делится
 * на k без остатка. 
 * 
 * Описание алгоритма:
 * Функция использует префиксные суммы и остатки
 * по модулю k.
 * 
 * Идея в том, что если две префиксные суммы дают
 * одинаковый остаток при делении на k, то
 * разность этих префиксных сумм (а значит и
 * сумма подмассива между ними) делится на k.
 * Это позволяет за один проход по массиву
 * подсчитывать все подходящие подмассивы, не
 * проверяя все пары индексов.
 * 
 * Пример для:
 *   nums = [4,5,0,-2,-3,1],
 *   k = 5
 * Результат:
 *   7
 * Пояснение:
 *   Существует 7 подмассивов, сумма которых
 *   делится на k = 5 без остатка:
 *   [4, 5, 0, -2, -3, 1],
 *   [5],
 *   [5, 0],
 *   [5, 0, -2, -3],
 *   [0],
 *   [0, -2, -3],
 *   [-2, -3]
 */
function subarraysDivByK(nums, k) {

  // Создаём типизированный массив Int32Array
  // длины k для хранения счётчиков префиксных
  // сумм по остаткам.
  //
  // Int32Array экономичнее по памяти и быстрее
  // для числовых операций по сравнению с
  // обычным массивом
  //
  // Индекс соответствует остатку от деления
  // префиксной суммы на k, а значение
  // — количеству таких префиксов.
  const remainderCount = new Int32Array(k);

  // Это учитывает префикс "пустой" (сумма
  // ноль до начала массива), чтобы подмассивы,
  // начинающиеся с индекса 0, корректно
  // считались, если их сумма даёт остаток 0.
  remainderCount[0] = 1;

  // Переменная для хранения текущего
  // префиксного остатка (суммы элементов от
  // начала до текущей позиции) по модулю k.
  //
  // Изначально 0, так как сумма пустого префикса
  // равна 0.
  let prefixRemainder = 0;

  // Переменная-аккумулятор для итогового
  // количества подмассивов, сумма которых
  // делится на k.
  let result = 0;

  // Итерация по каждому элементу входного
  // массива nums в порядке следования.
  for (const num of nums) {

    // Обновляем префиксный остаток, добавляя
    // текущее число.
    //
    //
    // Пошаговое объяснение выражения
    // ((prefixRemainder + num) % k + k) % k
    //
    // 1. prefixRemainder + num
    //    - Берём предыдущий остаток префиксной
    //      суммы и добавляем к нему текущее
    //      число num
    //
    //    - Это фактически обновляет префиксную
    //      сумму: мы учитываем все элементы до
    //      текущего включительно.
    //
    // 2. (prefixRemainder + num) % k
    //    - Берём остаток от деления новой
    //      префиксной суммы на k
    //
    //    - В JavaScript оператор % возвращает
    //      остаток, но он может быть
    //      отрицательным, если делимое
    //      отрицательное.  
    //      Например: -1 % 5 даст -1, а не 4.
    //
    // 3. ((prefixRemainder + num) % k + k)
    //    - Добавляем k к результату.  
    //
    //    - Это нужно для того, чтобы
    //      избавиться от отрицательных
    //      значений.  
    //
    //    - Если остаток был отрицательный,
    //      прибавление k гарантирует, что
    //      результат станет неотрицательным.  
    //      Например: (-1 % 5) + 5 = -1 + 5 = 4
    //
    // 4. ((prefixRemainder + num) % k + k) % k
    //    - Ещё раз берём % k, чтобы
    //      нормализовать результат в диапазон 
    //      от 0 до k-1
    //
    //    - Даже если после прибавления k число
    //      стало больше k, этот второй % k
    //      вернёт корректный остаток.  
    //
    //    - Таким образом, итоговое значение
    //      всегда находится в диапазоне
    //      [0, k-1]
    //
    // В результате prefixRemainder всегда
    // остаётся валидным индексом в remainderCount.
    prefixRemainder = ((prefixRemainder + num) % k + k) % k;

    // Если ранее встречались префиксы с таким же
    // остатком prefixRemainder, то разность между
    // текущим префиксом и каждым из них даёт
    // подмассив, сумма которого делится на k.
    // То есть для каждого такого префикса
    // существует непрерывный подмассив между
    // концом того префикса и текущей позицией,
    // сумма которого делится на k.
    // 
    // Это ключевая идея:
    // Пары префиксов с одинаковым остатком
    // соответствуют подмассивам, сумма которых
    // кратна k.
    //
    // Добавляем количество таких префиксов к
    // результату.
    result += remainderCount[prefixRemainder];

    // Увеличиваем счётчик для текущего остатка,
    // фиксируя, что ещё один префикс с этим
    // остатком встретился.
    //
    // Это влияет на будущие итерации:
    // Последующие элементы смогут образовывать
    // подмассивы с началом в этом префиксе.
    //
    // Это важно:
    // Сначала считаем существующие совпадения,
    // затем инкрементируем.
    remainderCount[prefixRemainder]++;
  }

  // Пример работы цикла для:
  //   nums = [4, 5, 0, -2, -3, 1];
  //   k = 5  
  //
  // Начальное состояние
  // - nums = [4, 5, 0, -2, -3, 1];
  //
  // - k = 5  
  //
  // - remainderCount = [1, 0, 0, 0, 0]
  //   — счётчики префиксных остатков по индексам
  //     0..4 (инициализировано
  //     remainderCount[0] = 1).  
  //
  // - prefixRemainder = 0 — текущий остаток
  //   префиксной суммы.  
  //
  // - result = 0 — накопленное количество
  //   подмассивов, сумма которых делится на k.
  //
  // ---
  //
  // Шаг 1 (num = 4)
  //
  // - Вычисление префиксного остатка:
  //   (0 + 4) % 5 = 4. Нормализация через
  //   ((...) % k + k) % k даёт 
  //   prefixRemainder = 4
  //
  // - Сколько ранее было префиксов с остатком 4:
  //   remainderCount[4] = 0, значит новых
  //   подмассивов не добавляется.  
  //
  // - Обновление результата:
  //   result = 0 + 0 = 0
  //
  // - Увеличиваем счётчик для остатка 4:
  //   remainderCount[4]++
  //   → remainderCount = [1, 0, 0, 0, 1]
  //
  // ---
  //
  // Шаг 2 (num = 5)
  //
  // - Вычисление префиксного остатка:
  //   (4 + 5) % 5 = 9 % 5 = 4.
  //   Нормализация даёт prefixRemainder = 4  
  //
  // - Сколько ранее было префиксов с остатком 4:
  //   remainderCount[4] = 1, значит существует 1
  //   подмассив, сумма которого делится на 5
  //   (между концом того префикса и текущей
  //   позицией).  
  //
  // - Обновление результата:
  //   result = 0 + 1 = 1
  //
  // - Увеличиваем счётчик для остатка 4:
  //   remainderCount[4]++
  //   → remainderCount = [1, 0, 0, 0, 2]
  //
  // ---
  //
  // Шаг 3 (num = 0)
  //
  // - Вычисление префиксного остатка:
  //   (4 + 0) % 5 = 4.
  //   Нормализация даёт prefixRemainder = 4
  //
  // - Сколько ранее было префиксов с остатком 4:
  //   remainderCount[4] = 2, значит добавляем 2
  //   новых подмассива.  
  //
  // - Обновление результата:
  //   result = 1 + 2 = 3
  //
  // - Увеличиваем счётчик для остатка 4:
  //   remainderCount[4]++
  //   → remainderCount = [1, 0, 0, 0, 3]
  //
  // ---
  //
  // Шаг 4 (num = -2)
  //
  // - Вычисление префиксного остатка:
  //   (4 + (-2)) % 5 = 2 % 5 = 2.
  //   Нормализация даёт prefixRemainder = 2
  //   (нормализация важна при отрицательных числах).  
  //
  // - Сколько ранее было префиксов с остатком 2:
  //   remainderCount[2] = 0, значит новых
  //   подмассивов не добавляется.  
  //
  // - Обновление результата: 
  //   result = 3 + 0 = 3
  //
  // - Увеличиваем счётчик для остатка 2:
  //   remainderCount[2]++
  //   → remainderCount = [1, 0, 1, 0, 3]
  //
  // ---
  //
  // Шаг 5 (num = -3)
  //
  // - Вычисление префиксного остатка:
  //   ((2 + (-3)) % 5 = (-1) % 5.
  //   В JavaScript -1 % 5 = -1, поэтому
  //   нормализация (-1 + 5) % 5 = 4
  //   даёт prefixRemainder = 4
  //
  // - Сколько ранее было префиксов с остатком 4:
  //   remainderCount[4] = 3, значит добавляем 3
  //   новых подмассива.  
  //
  // - Обновление результата:
  //   result = 3 + 3 = 6
  //
  // - Увеличиваем счётчик для остатка 4:
  //   remainderCount[4]++
  //   → remainderCount = [1, 0, 1, 0, 4]
  //
  // ---
  //
  // Шаг 6 (num = 1)
  //
  // - Вычисление префиксного остатка:
  //   (4 + 1) % 5 = 5 % 5 = 0.
  //   Нормализация даёт prefixRemainder = 0
  //
  // - Сколько ранее было префиксов с остатком 0:
  //   remainderCount[0] = 1, это учитывает 
  //   пустой префикс (или префиксы, сумма
  //   которых уже делится на k).
  //   Значит добавляем 1 новый подмассив.  
  //
  // - Обновление результата:
  //   result = 6 + 1 = 7
  //
  // - Увеличиваем счётчик для остатка 0:
  //   remainderCount[0]++
  //   → remainderCount = [2, 0, 1, 0, 4]
  //
  // ---
  //
  // Итог:
  //
  // После обработки всех элементов result = 7,
  // то есть функция вернёт 7 — количество
  // непрерывных подмассивов массива nums,
  // сумма которых делится на 5.  
  //
  // Если хотите, могу перечислить сами
  // подмассивы, которые дают эти 7 случаев, и
  // показать, как они соответствуют найденным
  // совпадениям остатков.

  // Возвращаем накопленное количество
  // подмассивов, сумма которых делится на k
  // без остатка.
  //
  // Результат соответствует сумме по всем
  // позициям количества предыдущих префиксов
  // с тем же остатком.
  return result;
}
