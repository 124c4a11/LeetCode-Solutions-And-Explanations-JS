/**
 * @param {string} keyboard
 * @param {string} word
 * @return {number}
 * 
 * calculateTime вычисляет суммарное «время» или «расстояние»
 * перемещений курсора по однорядной клавиатуре при наборе
 * заданного слова
 * 
 * Изначально ваш палец находится в позиции 0. Чтобы ввести
 * символ, необходимо переместить палец в позицию нужного
 * символа. Время, необходимое для перемещения пальца от
 * позиции i до позиции j, составляет |i - j|.
 * 
 * Параметры
 * - keyboard — строка длиной до 26 символов, задающая
 *   порядок букв на «линейной» клавиатуре. Ожидается, что
 *   символы — строчные латинские буквы a – z.  
 * 
 * - word — строка, которую нужно набрать. Также ожидается,
 *   что содержит только строчные латинские буквы.  
 * 
 * 
 * Пример для:
 *   keyboard = "abcdefghijklmnopqrstuvwxyz"
 *   word = "cba"
 * Результат:
 *   4
 * 
 * 
 * Пример для:
 *   keyboard = "pqrstuvwxyzabcdefghijklmno"
 *   word = "neetcode"
 * Результат:
 *   77
 */
function calculateTime(keyboard, word) {

  // Создаём массив фиксированной длины 26 типа Int32Array
  // для быстрого сопоставления буквы (a–z) с её индексом
  // в keyboard.
  //
  // Индекс 0 соответствует 'a',
  // индекс 25 — 'z'.
  //
  // Использование Int32Array экономит память и
  // обеспечивает быстрый доступ по индексу.
  //
  // Все значения по умолчанию равны 0.
  const charToNdx = new Int32Array(26);

  // Цикл по всем символам строки keyboard для заполнения
  // таблицы соответствий: буква → позиция на клавиатуре.
  for (let i = 0; i < keyboard.length; i++) {

    // Для символа keyboard[i] берём код символа через 
    // charCodeAt(0) и вычитаем 97 (код 'a'), чтобы
    // получить 0‑based индекс буквы в диапазоне 0..25
    // (Индекс 0 соответствует 'a', индекс 25 — 'z').
    //
    // Затем в массив charToNdx по этому индексу
    // записываем позицию i — таким образом строится
    // обратная карта: буква → её позиция на "линейной"
    // клавиатуре.
    charToNdx[keyboard[i].charCodeAt(0) - 97] = i;
  }

  // Инициализируем аккумулятор result, который будет
  // хранить суммарное "время" или суммарное расстояние
  // перемещений.
  let result = 0;

  // prevNdx хранит индекс предыдущей позиции курсора на
  // "клавиатуре". Инициализируется нулём, что означает,
  // что курсор стартует в позиции 0 (левый край) по
  // условию реализации.
  let prevNdx = 0;

  // Итерация по каждому символу в слове word.
  for (const char of word) {

    // Для текущего символа char вычисляем его индекс
    // в алфавите (charCodeAt(0) - 97) и затем получаем
    // позицию на клавиатуре из заранее построенного
    // массива charToNdx.
    const charNdx = charToNdx[char.charCodeAt(0) - 97];

    // К аккумулятору добавляем абсолютную разницу
    // между текущей позицией charNdx и предыдущей
    // prevNdx.
    //
    // Это моделирует расстояние (или время)
    // перемещения курсора от предыдущего символа к
    // текущему.
    //
    // Math.abs гарантирует положительное расстояние
    // независимо от направления движения.
    result += Math.abs(charNdx - prevNdx);

    // Обновляем prevNdx, чтобы в следующей итерации
    // учитывать перемещение от текущей позиции.
    prevNdx = charNdx;
  }

  // Возвращаем накопленное значение result — суммарное
  // расстояние/время для набора всего слова.
  //
  // Если word пустая строка, вернётся 0.
  return result;
}
