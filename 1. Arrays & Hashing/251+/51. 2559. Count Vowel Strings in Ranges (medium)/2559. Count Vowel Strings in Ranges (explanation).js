/**
 * @param {string[]} words
 * @param {number[][]} queries
 * @return {number[]}
 * 
 * vowelStrings принимает два параметра: массив строк
 * words и двумерный массив запросов queries, где
 * каждый запрос — пара индексов [l, r] подмассива в
 * words включительно. Функция считает для каждого
 * запроса количество слов в заданном подмассиве,
 * которые начинаются и заканчиваются гласной буквой.
 * 
 * Возвращаемое значение
 * - Массив чисел, где каждый элемент — количество
 *   слов, начинающихся и заканчивающихся гласной,
 *   на соответствующем отрезке [l, r] из queries
 * 
 * 
 * Пример для:
 *   words = ["aba","bcb","ece","aa","e"]
 *   queries = [[0,2],[1,4],[1,1]]
 * Результат:
 *   [2,3,0]
 * Пояснение:
 *   Строки, начинающиеся и заканчивающиеся на
 *   гласную: "aba", "ece", "aa" и "e".
 *  
 *   Ответ на запрос [0,2] равен 2
 *   (строки "aba" и "ece").
 * 
 *   Ответ на запрос [1,4] равен 3
 *   (строки "ece", "aa", "e").
 * 
 *   Ответ на запрос [1,1] равен 0.
 * 
 *   Возвращаем [2,3,0].
 */
function vowelStrings(words, queries) {

  // Получаем количество слов в массиве words и
  // сохраняем в константу n.
  // 
  // Используется для размеров префиксного массива и
  // итераций
  const n = words.length;

  // Создаём Set из символов гласных латинского
  // алфавита для O(1)-проверки принадлежности
  // символа к гласным.
  const vowelSet = new Set(['a', 'e', 'i', 'o', 'u']);

  // Инициализируем массив префиксных сумм длиной n+1
  // с типом Int32Array.
  //
  // Int32Array экономит память и быстрее при числовых
  // операциях по сравнению с обычным массивом
  //
  // ---
  //
  // prefixCn — это префиксный массив длиной n + 1,
  // где prefixCnt[k] хранит количество подходящих
  // слов среди первых k слов массива words. Нужен
  // дополнительный элемент в начале
  // (prefixCnt[0] = 0), чтобы быстро получать
  // количество на любом отрезке [l, r] как 
  // prefixCnt[r + 1] - prefixCnt[l]
  // 
  // ---
  // 
  // Почему длина n + 1
  //
  // - Префиксная техника обычно добавляет фиктивный
  //   нулевой элемент в начало, чтобы упростить
  //   формулы для диапазонов.  
  //
  // - Если words имеет n элементов, то префиксный
  //   массив сдвинут на 1: индекс k в prefixCnt
  //   соответствует первым k словам words (то есть k
  //   может быть от 0 до n).  
  //
  // - Поэтому нужен массив длины n + 1: индексы 0..n
  //   включительно. prefixCnt[0] — пустая префиксная
  //   сумма (0 подходящих слов), prefixCnt[n] — итог
  //   по всем словам.
  //
  // ---
  // 
  // Что означает индекс в prefixCnt
  //
  // Индекс k означает: "рассматриваем первые k слов
  // массива words".  
  // - prefixCnt[0] — среди первых 0 слов подходящих
  //   нет (0).  
  //
  // - prefixCnt[1] — количество подходящих слов
  //   среди words[0] (первых 1 слова).  
  //
  // - prefixCnt[i] — количество подходящих слов
  //   среди words[0]..words[i-1]
  //
  // - prefixCnt[n] — количество подходящих слов
  //   среди всех words[0]..words[n-1]
  // 
  // ---
  //
  // Что означает значение в prefixCnt
  //
  // - Значение prefixCnt[k] — это целое число,
  //   равное числу слов с нужным свойством (в данном
  //   коде: начинаются и заканчиваются гласной)
  //   среди первых k слов.
  //
  // - Массив строится инвариантом: при обработке
  //   слова words[i] мы копируем prefixCnt[i] в
  //   prefixCnt[i+1] и увеличиваем на 1, если
  //   words[i] удовлетворяет условию. Таким образом
  //   prefixCnt[i+1]
  //   = prefixCnt[i] + (isVowelWord ? 1 : 0)
  // 
  // ---
  //
  // Почему удобно брать r + 1 и l
  //
  // - Для диапазона [l, r] (включительно)
  //   количество подходящих слов равно сумме
  //   подходящих для первых r+1 слов минус сумма
  //   для первых l слов:  
  //   answer = prefixCnt[r + 1] - prefixCnt[l]
  //
  // - Благодаря сдвигу на 1 нет необходимости
  //   отдельно обрабатывать случай l = 0
  //   — формула работает корректно
  const prefixCnt = new Int32Array(n + 1);

  // Проходим по всем индексам от 0 до n-1, чтобы
  // заполнить префиксный массив количеством слов,
  // начинающихся и заканчивающихся на гласную до
  // текущей позиции
  for (let i = 0; i < n; i++) {

    // Копируем накопленное значение из
    // предыдущей позиции префиксного массива в
    // текущую позицию i+1, чтобы затем при
    // необходимости увеличить его на 1, если
    // текущее слово удовлетворяет условию
    //
    // Используем сдвиг i+1, так как в начале
    // массива prefixCnt располагается 0 для
    // удобства вычислений
    prefixCnt[i + 1] = prefixCnt[i];

    // Берём текущее слово по индексу i и
    // сохраняем в локальную константу word
    // для удобства и читаемости.
    const word = words[i];

    // Проверяем два условия одновременно:
    // первый символ слова — гласная, и
    // последний символ слова — гласная.
    //
    // Если оба условия истинны, увеличиваем
    // префиксную сумму для позиции i+1 на единицу,
    // тем самым отмечая, что слово на позиции i
    // удовлетворяет условию.
    if (
      vowelSet.has(word[0])
      && vowelSet.has(word.at(-1))
    ) prefixCnt[i + 1]++;

    // Пример выполнения цикла для:
    // - words = ["aba","bcb","ece","aa","e"],
    // - queries = [[0,2],[1,4],[1,1]]
    // 
    // ---
    // 
    // Исходные данные  
    //
    // - words = ["aba","bcb","ece","aa","e"]
    //
    // - n = 5
    //
    // - vowelSet = {'a','e','i','o','u'}
    //
    // - prefixCnt инициализируется как Int32Array
    //   длины n + 1, то есть 6 элементов: 
    //   prefixCnt = [0, 0, 0, 0, 0, 0]
    // 
    // ---
    // 
    // Итерация i = 0  
    //
    // - Действие:
    //   prefixCnt[1] = prefixCnt[0] → копируем 0.  
    //
    // - Текущее слово:
    //   word = "aba".  
    //
    // - Проверка:
    //   первая буква word[0] = 'a' — в vowelSet;
    //   последняя word.at(-1) = 'a' — тоже в
    //   vowelSet.
    //   → Условие истинно.  
    //
    // - Увеличение:
    //   выполняется prefixCnt[1]++,
    //   теперь prefixCnt[1] = 1.  
    //
    // - Состояние prefixCnt после итерации:
    //   [0, 1, 0, 0, 0, 0]  
    //
    // - Комментарий:
    //   среди первых 1 слова есть 1 подходящее слово
    //   ("aba").
    // 
    // ---
    // 
    // Итерация i = 1
    //
    // - Действие:
    //   prefixCnt[2] = prefixCnt[1] → копируем 1.  
    //
    // - Текущее слово:
    //   word = "bcb"  
    //
    // - Проверка:
    //   word[0] = 'b' — не в vowelSet, поэтому вторую
    //   проверку можно не выполнять → условие ложно.  
    //
    // - Увеличение: не выполняется.  
    //
    // - Состояние prefixCnt после итерации:
    //   [0, 1, 1, 0, 0, 0]
    //
    // - Комментарий:
    //   среди первых 2 слов по-прежнему 1 подходящее
    //   слово ("aba").
    // 
    // ---
    // 
    // Итерация i = 2
    //
    // - Действие:
    //   prefixCnt[3] = prefixCnt[2] → копируем 1.  
    //
    // - Текущее слово:
    //   word = "ece"
    //
    // - Проверка: 
    //   word[0] = 'e' — в vowelSet;
    //   word.at(-1) = 'e' — в vowelSet
    //   → условие истинно.  
    //
    // - Увеличение:
    //   выполняется prefixCnt[3]++,
    //   теперь prefixCnt[3] = 2.  
    //
    // - Состояние prefixCnt после итерации:
    //   [0, 1, 1, 2, 0, 0]
    //
    // - Комментарий:
    //   среди первых 3 слов два подходящих:
    //   aba" и "ece"
    // 
    // ---
    // 
    // Итерация i = 3
    //
    // - Действие:
    //   prefixCnt[4] = prefixCnt[3] → копируем 2.  
    //
    // - Текущее слово:
    //   word = "aa"  
    //
    // - Проверка:
    //   word[0] = 'a' и  word.at(-1) = 'a'
    //   — обе гласные → условие истинно.  
    //
    // - Увеличение:
    //   выполняется prefixCnt[4]++,
    //   теперь prefixCnt[4] = 3
    //
    // - Состояние prefixCnt после итерации:
    //   [0, 1, 1, 2, 3, 0]  
    //
    // - Комментарий: среди первых 4 слов три
    //   подходящих: "aba", "ece", "aa".
    // 
    // ---
    // 
    // Итерация i = 4
    //
    // - Действие:
    //   prefixCnt[5] = prefixCnt[4] → копируем 3.  
    //
    // - Текущее слово:
    //   word = "e"  
    //
    // - Проверка:
    //   word[0] = 'e' и word.at(-1) = 'e'
    //   (односимвольное слово) — обе проверки 
    //   истинны → условие истинно.
    //
    // - Увеличение:
    //   выполняется prefixCnt[5]++,
    //   теперь prefixCnt[5] = 4.  
    //
    // - Состояние prefixCnt после итерации:
    //   [0, 1, 1, 2, 3, 4] 
    //
    // - Комментарий:
    //   среди всех 5 слов четыре подходящих:
    //   "aba", "ece", "aa", "e".
    // 
    // ---
    // 
    // Итог после цикла  
    //
    // - Финальный prefixCnt = [0, 1, 1, 2, 3, 4].  
    //
    // - Интерпретация:
    //   prefixCnt[k] — количество подходящих слов
    //   среди первых k слов words. 
    //   
    //   Например, prefixCnt[3] = 2 означает, что в
    //   words[0..2] два подходящих слова.
    // 
    // ---
    // 
    // Как это используется для запросов  
    //
    // Для запроса [l, r] ответ вычисляется как
    // prefixCnt[r + 1] - prefixCnt[l].  
    //
    // На наших примерах:  
    // [0,2] → prefixCnt[3] - prefixCnt[0] = 2 - 0 = 2  
    // [1,4] → prefixCnt[5] - prefixCnt[1] = 4 - 1 = 3  
    // [1,1] → prefixCnt[2] - prefixCnt[1] = 1 - 1 = 0
  }

  // Создаём пустой массив result, в который будем
  // добавлять ответы на каждый запрос из queries.
  const result = [];

  // Проходим по каждому запросу в массиве queries
  // 
  // Каждый запрос ожидается в виде пары [l, r].
  //
  // Используем forEach для ускарения работы кода
  // при деструктуризации значения массива queries
  queries.forEach(([l, r]) => {

    // Для запроса [l, r] вычисляем количество
    // подходящих слов в диапазоне [l, r]
    // включительно:
    //
    // Разность префиксных сумм
    // prefixCnt[r+1] - prefixCnt[l] даёт количество
    // таких слов в [l, r].
    result.push(prefixCnt[r + 1] - prefixCnt[l]);

    // Пример выполнения цикла для:
    // - words = ["aba","bcb","ece","aa","e"],
    // - queries = [[0,2],[1,4],[1,1]]
    // 
    // ---
    //
    //Входные данные и начальное состояние
    //
    // - prefixCnt = [0, 1, 1, 2, 3, 4]  
    // - result = [] 
    // 
    // ---
    // 
    // Обработка запроса 1 — [0, 2]
    //
    // - Разбор запроса: l = 0, r = 2
    //
    // - Берём значения из prefixCnt:
    //   prefixCnt[r + 1] = prefixCnt[3] = 2
    //   prefixCnt[l] = prefixCnt[0] = 0
    //
    // - Вычисление:
    //   prefixCnt[r + 1] - prefixCnt[l]
    //   = 2 - 0 = 2  
    //
    // - Действие: выполняется result.push(2)
    //
    // - Состояние после операции:
    //   result = [2]  
    //
    // - Комментарий:
    //   на отрезке words[0..2] два слова начинаются
    //   и заканчиваются гласной ("aba", "ece").
    // 
    // ---
    // 
    // Обработка запроса 2 — [1, 4]
    //
    // - Разбор запроса: l = 1, r = 4.  
    //
    // - Берём значения из prefixCnt:
    //   prefixCnt[r + 1] = prefixCnt[5] = 4
    //   prefixCnt[l] = prefixCnt[1] = 1
    //
    // - Вычисление:
    //   prefixCnt[r + 1] - prefixCnt[l]
    //   = 4 - 1 = 3
    //
    // - Действие: выполняется result.push(3)  
    //
    // - Состояние после операции:
    //   result = [2, 3]
    //
    // - Комментарий:
    //   На отрезке words[1..4] три подходящих слова
    //   ("ece", "aa", "e").
    // 
    // ---
    // 
    // Обработка запроса 3 — [1, 1]
    //
    // - Разбор запроса: l = 1, r = 1.  
    //
    // - Берём значения из prefixCnt:
    //   prefixCnt[r + 1] = prefixCnt[2] = 1
    //   prefixCnt[l] = prefixCnt[1] = 1
    //
    // - Вычисление:
    //   prefixCnt[r + 1] - prefixCnt[l]
    //   = 1 - 1 = 0
    //
    // - Действие: выполняется result.push(0)
    //
    // - Состояние после операции:
    //   result = [2, 3, 0]
    //
    // - Комментарий:
    //   на отрезке words[1..1] нет слов,
    //   начинающихся и заканчивающихся гласной
    //   (слово "bcb" не подходит).
    // 
    // ---
    // 
    // Итог
    //
    // - Финальное значение result после
    //   выполнения всех итераций:
    //   result = [2, 3, 0]  
    //
    // - Как это работает в общем:
    //   для каждого запроса [l, r] берётся
    //   разность префиксных сумм 
    //   prefixCnt[r + 1] - prefixCnt[l],
    //   результат добавляется в result, что даёт
    //   количество подходящих слов на отрезке
    //   [l, r] включительно.
  });

  // Возврат массива с результатами для всех
  // запросов в том же порядке, в котором они были
  // заданы.
  return result;
}
