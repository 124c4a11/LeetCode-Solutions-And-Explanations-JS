/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @return {number[]}
 * 
 * relativeSortArray сортирует массив arr1 так, чтобы
 * сначала шли элементы в порядке, заданном массивом
 * arr2, а все остальные элементы arr1, которых нет в
 * arr2, шли в конце в возрастающем порядке.
 * 
 * Параметры:
 * - arr1 — входной массив целых чисел, который нужно
 *   отсортировать относительно arr2
 *
 * - arr2 — массив целых чисел без дубликатов,
 *   задающий приоритетный порядок. Гарантируется,
 *   что каждое значение из arr2 встречается в arr1
 *   (в классической формулировке задачи).
 * 
 * Временная и пространственная сложность
 * - Время: O(n + m + M), где
 *     n = длина arr1,
 *     m = длина arr2, 
 *     M = максимальное значение в arr1
 *     (из‑за прохода по массиву частот) — типичная
 *     оценка для counting sort решения.  
 * 
 * - Память: дополнительная память O(M) для массива
 *   частот плюс O(n) для результирующего массива.
 * 
 * Пример для:
 *   arr1 = [2,3,1,3,2,4,6,7,9,2,19]
 *   arr2 = [2,1,4,3,9,6]
 * Результат:
 *   [2,2,2,1,4,3,3,9,6,7,19]
 */
function relativeSortArray(arr1, arr2) {

  // Вычисляем максимальное значение в массиве arr1
  //
  // Это нужно, чтобы определить минимально
  // необходимую длину массива частот num1Freq
  const max = Math.max(...arr1);

  // Создаём типизированный массив Int32Array
  // длиной max + 1 для хранения частоты каждого
  // числа от 0 до max включительно.
  // 
  // Использование max + 1 гарантирует, что
  // индекс max будет доступен.
  //
  // Int32Array экономит память и обеспечивает
  // быстрый доступ по индексу.
  const num1Freq = new Int32Array(max + 1);

  // Проходим по каждому элементу arr1 и
  // увеличиваем соответствующий счётчик в
  // массиве частот.
  //
  // Предполагается, что все значения в arr1
  // — неотрицательные целые числа и не превышают
  // max.
  //
  // Операция num1Freq[num]++ выполняется быстро
  // благодаря прямому индексированию
  // типизированного массива.
  for (const num of arr1) num1Freq[num]++;

  // Инициализируем пустой массив result, в
  // который будем поэтапно добавлять элементы в
  // нужном порядке.
  //
  // Итоговый массив будет содержать все
  // элементы arr1, но переупорядоченные
  // согласно arr2 и затем оставшиеся элементы
  // arr1, которые не содержатся в arr2,
  // упорядоченные по возрастанию.
  const result = [];

  // Проходим по каждому числу в arr2 
  //
  // Затем добавляем это число в результат в том
  // количестве, в котором оно встречается в arr1
  for (const num of arr2) {

    // Цикл while с постфиксным декрементом
    // num1Freq[num]-- > 0:
    // 1. Сравнение выполняется с текущим
    //    значением счётчика (до декремента).
    //
    // 2. Если счётчик > 0, в тело цикла заходим
    //    и добавляем число в результат.
    //
    // 3. После проверки счётчик уменьшается на 1.
    //
    // Это компактный приём для добавления числа
    // ровно столько раз, сколько оно встречалось
    // в массиве arr1.
    while (num1Freq[num]-- > 0) result.push(num);
  }

  // После обработки всех чисел из arr2 в num1Freq
  // останутся только те числа, которых не было в
  // arr2.
  //
  // Проходим по всем возможным значениям от 0 до
  // max (длина num1Freq равна max + 1).
  //
  // Порядок обхода по возрастанию индекса
  // гарантирует, что оставшиеся числа будут
  // добавлены в возрастающем порядке без
  // использования дополнительной сортировки.
  for (let num = 0; num < num1Freq.length; num++) {

    // Аналогично предыдущему циклу:
    // Пока для данного значения счётчик
    // положителен, добавляем это значение в
    // результат и уменьшаем счётчик.
    //
    // Это обеспечивает, что все оставшиеся
    // элементы arr1, не указанные в arr2, будут
    // добавлены в порядке возрастания.
    while (num1Freq[num]-- > 0) result.push(num);
  }

  // Возвращаем итоговый массив:
  // Сначала элементы в порядке, заданном arr2
  // (с сохранением кратности), затем все
  // остальные элементы arr1 в порядке возрастания.
  return result;
}
