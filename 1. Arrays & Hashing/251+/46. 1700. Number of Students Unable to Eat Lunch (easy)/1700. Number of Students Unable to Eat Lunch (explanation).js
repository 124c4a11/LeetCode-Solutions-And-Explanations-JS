/**
 * @param {number[]} students
 * @param {number[]} sandwiches
 * @return {number}
 * 
 * countStudentsмоделирует процесс выдачи сэндвичей
 * студентам с бинарными предпочтениями и возвращает
 * число студентов, которые в итоге не получат
 * сэндвичи.
 * 
 * Параметры:
 * - students — массив чисел, где каждый элемент
 *   равен 0 или 1. Значение обозначает предпочтение
 *   конкретного студента (например,
 *   0 — предпочитает тип 0, 1 — предпочитает тип 1).  
 * 
 * - sandwiches — массив чисел, где каждый элемент
 *   равен 0 или 1. Порядок элементов соответствует
 *   порядку сэндвичей в стопке (первый элемент
 *   выдаётся первым).
 * 
 * Возвращаемое значение
 * - Число (целое) студентов, которые не получили
 *   сэндвичи при заданных входных массивах.
 * 
 *
 * Пример для:
 *   students = [1,1,1,0,0,1]
 *   sandwiches = [1,0,0,0,1,1]
 * Результат:
 *   3
 */
function countStudents(students, sandwiches) {

  // Создаём типизированный массив Int32Array
  // длины 2 для хранения счётчиков предпочтений.
  //
  // Использование Int32Array даёт компактное
  // представление и гарантирует целочисленные
  // элементы.
  //
  // Индекс 0 будет соответствовать числу
  // студентов, предпочитающих тип бутерброда 0,
  // индекс 1 — числу студентов, предпочитающих
  // тип бутерброда 1.
  const preferenceCnt = new Int32Array(2);

  // Проходим по каждому элементу массива
  // students
  //
  // Для каждого значения s (ожидается 0 или 1)
  // увеличиваем соответствующий счётчик.
  for (const s of students) preferenceCnt[s]++;

  // Инициализируем переменную result общим
  // количеством студентов.
  //
  // Она будет уменьшаться по мере того, как
  // студенты получают бутерброды, и в конце
  // станет равна числу студентов, которые не
  // смогли получить подходящий бутерброд.
  let result = students.length;

  // Проходим по массиву sandwiches в порядке
  // выдачи (первый элемент — верх стека).
  //
  // Для каждого бутерброда проверяем, есть
  // ли ещё студенты, которые его предпочтут.
  for (const s of sandwiches) {

    // Проверка: если соответствующий счётчик
    // предпочтений равен нулю, значит нет ни
    // одного студента, который согласится
    // взять текущий тип бутерброда.
    //
    // В этом случае дальнейшая выдача
    // бессмысленна, потому что очередь
    // студентов циклична: если никто не
    // возьмёт текущий бутерброд, процесс
    // остановится и все оставшиеся
    // бутерброды останутся невыданными, так
    // как хоть кто-то должен взять текущий
    // бутерброд, чтбы была возможность 
    // выдать следующие (принцип стека)
    if (!preferenceCnt[s]) break;

    // Если есть хотя бы один студент,
    // предпочитающий текущий тип бутерброда
    // s, уменьшаем соответствующий счётчик
    // на единицу — один студент "потребил"
    // этот бутерброд.
    preferenceCnt[s]--;

    // Поскольку один студент накормлен,
    // уменьшаем общее число оставшихся
    // студентов.
    //
    // Это позволяет в конце вернуть
    // количество студентов, которые
    // остались без подходящего бутерброда.
    result--;
  }

  // Пример работы цикла для:
  //
  // students = [1,1,1,0,0,1], 
  // sandwiches = [1,0,0,0,1,1]
  //
  // ---
  //
  // Исходное состояние перед входом в цикл  
  //
  // preferenceCnt = [2, 4] (две единицы
  // предпочитают 0, четыре — 1)  
  //
  // result = 6
  // 
  // ---
  //
  // Шаг 1 — берем первый бутерброд s = 1
  //
  // Проверка:
  //   preferenceCnt[1] = 4,
  //   условие !preferenceCnt[s] ложно,
  //   цикл продолжается.  
  //
  // До изменения: 
  //   preferenceCnt = [2, 4],
  //   result = 6.  
  //
  // Действие: 
  //   preferenceCnt[1]-- → 3
  //   result-- → становится 5  
  //
  // После изменения: 
  //   preferenceCnt = [2, 3]
  //   result = 5.
  //
  // ---
  // 
  // Шаг 2 — берем второй бутерброд s = 0
  //
  // Проверка:
  //   preferenceCnt[0] = 2,
  //   условие ложно,
  //   цикл продолжается.
  //
  // До изменения:
  //   preferenceCnt = [2, 3],
  //   result = 5.
  //
  // Действие: 
  //   preferenceCnt[0]-- → 1
  //   result-- → 4.
  //
  // После изменения:
  //   preferenceCnt = [1, 3],
  //   result = 4.
  // 
  // ---
  //
  // Шаг 3 — берем третий бутерброд s = 0
  //
  // Проверка: 
  //   preferenceCnt[0] = 1,
  //   условие ложно,
  //   цикл продолжается.  
  //
  // До изменения:
  //   preferenceCnt = [1, 3],
  //   result = 4.  
  //
  // Действие:
  //   preferenceCnt[0]-- → 0;
  //   result-- → 3.  
  //
  // После изменения: 
  //   preferenceCnt = [0, 3],
  //   result = 3.
  //
  // ---
  // 
  // Шаг 4 — берем четвёртый бутерброд s = 0
  //
  // Проверка: 
  //   preferenceCnt[0] равно 0,
  //   условие !preferenceCnt[s] истинно,
  //   (нет желающих взять бутерброд типа 0),
  //   выполняется `break`.  
  //
  // Цикл прерывается до выполнения
  //   preferenceCnt[s]-- и result--  
  //
  // ---
  //
  // Состояние при выходе:
  //
  //   preferenceCnt = [0, 3],
  //   result = 3.
  // 
  // ---
  //
  // Итог:
  //
  // Цикл остановлен на четвёртом бутерброде.
  // Возвращаемое значение result равно 3.

  // Возвращаем итоговое число студентов,
  // которые не получили бутерброд по
  // своим предпочтениям.
  //
  // Это значение равно исходному числу
  // студентов минус число успешно
  // обслуженных студентов.
  return result;
}
