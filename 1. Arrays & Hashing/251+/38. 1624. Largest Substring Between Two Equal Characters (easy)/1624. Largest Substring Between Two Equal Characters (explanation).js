/**
 * @param {string} s
 * @return {number}
 * 
 * maxLengthBetweenEqualCharacters ищет в строке две одинаковые
 * буквы с максимальным числом символов между ними и возвращает
 * это число.
 * 
 * Принимает один параметр — строку s.
 * 
 * Возвращает целое число или -1, если пар одинаковых символов
 * нет.
 * 
 * 
 * Пример для:
 *   s = "aa"
 * Результат:
 *   0
 * Пояснение:
 *   Оптимальная подстрока здесь — пустая подстрока между
 *   двумя 'a'.
 * 
 * 
 * Пример для: 
 *   s = "abca"
 * Результат:
 *   2
 * Пояснение:
 *   Оптимальная подстрока здесь — "bc".
 * 
 * 
 * Пример для 3:
 *   s = "cbzxy"
 * Результат:
 *   -1
 * Пояснение:
 *   В строке нет символов, которые встречаются дважды.
 */
function maxLengthBetweenEqualCharacters(s) {

  // Создаём Map для сопоставления символа с индексом его
  // первого вхождения.
  //
  // Map выбран потому, что обеспечивает амортизированное O(1)
  // время доступа для операций has/get/set и позволяет хранить
  // ключи любого типа.
  const charToFirstNdx = new Map();

  // Инициализируем переменную result значением -1 — это
  // значение по умолчанию, которое будет возвращено, если не
  // найдётся ни одной пары одинаковых символов.
  //
  // Использование -1 соответствует условию задачи: если пар
  // нет, вернуть -1.
  //
  // В процессе обхода строки result будет обновляться на
  // максимальное число символов между двумя одинаковыми
  // символами.
  let result = -1;

  // Запускает цикл по индексам строки s от 0 до s.length - 1
  // включительно, чтобы обработать каждый символ по порядку.
  //
  // Итерация по индексам нужна, потому что при нахождении
  // повторного символа требуется знать его индекс для
  // вычисления расстояния.
  for (let i = 0; i < s.length; i++) {

    // Извлекает символ в позиции i
    const char = s[i];

    // Проверяем, встречался ли этот символ ранее (есть ли в
    // Map запись о его первом индексе).
    //
    // Метод has возвращает true, если ключ уже присутствует в
    // Map.
    if (!charToFirstNdx.has(char)) {

      // Если символ встречается впервые, сохраняем его
      // индекс как первый найденный.
      //
      // Мы сохраняем именно первый индекс, потому что для
      // максимального расстояния между одинаковыми символами
      // имеет смысл сравнивать последующие вхождения с самым
      // ранним вхождением.
      charToFirstNdx.set(char, i);
    } else {

      // Если символ уже встречался ранее, извлекаем индекс
      // его первого вхождения и вычисляем количество символов
      // между ними.
      //
      // Выражение i - charToFirstNdx.get(char) - 1 даёт число
      // символов строго между двумя одинаковыми символами.
      //
      // Затем обновляем result, выбирая максимум между
      // текущим result и только что вычисленным расстоянием.
      //
      // Math.max гарантирует, что в result останется наибольшее
      // найденное значение.
      //
      // Обозначения и смысл частей формулы
      // - i — индекс текущего символа в строке (правый конец
      //   пары).  
      //
      // - charToFirstNdx.get(char) — индекс первого (самого
      //   левого) вхождения того же символа, сохранённый
      //   ранее. Обозначим его как first.
      //
      // - - 1 — корректировка, чтобы не включать в результат
      //   сами символы на позициях first и i.
      result = Math.max(result, i - charToFirstNdx.get(char) - 1);
    }
  }

  // После прохода по всей строке возвращаем найденный максимум
  // или -1, если ни одной пары одинаковых символов не
  // обнаружено.
  return result;
}
