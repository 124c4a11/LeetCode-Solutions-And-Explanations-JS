/**
 * @param {number[]} nums
 * @return {boolean}
 * 
 * check проверяет, можно ли получить неубывающий
 * (неубывающий значит каждый
 * следующий элемент >= предыдущего) порядок
 * элементов массива с помощью циклического сдвига
 * (т.е. разрешено ровно ноль или одно «убывание»
 * при обходе по кругу).
 * 
 * Если при проходе по всем соседним парам (включая
 * пару последнего и первого элемента) встречается
 * более одного убывания (предыдущий > следующий),
 * функция возвращает false. В остальных случаях
 * — true.
 * 
 * Параметры:
 * - nums — массив чисел
 * 
 * Возвращает: 
 * - true, если массив уже неубывающий или может
 *   быть получен из неубывающего массива
 *   циклическим сдвигом
 * 
 * - false, если для достижения неубывающего
 *   порядка потребовалось бы более одного
 *   разрыва/убывания.
 * 
 * Пример для:
 *   nums = [3,4,5,1,2]
 * Резульат:
 *   true
 * Пояснение:
 *   [1,2,3,4,5] — исходный отсортированный
 *   массив. Вы можете повернуть массив на
 *   x = 2 позиции, чтобы начать с элемента
 *   со значением 3: [3,4,5,1,2].
 */
function check(nums) {

  // Определение константы n — длины
  // входного массива nums.
  // 
  // Используется для границ цикла и
  // операций по модулю
  const n = nums.length;

  // Инициализация счётчика decreaseCnt,
  // который будет считать количество мест,
  // где последовательность "убывает"
  // (т.е. где предыдущий элемент строго
  // больше следующего).
  // 
  // Начинаем с 0.
  let decreaseCnt = 0;

  // Цикл for перебирает индексы i от 1 до
  // n включительно.
  //
  // Внутри цикла сравнивается элемент
  // nums[i-1] с элементом nums[i % n],
  // что обеспечивает цикличность сравнения
  // (последний элемент сравнивается с
  // первым благодаря оператору %).
  //
  // Цикл начинается с индекса 1, так как
  // для проверки пары соседних элементов
  // мы на каждой итерации работаем с 
  // предыдущим элементом nums[i - 1]
  // и с текущим nums[i % n].
  for (let i = 1; i <= n; i++) {

    // Условие состоит из двух частей,
    // объединённых логическим И:
    // 1. nums[i - 1] > nums[i % n]
    //    — обнаружено "убывание" между
    //    двумя соседними элементами в
    //    циклическом смысле.
    //
    //    Выражение nums[i % n]
    //    использует оператор остатка
    //    по модулю, чтобы при
    //    достижении конца массива
    //    следующий индекс стал 0,
    //    обеспечивая тем самым
    //    циклическое сравнение
    //    последнего элемента с первым.
    //
    // 2. ++decreaseCnt > 1
    //    — предварительно увеличиваем
    //    счётчик убываний и проверяем,
    //    превысил ли он 1.
    //
    // Если оба условия истинны, значит
    // найдено более одного убывания
    // — массив нельзя сделать
    // неубывающим простым циклическим
    // сдвигом, возвращаем false
    if (
      nums[i - 1] > nums[i % n]
      && ++decreaseCnt > 1
    ) return false;
  }

  // Если цикл завершился, и число
  // убываний не превысило 1, 
  // возвращаем true — массив либо уже
  // неубывает, либо может быть
  // приведён к неубывающему путём
  // одного циклического сдвига.
  return true;
};