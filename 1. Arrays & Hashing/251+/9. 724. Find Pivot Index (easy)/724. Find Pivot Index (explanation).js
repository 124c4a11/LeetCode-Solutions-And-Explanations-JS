/**
 * @param {number[]} nums
 * @return {number}
 * 
 * pivotIndex ищет индекс элемента в массиве чисел,
 * для которого сумма всех элементов слева от этого
 * индекса равна сумме всех элементов справа от
 * него.
 * 
 * Если такой индекс найден, функция возвращает
 * этот индекс (первый, самый левый подходящий).
 * 
 * Если ни один индекс не удовлетворяет условию,
 * возвращает -1.
 * 
 * Параметры:
 * — nums, массив чисел
 * 
 * Пример:
 *   Для:
 *     nums = [1,7,3,6,5,6]  
 *   Результат:
 *     3
 *   Объяснение:
 *     Сумма слева
 *       = nums[0] + nums[1] + nums[2]
 *       = 1 + 7 + 3 = 11
 *     Сумма справа
 *       = nums[4] + nums[5]
 *       = 5 + 6 = 11
 */
function pivotIndex(nums) {

  // Вычисление суммарного значения всех
  // элементов массива nums.
  const total = nums.reduce((a, b) => a + b, 0);

  // Инициализация переменной leftSum для
  // накопления суммы элементов, расположенных
  // слева от текущей позиции.
  //
  // В начале перед проверкой первого индекса
  // слева нет элементов, поэтому leftSum
  // устанавливается в 0.
  let leftSum = 0;

  // Цикл for проходит по всем индексам массива
  // nums по порядку от 0 до nums.length - 1.
  for (let i = 0; i < nums.length; i++) {

    // Вычисление суммы элементов справа от
    // текущего индекса i.
    //
    // Пояснение:
    // общая сумма total содержит сумму всех
    // элементов. Чтобы получить сумму справа,
    // вычитаем сумму слева leftSum и текущий
    // элемент nums[i], потому что они не
    // входят в правую часть.
    const rightSum = total - leftSum - nums[i];

    // Проверка условия равенства сумм слева
    // и справа.
    //
    // Если leftSum равна rightSum, текущий
    // индекс i является искомым pivot index.
    //
    // В этом случае функция немедленно
    // возвращает i и завершает выполнение.
    if (leftSum === rightSum) return i;

    // Если условие не выполнено, добавляем
    // текущий элемент nums[i] к leftSum,
    // чтобы на следующей итерации leftSum
    // отражала сумму элементов слева от
    // нового индекса i + 1.
    leftSum += nums[i];
  }

  // Если после прохода по всему массиву ни
  // один индекс не удовлетворил условию,
  // возвращаем -1 как индикатор отсутствия
  // pivot index в массиве.
  return -1;
}
