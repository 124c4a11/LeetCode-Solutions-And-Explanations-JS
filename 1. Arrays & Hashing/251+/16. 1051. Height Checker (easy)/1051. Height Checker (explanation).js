/**
 * @param {number[]} heights
 * @return {number}
 * 
 * heightChecker подсчитывает, сколько элементов
 * в входном массиве стоят не на тех позициях по
 * сравнению с массивом, отсортированным по
 * возрастанию.
 * Проще: она возвращает количество индексов,
 * на которых значение текущего роста отличается
 * от значения на той же позиции в
 * отсортированном варианте массива.
 * 
 * Параметры:
 * - heights — массив целых чисел, каждый
 *   элемент которого представляет рост студента
 *   (обычно ожидаются значения в диапазоне
 *   от 1 до 100).  
 * 
 * Возвращает целое число — количество позиций,
 * где значения исходного массива отличается от
 * отсортированного
 * 
 * Пример для:
 *   heights:  [1,1,4,2,1,3]
 *   expected: [1,1,1,2,3,4]
 * Результат:
 *   3
 * Пояснение: 
 *   Индексы 2, 4 и 5 не совпадают.
 */
function heightChecker(heights) {

  // Создаём массив целотипный Int32Array
  // длиной 101: индексы 0..100 используются
  // как счётчики для каждого возможного роста
  // студента.
  //
  // Использование Int32Array экономит память
  // и гарантирует целочисленные значения
  // по умолчанию 0.
  const heightFreq = new Int32Array(101);

  // Итерация по каждому значению h из
  // входного массива heights. Для каждого
  // роста увеличиваем соответствующий счётчик
  // в heightFreq.
  //
  // После выполнения этой строки для
  // heights = [1,1,4,2,1,3] heightFreq будет
  // иметь:
  //
  // heightFreq[1] = 3,
  // heightFreq[2] = 1,
  // heightFreq[3] = 1,
  // heightFreq[4] = 1,
  // остальные = 0.
  for (let h of heights) heightFreq[h]++;

  // Объявляем пустой обычный массив expected
  // — в нём мы сформируем отсортированную по
  // возрастанию версию heights, но делаем это
  // вручную, используя подсчитанные частоты,
  // чтобы избежать вызова явной сортировки
  // O(n log n).
  const expected = [];

  // Внешний цикл перебирает все возможные
  // значения роста от 1 до 100 (предполагается,
  // что рост в этом диапазоне).
  //
  // Индекс h здесь представляет конкретный рост,
  // для которого мы будем добавлять
  // heightFreq[h] элементов в expected.
  for (let h = 1; h <= 100; h++) {

    // Вложенный цикл добавляет значение h в
    // массив expected ровно столько раз,
    // сколько записано в heightFreq[h].
    //
    // Это создаёт отсортированный по возрастанию
    // массив expected, так как мы идём по h в
    // порядке возрастания.
    //
    // Для элементов heightFreq, значения которых
    // равны 0, этот цикл не запустится, что
    // позволяет получить в expected только те
    // значения, которые присутствуют в heights.
    //
    // Для примера:
    // - h = 1: 
    //     heightFreq[1] = 3,
    //     добавляем 1 трижды
    //     → expected = [1,1,1]
    //
    // - h = 2:
    //     heightFreq[2] = 1,
    //     добавляем 2 один раз
    //     → expected = [1,1,1,2]
    //
    // - h = 3:
    //     heightFreq[3] = 1,
    //     добавляем 3 один раз
    //     → expected = [1,1,1,2,3]
    //
    // - h = 4:
    //     heightFreq[4] = 1,
    //     добавляем 4 один раз
    //     → expected = [1,1,1,2,3,4]
    for (let i = 0; i < heightFreq[h]; i++) {
      expected.push(h);
    }
  }

  // Инициализируем счётчик result нулём.
  // 
  // Он будет содержать количество позиций,
  // в которых значения исходного массива
  // heights отличаются от значений массива
  // expected
  let result = 0;

  // Проходим по индексам
  // от 0 до heights.length - 1 и сравниваем
  // каждый элемент исходного массива с
  // соответствующим элементом expected.
  for (let i = 0; i < heights.length; i++) {

    // Если на позиции i исходный рост не
    // равен ожидаемому (отсортированному)
    // росту, увеличиваем счётчик result.
    //
    // Это соответствует числу учеников,
    // которые стоят не на своих
    // "отсортированных" местах.
    //
    // Для примера
    // heights    = [1,1,4,2,1,3]
    // и expected = [1,1,1,2,3,4]:
    // - i = 0:
    //     heights[0] = 1
    //     expected[0] = 1
    //     → совпадает
    //     → result = 0
    //
    // - i = 1:
    //     heights[1] = 1
    //     expected[1] = 1
    //     → совпадает
    //     → result = 0
    //
    // - i = 2:
    //     heights[2] = 4
    //     expected[2] = 1
    //     → не совпадает
    //     → result = 1
    //
    // - i = 3:
    //     heights[3] = 2
    //     expected[3] = 2
    //     → совпадает
    //     → result = 1
    //
    // - i = 4:
    //     heights[4] = 1
    //     expected[4] = 3
    //     → не совпадает
    //     → result = 2
    //
    // - i = 5:
    //     heights[5] = 3
    //     expected[5] = 4
    //     → не совпадает
    //     → result = 3
    if (heights[i] !== expected[i]) result++;
  }

  // Возвращаем итоговое число result
  // — количество индексов, где элемент
  // в исходном массиве отличается от
  // элемента в массиве, упорядоченном
  // по возрастанию (expected).
  //
  // Для примера результат 3.
  return result;
};