/**
 * MovingAverage:
 * - MovingAverage(int size) — инициализирует объект с размером
 *   окна size.
 * 
 * - double next(int val) — возвращает скользящее среднее по
 *   последним size значениям потока.
*/
class MovingAverage {
  /**
   * @param {number} size
   */
  constructor(size) {

    // Сохраняем переданный размер окна в свойство
    // экземпляра для дальнейшего использования
    this.size = size;

    // Создаём фиксированный по длине кольцевой буфер целых
    // чисел для хранения последних значений окна
    //
    // Int32Array экономичнее по памяти и быстрее для числовых
    // операций, но хранит только 32‑битные целые числа.
    //
    // Кольцевой буфер используется потому, что он обеспечивает
    // фиксированную по памяти, быструю O(1) и предсказуемую
    // структуру для хранения последних N элементов потока, без
    // сдвигов данных и без перераспределения памяти.
    this.q = new Int32Array(this.size);

    // Индекс последнего записанного элемента
    this.lastNdx = 0;

    // Переменная для хранения суммы всех значений, находящихся
    // в текущем окне.
    // 
    // Используется для быстрого вычисления среднего
    this.windowSum = 0;

    // Счётчик всех полученных значений (включая те, что вышли
    // за пределы окна).
    // 
    // Нужен для корректного деления на фактический размер
    // окна до его заполнения.
    this.seenCnt = 0;
  }

  /**
   * @param {number} val
   * @return {number}
   * 
   * Метод next добавляет новое значение в структуру и возвращает
   * обновлённое скользящее среднее
   */
  next(val) {

    // Увеличиваем общий счётчик полученных значений.
    //
    // Это позволяет отличать ситуацию "ещё не заполнили окно"
    // от "окно заполнено"
    this.seenCnt++;

    // Вычисляем индекс ячейки кольцевого буфера, которая будет
    // перезаписана при добавлении нового значения — это
    // «следующая» позиция относительно текущего индекса
    // последнего записанного элемента с учётом циклического
    // перехода в начало массива.
    //
    // Оператор % обеспечивает корректный переход(wrap‑around)
    // при достижении конца буфера
    //
    // Что делает выражение по шагам:
    // - this.lastNdx — индекс последнего записанного элемента.
    //
    // - this.lastNdx + 1 — логически это следующая позиция в
    //   буфере (куда мы перейдём при вставке нового элемента).
    //
    // - % this.size — берёт остаток от деления на размер
    //   буфера, то есть если this.lastNdx + 1 равен this.size
    //   (мы дошли до конца массива), результат станет
    //   0 — переход в начало. Это и есть «кольцевое»
    //   поведение буфера. То есть использование % обеспечивает
    //   корректную циклическую работу индекса при достижении
    //   конца массива и гарантирует то, что индекс остаётся в
    //   диапазоне [0, size-1].
    //
    // Почему именно lastNdx + 1, а не lastNdx или lastNdx - 1
    // В этой реализации lastNdx указывает на последний
    // записанный элемент. При добавлении нового значения
    // нужно определить, какая ячейка будет вытеснена (старое
    // значение, которое вычитают из суммы) — это именно
    // следующая по циклу позиция. Поэтому сначала вычисляют
    // nextOverwriteNdx как следующую позицию, вычитают из суммы
    // значение из q[nextOverwriteNdx], а затем записывают новое
    // значение в эту позицию, обновляя lastNdx на ту же позицию.
    // Такой порядок гарантирует, что сумма окна корректно
    // обновляется за O(1).
    const nextOverwriteNdx = (this.lastNdx + 1) % this.size;

    // Обновляем сумму окна:
    // Вычитаем значение, которое выходит из окна
    // (q[nextOverwriteNdx]), и добавляем новое значение val.
    //
    // Это даёт амортизированное O(1) обновление суммы.
    //
    // Заметьте:
    // До заполнения буфера значения в q являются нулями,
    // поэтому вычитание корректно уменьшит сумму на 0.
    this.windowSum = this.windowSum - this.q[nextOverwriteNdx] + val;

    // Сдвигаем указатель lastNdx на следующую позицию по кольцу,
    // чтобы записать новое значение в правильное место. 
    //
    // Обновляем индекс последнего записанного элемента на только
    // что вычисленный индекс перезаписи.
    //
    // После этой строки lastNdx указывает на позицию, где бутет
    // хранится новое значение.
    this.lastNdx = nextOverwriteNdx;

    // Записываем новое значение в кольцевой буфер на позиции
    // lastNdx, тем самым заменяя старое значение (которое уже
    // было вычтено из windowSum на предыдущем шаге)
    this.q[this.lastNdx] = val;

    // Возвращаем среднее:
    //
    // Текущая сумма окна делится на фактическое количество
    // элементов в окне:
    // - Если элементов меньше, чем размер окна, делим на seenCnt
    //
    // - Если окно заполненно, делим на size
    //
    // До тех пор, пока не получено size значений, окно фактически
    // меньше, поэтому используем Math.min(size, seenCnt), что
    // обеспечивает корректное деление в обоих случаях.
    return this.windowSum / Math.min(this.size, this.seenCnt);
  }
}

/**
 * Your MovingAverage object will be instantiated and called as such:
 * var obj = new MovingAverage(size);
 * var param_1 = obj.next(val);
 */
