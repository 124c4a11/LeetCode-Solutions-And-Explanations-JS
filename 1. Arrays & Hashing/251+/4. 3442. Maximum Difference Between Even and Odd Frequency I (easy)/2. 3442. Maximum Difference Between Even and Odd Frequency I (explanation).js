/**
 * @param {string} s
 * @return {number}
 * 
 * maxDifference принимает на вход строку s
 * (ожидается последовательность строчных
 * латинских букв a–z) и возвращает
 * числовую разницу между наибольшей
 * встречающейся нечётной частотой символа
 * и наименьшей встречающейся чётной
 * частотой символа в этой строке.
 * 
 * Пример:
 *  Для:
 *   s = "aaaaabbc"
 *  Результат: 
 *   3
 *  Пояснение:
 *   - Символ 'a' имеет нечётную частоту 5,
 *     а 'b' имеет чётную частоту 2
 *   - Максимальная разница равна 5 − 2 = 3.
 */
function maxDifference(s) {

  // Создаётся массив фиксированного
  // размера 26 (Int32Array) — по одному
  // элементу для каждой буквы латинского
  // алфавита a..z. Этот массив
  // используется для подсчёта, сколько
  // раз каждая буква встречается
  // в строке s.
  const charFreq = new Int32Array(26);

  // Перебирает каждый символ строки s
  // по очереди
  for (const char of s) {

    // Получает числовой код текущего
    // символа в кодировке UTF-16
    // char.charCodeAt(0)
    //
    // Вычитает 97 чтобы сдвинуть
    // диапазон и получить его 
    // индекс в массиве:
    // 'a' → 0, 'b' → 1, ..., 'z' → 25
    // char.charCodeAt(0) - 97
    //
    // Использует полученный индекс
    // для доступа к соответствующей
    // ячейке charFreq и увеличивает
    // её на единицу
    //
    // При s = "aaaaabbc":
    //  - при первом 'a' индекс = 0,
    //    charFreq[0] становится 1;
    //  - после всех пяти 'a' charFreq[0] = 5;
    //  - для 'b' (индекс 1) после двух 'b'
    //    charFreq[1] = 2;
    //  - для 'c' (индекс 2) после одного 'c'
    //    charFreq[2] = 1.
    charFreq[char.charCodeAt(0) - 97]++;
  }

  // Инициализация переменной oddMax,
  // предназначенной для хранения
  // максимальной нечётной частоты
  // среди всех букв. Начинаем с 0,
  // потому что минимальная возможная
  // нечётная частота — 1.
  let oddMax = 0;

  // Инициализация переменной evenMin
  // для хранения минимальной чётной
  // частоты среди букв.
  //
  // Стартовое значение s.length
  // гарантирует, что любая реальная
  // чётная частота (<= длине строки)
  // сможет уменьшить даже это значение.
  // Для пустой строки evenMin останется
  // равным 0.
  let evenMin = s.length;

  // Проходим по всем 26 частотам
  // (некоторые могут быть 0,
  // если буква не встречалась)
  for (const freq of charFreq) {

    // Если частота равна 0 (буква
    // отсутствовала в s), пропускаем
    // обработку для этой буквы
    if (!freq) continue;

    // Проверяем, является ли частота
    // нечётной
    //
    // Операция (freq & 1) даёт 1 для
    // нечётных, 0 для чётных.
    //
    // freq & 1 — что делает и почему
    // так проверяют нечётность
    //
    // - Операция & — это побитовый AND:
    //   она выполняет логическое И для
    //   каждой пары битов двух операндов.
    //
    // - Конкретно выражение freq & 1
    //   оставляет только младший бит числа
    //   freq, потому что бинарное
    //   представление 1 — это ...0001;
    //   результат равен 1, если младший бит
    //   в freq равен 1, и 0 в противном
    //   случае.
    //
    // - Младший бит числа показывает его
    //   чётность: если младший бит = 1,
    //   число нечётное; если 0 — чётное.
    //   Поэтому freq & 1 — быстрый способ
    //   проверить нечётность.
    //
    // Как интерпретируется значение
    // в условии if
    //
    // В JS результат freq & 1
    // будет либо 1 (для нечётных freq),
    // либо 0 (для чётных). В условии
    // if (freq & 1) значение 1
    // рассматривается как true,
    // 0 — как false, то есть условие
    // срабатывает только для нечётных
    // частот.
    //
    // Эквивалентные записи
    //
    // Аналог по смыслу: freq % 2 !== 0
    // или freq % 2 === 1
    // (для неотрицательных целых).
    // freq & 1 обычно чуть быстрее
    // и компактнее, особенно в
    // низкоуровневом коде,
    // но в современном JS разница
    // по скорости заметна редко и чаще
    // это вопрос стиля.
    //
    // Поведение для нецелых и
    // отрицательных значений
    //
    // Побитовые операции в JavaScript
    // сначала приводят операнд
    // к 32‑битному целому (ToInt32).
    // Если freq нецелое, он будет
    // приведён к целому (отбрасывается
    // дробная часть). Если freq
    // отрицательное, младший бит всё
    // ещё показывает чётность
    // по двоичному дополнительному
    // коду, поэтому (-3) & 1 даст
    // 1 (нечётное), (-2) & 1
    // даст 0 (чётное).
    // В контексте счётчиков частот
    // (неотрицательные целые) это
    // поведение корректно и безопасно.
    //
    // Примеры
    //
    // 5 & 1 → 1 (нечётное)
    // 4 & 1 → 0 (чётное)
    // 0 & 1 → 0
    if (freq & 1) {

      // Если freq нечётное,
      // обновляем oddMax, выбирая
      // максимальное между текущим
      // oddMax и freq
      //
      // Для s = "aaaaabbc":
      // - charFreq[0] = 5 (нечётное)
      //   → oddMax = max(0, 5) = 5;
      // - charFreq[1] = 2 (чётное)
      //   → здесь не обновляем oddMax;
      // - charFreq[2] = 1 (нечётное)
      //   → oddMax = max(5, 1) = 5
      //     (остаётся 5).
      oddMax = Math.max(oddMax, freq);
    } else {

      // Если freq чётное, обновляем
      // evenMin, выбирая минимальное
      // между текущим evenMin и freq
      //
      // Для чётных частот обновляем
      // evenMin, если текущая частота
      // меньше уже найденного минимума.
      //
      // Для s = "aaaaabbc":
      // - charFreq[1] = 2 (чётное)
      //   → evenMin = min(8, 2) = 2
      //     (s.length = 8);
      // - остальные чётные частоты
      //   отсутствуют, поэтому evenMin
      //   остаётся 2.
      evenMin = Math.min(evenMin, freq);
    }
  }

  // Возвращаем разницу между наибольшей
  // найденной нечётной частотой и наименьшей
  // найденной чётной частотой.
  //
  // Для s = "aaaaabbc" это oddMax (5)
  // минус evenMin (2) = 3.
  //
  // Возможные граничные случаи:
  // - если не найдено ни одной нечётной частоты,
  //   oddMax останется 0;
  // - если не найдено ни одной чётной частоты,
  //   evenMin останется равной s.length, что
  //   может дать отрицательное значение.
  return oddMax - evenMin;
}
