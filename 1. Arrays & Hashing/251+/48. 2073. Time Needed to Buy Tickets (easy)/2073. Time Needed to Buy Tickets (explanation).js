/**
 * @param {number[]} tickets
 * @param {number} k
 * @return {number}
 * 
 * timeRequiredToBuy вычисляет и возвращает общее число
 * шагов (секунд), которое потребуется, чтобы человек на
 * позиции k в очереди купил все свои билеты при правилах,
 * где каждый человек покупает по одному билету за 1
 * секунду и затем, если нужно, уходит в конец очереди.
 *
 * Параметры:
 * - tickets — массив целых чисел, где tickets[i]
 *   означает, сколько билетов хочет купить человек с
 *   индексом i
 * 
 * - k — целочисленный индекс (0‑based) человека в этом
 *   массиве, для которого нужно посчитать время до
 *   полного завершения покупки.
 * 
 * 
 * Пример для:
 *   tickets = [2,3,2]
 *   k = 2
 * Результат:
 *   6
 */
function timeRequiredToBuy(tickets, k) {

  // Инициализация аккумулятора результата.
  //
  // В нем будет накапливаться суммарное количество
  // отдельных операций покупки (единиц времени),
  // необходимых до момента, когда человек на позиции k
  // купит все свои билеты.
  //
  // Начальное значение 0 означает, что пока никто не
  // купил билеты.
  let result = 0;

  // Запускаем цикл по всем индексам очереди от 0 до
  // tickets.length - 1.
  // 
  // Каждый индекс соответствует одному покупателю в
  // очереди.
  for (let i = 0; i < tickets.length; i++) {

    // Проверяем, находится ли текущий индекс i до или
    // на той же позиции, что и k.
    //
    // Это важно, потому что люди до и включая k могут
    // совершать покупку в том же "раунде", когда k
    // делает свою последнюю покупку.
    if (i <= k) {

      // Для покупателей с индексом <= k добавляем в
      // результат минимальное значение между
      // tickets[i] и tickets[k].
      //
      // tickets[i] — сколько билетов хочет купить
      // человек i.
      //
      // tickets[k] — сколько билетов хочет купить
      // целевой человек k.
      //
      // Обоснование:
      // Покупатель i сможет совершать покупки в
      // каждом раунде до тех пор, пока либо у него
      // не кончатся билеты, либо пока k не купит
      // все свои билеты.
      //
      // Таким образом, число раундов, в которых i
      // будет участвовать до завершения k,
      // равно min(tickets[i], tickets[k]).
      result += Math.min(tickets[i], tickets[k]);
    } else {

      // Для покупателей с индексом > k добавляем в
      // результат минимальное значение между
      // tickets[i] и tickets[k] - 1.
      //
      // Обоснование:
      // Покупатели после k не участвуют в последнем
      // раунде, когда k делает свою последнюю
      // покупку, потому что в этом раунде k уже
      // перед ним в очереди и завершает
      // обслуживание. Поэтому максимальное число
      // раундов, в которых они могут участвовать до
      // завершения k, равно tickets[k] - 1, но не
      // больше их собственного количества билетов.
      result += Math.min(tickets[i], tickets[k] - 1);
    }
  }

  // После прохода по всей очереди возвращаем
  // накопленное значение result — общее количество
  // отдельных покупок (временных единиц), которое
  // потребуется, чтобы покупатель на позиции k
  // полностью купил свои билеты.
  return result;
}
