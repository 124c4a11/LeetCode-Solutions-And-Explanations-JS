/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 * 
 * nextGreaterElement находит для каждого
 * элемента массива nums1 первый справа
 * стоящий в массиве nums2 элемент, который
 * больше его. Если такого элемента нет,
 * возвращает -1 для этой позиции.
 * 
 * Параметры:
 * - nums1 — массив чисел, для которых нужно
 *   найти следующие большие элементы.
 * - nums2 — массив чисел, внутри которого
 *   ищутся следующие большие элементы для
 *   значений из nums1.
 * 
 * Дополнительные важные факты:
 * - Ожидается, что элементы nums1 встречаются
 *   в nums2.
 * - Функция возвращает массив той же длины,
 *   что nums1, где каждая позиция содержит
 *   либо найденное большее число из nums2,
 *   либо -1.
 * 
 * Пример для:
 *   nums1 = [4, 1, 2]
 *   nums2 = [2, 1, 3, 4]
 * Результат:
 *   [-1, 3, 3]
 * Объяснение:
 * - Для 4 из nums1 следующего большего
 *   в nums2 слева направо не нашлось,
 *   поэтому -1.
 * - Для 1 первым следующим большим оказался 3.
 * - Для 2 первым следующим большим оказался 3.
 */
function nextGreaterElement(nums1, nums2) {

  // Создаём Map<num, index> для быстрого
  // получения индекса элемента nums1 по его
  // значению
  //
  // Это нужно, чтобы при нахождении
  // "следующего большего" по значению в nums2
  // мы могли напрямую записать результат
  // в соответствующую позицию result для
  // nums1
  const nums1ToNdx = new Map();
  for (let i = 0; i < nums1.length; i++) {

    // Помещаем в Map пару:
    // - ключ - значение элемента nums1,
    // - значение - индекс этого элемента
    //   в nums1
    nums1ToNdx.set(nums1[i], i)
  }

  // Создаём массив result той же длины,
  // что nums1.
  //
  // Предварительно заполняем все элементы -1,
  // это значение по умолчанию для случаев,
  // когда следующий больший элемент не найден
  const result = new Array(nums1.length).fill(-1);

  // Стек (в виде массива) будет хранить
  // значения из nums2, которые присутствуют
  // в nums1 и для которых ещё не найден
  // следующий больший элемент (в порядке
  // появления в nums2).
  const stack = [];

  // Проходим по каждому числу num в массиве
  // nums2 
  //
  // Идея: когда встречаем число большее,
  // чем верх стека, значит для значения из
  // стека найден его следующий больший
  // элемент
  for (const num of nums2) {

    // Пока стек не пуст и текущее число
    // num больше элемента на вершине
    // стека это означает: для вершины
    // стека найден следующий больший
    // элемент = num
    while (
      stack.length
      && num > stack.at(-1)
    ) {

      // Извлекаем верхний элемент стека
      // — это значение из nums1, для
      // которого найден следующий больший
      // элемент
      const stackNum = stack.pop();

      // Получаем индекс извлечённого
      // значения в массиве nums1 через Map
      const i = nums1ToNdx.get(stackNum);

      // Записываем найденный следующий
      // больший элемент в соответствующую
      // позицию результата
      result[i] = num;
    }

    // Если текущий элемент num присутствует
    // в nums1 (проверка по Map),
    // то добавляем его в стек как кандидата,
    // для которого будем искать следующий
    // больший элемент
    if (nums1ToNdx.has(num)) {
      stack.push(num);
    }

    // Пример работы цикла:
    //
    // Исходные значения:
    // - nums1 = [4, 1, 2]
    // - nums2 = [2, 1, 3, 4]
    // - nums1ToNdx = {4 → 0, 1 → 1, 2 → 2}
    // - Начальное состояние:
    //   stack = [],
    //   result = [-1, -1, -1]
    //
    // Шаг 1: num = 2
    // - Перед while: stack = [],
    //   условие while не выполняется.
    // - После while: stack = []
    // - Проверка nums1ToNdx.has(2) — true,
    //   выполняется push(2).
    // - После push:
    //   stack = [2],
    //   result = [-1, -1, -1]
    //
    // Шаг 2: num = 1
    // - Перед while:
    //   stack = [2], верх = 2;
    //   условие while: 1 > 2 — ложь,
    //   while не выполняется.
    // - После while: stack остаётся [2].
    // - nums1ToNdx.has(1) — true,
    //   выполняется push(1).
    // - После push:
    //   stack = [2, 1],
    //   result = [-1, -1, -1]
    //
    // Шаг 3: num = 3
    // - Перед while:
    //   stack = [2, 1], верх = 1.
    // - while итерация 1: 3 > 1 — истина
    //   - stack.pop() возвращает 1
    //     (stackNum = 1).
    //   - i = nums1ToNdx.get(1) = 1.
    //   - result[1] = 3.
    //   - После pop:
    //     stack = [2],
    //     result = [-1, 3, -1].
    // - while итерация 2: теперь верх = 2,
    //   3 > 2 — истина
    //   - stack.pop() возвращает 2
    //     (stackNum = 2).
    //   - i = nums1ToNdx.get(2) = 2.
    //   - result[2] = 3.
    //   - После pop:
    //     stack = [],
    //     result = [-1, 3, 3].
    // - while завершился (stack пуст).
    // - nums1ToNdx.has(3) — false, не пушим.
    // - Итог после шага:
    //   stack = [],
    //   result = [-1, 3, 3]
    //
    // Шаг 4: num = 4
    // - Перед while: stack = [],
    //   while не выполняется.
    // - После while: stack = [].
    // - nums1ToNdx.has(4) — true,
    //   выполняется push(4).
    // - После push:
    //   stack = [4],
    //   result = [-1, 3, 3]
    //
    // Конечное состояние после прохода
    // по nums2:
    // stack = [4],
    // result = [-1, 3, 3].
    // Остаток в стеке (4) не получил
    // следующего большего элемента в nums2,
    // поэтому result[0] остаётся -1.
  }

  // Возвращаем массив result, содержащий для
  // каждого элемента nums1 его следующий
  // больший элемент из nums2 или -1
  return result;
}
