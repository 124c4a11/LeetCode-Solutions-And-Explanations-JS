/**
 * @param {number[]} nums
 * @return {number}
 * 
 * Boyer-Moore Voting Algorithm
 * 
 * Функция majorityElement принимает на вход
 * массив целых чисел nums и ищет в нём
 * элемент, который встречается более
 * половины длинны массива 
 * ( > floor(nums.length/2) ), то есть 
 * более общего количества символов
 * в массиве.
 * Такой элемент гарантированно существует
 * в массиве.
 * 
 * Например:
 * для nums = [3, 3, 4]
 * функция должна вернуть 3, посколько 3
 * встречается два раза из трех
 * (более половины длинные массива,
 * или более общего количества символов
 * в массиве).
 */
function majorityElement(nums) {

  // Дополнительная информация
  //
  // Алгоритм, реализованный в этой функции,
  // называется алгоритмом Бойера–Мура
  // (Boyer–Moore Voting Algorithm). Его
  // ключевая идея — метод «голосования» за
  // кандидата на мажоритарный элемент:
  //
  // - При каждом новом числе «голосуем»
  //   за него, сравнивая с текущим кандидатом.  
  // - Если это тот же кандидат, усиливаем
  //   его позицию (count++).  
  // - Если нет — ослабляем (count--).  
  // - Как только баланс опускается до нуля,
  //   предыдущий кандидат «снимается»,
  //   и следующий элемент становится
  //   новым кандидатом.
  //
  // Временная и пространственная сложность
  //
  // - Временная: O(n), где n — длина массива.  
  // - Пространственная: O(1),
  //   используется только два дополнительных
  //   счётчика (result, count).


  // result будет хранить текущего кандидата
  // на мажоритарный элемент.
  //
  // Изначально мы не знаем верного кандидата,
  // поэтому задаём любую заглушку (0).
  //
  // Для примера: сразу после входа в цикл,
  // когда count = 0, result заменится
  // на первый элемент массива.
  //
  // Для nums = [3,3,4] после первой итерации
  // result = 3.
  //
  // Но это значение
  // заменится при последующих итерациях,
  // если count станет равен 0.
  let result = 0;

  // count — баланс «голосов» в пользу
  // текущего кандидата.
  // При положительном count кандидат остаётся,
  // при нуле выбираем нового.
  //
  // Пример для [3,3,4]: 
  // count идёт 0 → 1 → 2 → 1.
  let count = 0;

  // Проходим по каждому числу num
  // в массиве nums.
  // На каждой итерации корректируем кандидата
  // и баланс голосов.
  for (const num of nums) {

    // Если баланс обнулился, значит
    // предыдущий кандидат «утратил»
    // большинство до этого момента,
    // и текущий элемент num становится новым
    // кандидатом.
    //
    // В примере [3,3,4] это происходит только
    // при первой итерации:
    // count === 0,
    // результат меняется на nums[0] = 3.
    if (count === 0) result = num;

    // если num совпадает с текущим кандидатом
    // result, прибавляем 1,
    // иначе вычитаем 1 (против кандидата
    // «голосуют» другие элементы).
    //
    // В шаге с num = 4 (третья итерация)
    // result = 3, 
    // 4 !== 3,
    // поэтому count: 2 → 1
    count += (num === result) ? 1 : -1;
  }

  // В конце result хранит мажоритарный элемент.
  //
  // В примере [3,3,4] функция вернёт 3,
  // так как оно встречается чаще всех.
  return result;
}
