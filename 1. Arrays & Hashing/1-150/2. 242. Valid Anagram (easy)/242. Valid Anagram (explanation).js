/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 * 
 * Функция isAnagram проверяет,
 * являются ли строки s и t
 * анаграммами — то есть
 * содержат ли они одинаковые
 * буквы в любом порядке.
 * 
 * Параметры:
 *  s: первая строка,
 *     например "anagram"
 *  t: вторая строка,
 *     например "nagaram"
 * 
 * Возвращает true,
 * если t — это перестановка букв
 * из s, иначе false.
 */
function isAnagram(s, t) {
  // Проверка длины строк.
  // Если длины не совпадают,
  // строки не могут быть
  // анаграммами.
  //
  // Возвращаем false.
  if (s.length !== t.length) return false;

  // Создаем массив charCount
  // из 26 нулей для подсчета букв
  // латинского алфавита
  // в нижнем регистре.
  //
  // После fill: [0, 0, 0, ..., 0]
  //
  // ---
  //
  // Роль массива charCount
  //
  // Массив charCount используется
  // как компактный счетчик разницы
  // в количестве каждой буквы между
  // строками s и t. 
  //
  // ---
  //
  // Инициализация и смысл ячеек
  //
  // - Создается массив из 26 нулей:  
  //   Каждый элемент отвечает за
  //   одну букву латинского алфавита
  //   в нижнем регистре:
  //   - charCount[0] для a  
  //   - charCount[1] для b  
  //   - …  
  //   - charCount[25] для z  
  //
  // ---
  //
  // Инкремент и декремент в цикле
  //
  // При проходе по строкам одновременно:
  // - charCount[s.charCodeAt(i) - 97]++  
  //   Увеличивает счётчик для буквы из строки s.  
  // - charCount[t.charCodeAt(i) - 97]--  
  //   Уменьшает счётчик для буквы из строки t.  
  //
  // В результате каждая одинаковая буква
  // из s и t обнуляет свой слот, а любые
  // расхождения остаются в виде положительных
  // или отрицательных значений.
  //
  // ---
  //
  // Пример работы
  // В этом примере строки s = "abc" и t = "bac"
  // приводят массив обратно к нулям,
  // что свидетельствует о полной компенсации.
  //
  // | i  | s[i] | действие       | charCount до  | charCount после | t[i] | действие      | charCount после |
  // |----|------|----------------|---------------|-----------------|------|---------------|-----------------|
  // | 0  | 'a'  | + на индекс 0  | [0,0,0,…,0]   | [1,0,0,…,0]     | 'b'  | – на индекс 1 | [1,-1,0,…,0]    |
  // | 1  | 'b'  | + на индекс 1  | [1,-1,0,…,0]  | [1,0,0,…,0]     | 'a'  | – на индекс 0 | [0,0,0,…,0]     |
  // | 2  | 'c'  | + на индекс 2  | [0,0,0,…,0]   | [0,0,1,…,0]     | 'c'  | – на индекс 2 | [0,0,0,…,0]     |
  //
  // ---
  //
  // Итоговая проверка
  //
  // После завершения цикла:
  // return charCount.every((n) => n === 0);
  // - Если все элементы charCount равны нулю,
  //   значит частоты букв в s и t совпадают.  
  // - Если есть хоть одно ненулевое значение,
  //   это означает, что какая-то буква
  //   встречается чаще в одной из строк.
  //
  // ---
  //
  // Преимущества подхода
  //
  // - Производительность: временная сложность O(n), 
  //   так как за одну итерацию анализируем сразу
  //   обе строки.
  // - Экономия памяти: потребление памяти O(1)
  //   благодаря фиксированному массиву из 26 элементов.  
  // - Избегается дорогостоящая сортировка
  //   или использование дополнительных структур
  //   для каждой строки.
  // - Простота проверки: единственный вызов every
  //   определяет, сбалансированы ли частоты.
  //
  // ---
  //
  // Возможные расширения
  //
  // - Замена массива на объект или Map для поддержки
  //   любых Unicode-символов.  
  // - Предварительная фильтрация и приведение
  //   к одному регистру для учёта заглавных букв и
  //   игнорирования пробелов или пунктуации.
  const charCount = new Array(26).fill(0);

  // Проходим по всем символам
  // двух строк a и t одновременно.
  for (let i = 0; i < s.length; i++) {

    // Получаем код символа s[i] (UTF-16),
    // вычитаем 97 — код 'a',
    // чтобы привести буквы 'a'–'z'
    // к диапазону индексов 0–25.
    // Увеличиваем соответствующий счетчик,
    // фиксируя встречу буквы в s.
    //
    // Пример:
    // для s[i] = 'a': 
    // s.charCodeAt(i) = 97, 
    // 97 - 97 = 0 → charCount[0]++.
    charCount[s.charCodeAt(i) - 97]++;

    // Аналогично для t[i]: уменьшаем счетчик
    // на единицу, потому что каждая буква во
    // второй строке должна нейтрализовать
    // одну букву из первой.
    //
    // Пример для t[i] = 'b':
    // t.charCodeAt(i) = 98,
    // 98 - 97 = 1 → charCount[1]--.
    charCount[t.charCodeAt(i) - 97]--;
  }

  // После завершения цикла:
  // - Если все элементы charCount равны нулю,
  //   значит частоты букв в s и t совпадают.  
  // - Если есть хоть одно ненулевое значение,
  //   это означает, что какая-то буква
  //   встречается чаще в одной из строк.
  //
  // Метод every проходит по массиву и проверяет
  // условие n === 0 для всех элементов.
  //
  // Пример: 
  // charCount = [0, 1, 0, ...] даст false,
  //             [0, 0, ..., 0] — true.
  return charCount.every((n) => n === 0);
}
