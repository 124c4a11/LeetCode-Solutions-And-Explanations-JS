/**
 * @param {number[]} nums
 * @return {number}
 * 
 * maxSubarraySumCircular принимает массив
 * чисел nums и вычисляет максимальную
 * возможную сумму непрерывного подмассива
 * в кольцевом (циклическом) представлении
 * массива, то есть допускает, что подмассив
 * может оборачиваться с конца массива
 * на его начало.
 * 
 * Возвращает одно число — наибольшую сумму
 * непрерывного подмассива в циклическом
 * массиве nums. Если все элементы
 * неположительны, возвращается наибольший
 * (наименее отрицательный) элемент массива.
 * 
 * Пример:
 *  Для:
 *    nums = [5,-3,5]
 *  Возвращает:
 *    10
 */
function maxSubarraySumCircular(nums) {

  // Устанавливаем глобальный минимум
  // подмассива равным первому элементу
  // массива, это нужно, чтобы корректно
  // отслеживать наименьшую найденную сумму
  // подмассива при первом сравнении.
  let globMin = nums[0];

  // Устанавливаем глобальный максимум
  // подмассива равным первому элементу
  // массива, это нужно, чтобы корректно
  // отслеживать наибольшую найденную сумму
  // подмассива при первом сравнении.
  let globMax = nums[0];

  // currMin — текущая минимальная сумма
  // подмассива, заканчивающегося на текущем
  // элементе, инициализируем нулём, чтобы
  // начать накопление при первом обходе.
  let currMin = 0;

  // currMax — текущая максимальная сумма
  // подмассива, заканчивающегося на текущем
  // элементе, инициализируем нулём для
  // накопления.
  let currMax = 0;

  // total накапливает сумму всех элементов
  // массива. Понадобится для вычисления
  // максимума циклического подмассива.
  let total = 0;

  // Проход по каждому элементу массива nums,
  // обновляем локальные и глобальные величины,
  // а также total.
  for (const num of nums) {

    // Обновление текущего минимума: либо
    // расширяем текущуую минимальную
    // подпоследовательность, добавив num,
    // либо начинаем новую
    // подпоследовательность с самого num,
    // если num меньше, чем currMin + num.
    //
    // Это позволяет отслеживать минимальную
    // непрерывную сумму, необходимую для
    // вычисления обратного (циклического)
    // варианта.
    //
    // Пример для nums = [5,-3,5]:
    // 1-й шаг (num=5):
    //   currMin = Math.min(0 + 5, 5) = 5
    // 2-й шаг (num=-3):
    //   currMin = Math.min(5 + -3, -3) = -3
    // 3-й шаг (num=5):
    //   currMin = Math.min(-3 + 5, 5) = 2
    currMin = Math.min(currMin + num, num);

    // Обновление текущего максимума: либо
    // расширяем текущую максимальную
    // подпоследовательность, либо начинаем
    // новую с num.
    //
    // Это классический шаг алгоритма Kadane
    // для поиска максимальной суммы
    // непрерывного подмассива.
    //
    // Пример для nums = [5,-3,5]:
    // 1-й шаг (num=5):
    //   currMax = Math.max(0 + 5, 5) = 5
    // 2-й шаг (num=-3):
    //   currMax = Math.max(5 + -3, -3) = 2
    // 3-й шаг (num=5):
    //   currMax = Math.max(2 + 5, 5) = 7
    currMax = Math.max(currMax + num, num);

    // Накопление общей суммы элементов для
    // дальнейшего вычисления циклической суммы.
    //
    // Пример:
    // 1-й шаг (num=5): total = 0 + 5 = 5
    // 2-й шаг (num=-3): total = 5 + (-3) = 2
    // 3-й шаг (num=5): total = 2 + 5 = 7
    total += num;

    // Обновление глобального минимума:
    // сохраняем минимальное из уже найденных
    // currMin.
    //
    // Это позволит в конце получить
    // минимальную непрерывную сумму, вычитание
    // которой из total даёт сумму максимум для
    // циклического случая (когда мы выбираем
    // часть с двух концов массива).
    //
    // Пример:
    // Изначально globMin = 5
    // 1-й шаг (num=5): globMin = min(5, 5) = 5
    // 2-й шаг (num=-3): globMin = min(5, -3) = -3
    // 3-й шаг (num=5): globMin = min(-3, 2) = -3
    globMin = Math.min(globMin, currMin);

    // Обновляем глобальный максимум:
    // сохраняем наибольшее значение currMax,
    // встреченное за все итерации.
    //
    // Пример:
    // Изначально globMax = 5
    // 1-й шаг (num=5): globMax = max(5, 5) = 5
    // 2-й шаг (num=-3): globMax = max(5, 2) = 5
    // 3-й шаг (num=5): globMax = max(5, 7) = 7
    globMax = Math.max(globMax, currMax);
  }

  // Заключительная проверка и возврат результата.
  //
  // Если globMax > 0, значит существует
  // положительная сумма подмассива.
  // Возвращаем максимум из двух вариантов:
  // 1. globMax — наибольшая сумма непрерывного
  //    нециклического подмассива
  // 2. total - globMin —  наибольшая сумма
  //    циклического подмассива, полученная как
  //    сумма всех элементов за вычетом
  //    минимальной суммы нециклического
  //    подамссива
  //
  // Если globMax <= 0, это означает, что все
  // элементы либо нулевые, либо отрицательные,
  // тогда лучший выбор — просто globMax
  // (наибольшее из отрицательных или ноль).
  //
  // Пример для nums = [5,-3,5]:
  // После цикла: 
  //   total = 7,
  //   globMax = 7,
  //   globMin = -3
  // total - globMin = 7 - (-3) = 10
  // globMax > 0,
  // поэтому возвращаем max(7, 10) = 10
  return globMax > 0
    ? Math.max(globMax, total - globMin)
    : globMax;
}
