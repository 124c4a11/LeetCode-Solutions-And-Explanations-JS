/**
 * @param {number[]} ratings
 * @return {number}
 * 
 * candy принимает массив оценок учащихся или
 * детей
 * 
 * Функция рассчитывает и возвращает минимальное
 * количество конфет, которые нужно выдать,
 * чтобы у каждого ребёнка было по крайней мере
 * по одной конфете и каждый ребёнок с большей
 * оценкой чем сосед получал больше конфет.
 * 
 * Пример для:
 *   ratings = [4,5,3]
 * Результат:
 *   4
 */
function candy(ratings) {
  const n = ratings.length;

  // Инициализация переменной result значением
  // n — это минимальное количество конфет,
  // предполагающее, что каждому ребёнку уже
  // дали по одной конфете
  let result = n;

  // Индекс i указывает на текущую позицию
  // в массиве при проходе.
  //
  // Начинаем с 1, потому что при сравнении
  // мы смотрим на i и i-1,
  // начальная пара — элементы 0 и 1.
  let i = 1;

  // Внешний цикл:
  // обходим массив слева направо, пока i
  // не достигнет n
  while (i < n) {

    // Если текущая оценка равна предыдущей,
    // то нет необходимости кому-либо
    // увеличивать количество конфет по
    // отношению друг к другу, поэтому
    // просто сдвигаем указатель и продолжаем
    // цикл, оставив в этой точке каждому
    // ребенку из пары по одной конфете.
    if (ratings[i] === ratings[i - 1]) {
      i++;
      continue;
    }

    // Переменная inc будет хранить число
    // последовательных шагов текущего строго
    // возрастающего участка, то есть сколько
    // раз подряд ratings[i] > ratings[i-1] 
    let inc = 0;

    // Внутренний цикл для обработки строго
    // возрастающей последовательности.
    //
    // Пока следующий ребёнок имеет строго
    // большую оценку, считаем возрастания
    // и добавляем к результату последовательные
    // дополнительные конфеты для этого участка.
    //
    // Для каждого шага inc увеличивается на 1,
    // и мы каждому следующему ребенку добавляем
    // inc конфет, что соответствует
    // распределению 1,2,3,... вдоль возрастания.
    while (
      i < n
      && ratings[i] > ratings[i - 1]
    ) {

      // Увеличиваем счётчик длинны
      // возрастающего участка на 1
      //
      // Так же это количество дополнительных
      // конфет для текущего шага 
      inc++;

      // Для каждого шага возрастаюего участка
      // нужно дать следующему ребёнку на 1
      // конфету больше, чем предыдущему в
      // этой цепочке.
      //
      // Первая итерация inc=1 добавляет одну
      // дополнительную конфету для ребёнка с
      // большей оценкой, вторая итерация inc=2
      // добавляет две дополнительные конфеты
      // следующему ребенку с большей оценкой
      // и т.д.
      //
      // Поэтому результат увеличивается на inc,
      // аккумулируя суммарные дополнительные
      // конфеты для этого возрастающего участка.
      result += inc;

      // Переходим к следующей позиции для
      // продолжения анализа текущего
      // возрастающего участка до его окончания
      // и возможному переходу к убывающему
      // участку
      i++;
    }

    // Переменная dec будет хранить число
    // последовательных шагов текущего строго
    // убывающего участка, то есть сколько раз
    // подряд ratings[i] < ratings[i-1]
    let dec = 0;

    // Внутренний цикл для обработки строго
    // убывающей последовательности.
    //
    // Пока следующий ребёнок имеет строго меньшую
    // оценку, считаем убывания и добавляем
    // к результату последовательные дополнительные
    // конфеты для этого участка.
    //
    // Для каждого шага dec увеличивается на 1,
    // и мы добавляем dec к результату,
    // что соответствует распределению 1,2,3,...
    // вдоль убывания, но в обратном порядке по 
    // отношению к детям
    //
    // Для убывающего сегмента каждому следующему
    // ребёнку требуется всё меньше конфет по
    // сравнению с пиком.
    // Мы добавляем dec, потому что если убывание
    // длины k, то дополнительные конфеты
    // соответствуют сумме 1+2+...+k, и по мере
    // прохождения цикла этот счёт аккумулируется.
    //
    // Подобная логика допустима, так как нам нужно
    // знать общее количество конфет, а не то, 
    // сколько конфет получит каждый отдельный 
    // ребенок.
    while (
      i < n
      && ratings[i] < ratings[i - 1]
    ) {

      // Увеличиваем счётчик длинны
      // убывающего участка на 1
      //
      // Так же это количество дополнительных
      // конфет для текущего шага
      dec++;

      // Для убывающего сегмента каждому
      // следующему ребёнку требуется всё
      // меньше конфет по сравнению с пиком.
      // Мы добавляем dec, потому что если
      // убывание длины k, то дополнительные
      // конфеты  соответствуют сумме
      // 1+2+...+k, и по мере прохождения
      // цикла этот счёт аккумулируется.
      result += dec;

      // Переходим к следующей позиции для
      // продолжения анализа текущего
      // убывающего участка до его окончания
      // и возможному переходу к
      // возрастающему участку
      i++;
    }

    // Корректировка для перекрывающей вершины
    // между возрастающим и убывающим участками:
    //
    // Вершина между возрастающим и убывающим
    // участками (переход из возрастания в
    // убывание, если перед спадом был подъём),
    // была учтена дважды: в конце возрастания
    // и в начале убывания как требующая
    // увеличения конфет.
    // 
    // Чтобы убрать двойной учёт, и не дать
    // вершине лишние конфеты дважды,
    // вычитаем из результата минимум от
    // inc и dec — это корректирует
    // количество конфет в "пике".
    //
    // То есть, если на возврастающем участке
    // мы добавили к результату 3 конфеты,
    // а на убывающем 2, том мы должны удалить
    // 2 конфеты, так как они уже были учтены
    // на возрастающем участке
    //
    // Выражение вычитает минимальную длину
    // перекрывающихся частей возрастающего
    // и убывающего сегментов  в зависимости
    // от значений inc и dec
    // 
    // Примеры:
    // - Если inc = 1 и dec = 1,
    //   тогда вычитается Math.min(1,1) = 1
    //   — удаляется одна конфета
    //   (типичный случай с одиночным пиком).  
    //
    // - Если inc = 0 и dec = 2,
    //   тогда вычитается Math.min(0,2) = 0
    //   — ничего не вычитается, потому что
    //   пика слева не было.  
    //
    // - Если inc = 3 и dec = 2,
    //   тогда вычитается Math.min(3,2) = 2
    //   — убираются две конфеты, потому что
    //   две нижние ступени убывающего участка
    //   были учтены в суммах обоих участков и
    //   перекрываются.  
    //
    // - Если inc = 4 и dec = 4, вычитается 4
    //   — большая симметричная вершина требует
    //   вычесть всю перекрывающуюся часть.
    // 
    // Короткая интерпретация:
    // выражение корректирует двойной подсчёт
    // для всех ступеней, которые были учтены
    // и в возрастающей, и в убывающей частях.
    // Величина коррекции равна числу таких
    // перекрывающихся ступеней.
    result -= Math.min(inc, dec);

    // Пример работы цикла для
    // ratings = [4, 5, 3]
    // 
    // Инициализация  
    // - ratings = [4, 5, 3]  
    // - n = 3  
    // - result = n = 3
    // - i = 1
    // 
    // Шаг 1: вход в while (i < n) с i = 1  
    // - Сравниваем ratings[1] (5)
    //   и ratings[0] (4):
    //   5 !== 4 и 5 > 4 → пойдём в блок
    //   возрастания.  
    // - Инициализируем inc = 0.
    // 
    // Внутренний цикл возрастания
    // (пока ratings[i] > ratings[i-1]):  
    // - Итерация 1 (возрастание):
    //   условие true (5 > 4)  
    //   - inc++ → inc = 1
    //   - result += inc → result = 3 + 1 = 4
    //   - i++ → i = 2
    // - Следующая проверка:
    //   i = 2, проверяем
    //   ratings[2] (3) > ratings[1] (5)
    //   → условие ложно, выходим из цикла
    //     возрастания.
    // 
    // После цикла возрастания:  
    // - Текущее состояние: 
    //   inc = 1
    //   result = 4
    //   i = 2
    // - Инициализируем dec = 0.
    // 
    // Внутренний цикл убывания
    // (пока ratings[i] < ratings[i-1]):  
    // - Итерация 1 (убывание):
    //   проверка для i = 2:
    //   3 < 5 → условие true  
    //   - dec++ → dec = 1
    //   - result += dec → result = 4 + 1 = 5
    //   - i++ → i = 3
    // - Следующая проверка: i = 3 ≥ n
    //   → выходим из цикла убывания.
    // 
    // После цикла убывания и корректировки
    // перекрытия:  
    // - Перед корректировкой: 
    //   inc = 1
    //   dec = 1
    //   result = 5
    //   i = 3.  
    // - Вычитаем Math.min(inc, dec) = 1
    //   → result = 5 - 1 = 4
    // 
    // Шаг 2: проверка внешнего цикла  
    // - i = 3, i < n ложь
    //   → внешний while завершается.
    // 
    // Итоговое состояние и возвращаемое
    // значение  
    // - result = 4 — функция вернёт 4.  
    // - Возможный корректный расклад
    //   по детям: [1,2,1].
  }

  // Возвращаем итоговое минимальное количество
  // конфет
  return result;
}
