/**
 * @param {string} s
 * @param {number} minJump
 * @param {number} maxJump
 * @return {boolean}
 * 
 * Функция canReach проверяет, можно ли, начиная
 * с позиции 0 строки s, добраться до последнего
 * индекса строки, делая прыжки длиной
 * от minJump до maxJump включительно и разрешая
 * приземляться только на символы '0'.
 * 
 * Параметры:
 * - s — строка, состоящая из символов '0' и '1',
 *   где '0' означает допустимую позицию для
 *   приземления, а '1' — недопустимую.  
 * - minJump — целое неотрицательное число,
 *   минимальная длина одного прыжка.  
 * - maxJump — целое неотрицательное число,
 *   максимальная длина одного прыжка.
 * 
 * Возвращаемое значение:
 * - Возвращает true, если существует
 *   последовательность допустимых прыжков
 *   от индекса 0 до индекса n - 1;  
 * - Возвращает false, если такой
 *   последовательности не существует.
 * 
 * Пример для:
 *   s = "011010", minJump = 2, maxJump = 3
 * Возвращает:
 *   true
 */
function canReach(s, minJump, maxJump) {

  // Получаем длину строки s и сохраняем
  // её в n для удобства дальнейших проверок.
  const n = s.length;

  // Создаём очередь q для реализации поиска
  // в ширину (BFS).
  //
  // Очередь хранит индексы позиций,
  // от которых будем пытаться прыгнуть
  // дальше.
  const q = new Queue();

  // Помещаем стартовую позицию 0 в очередь.
  //
  // Считаем, что стартовая позиция валидна
  // по условию задачи.
  q.enqueue(0);

  // Переменная farthest хранит самый правый
  // индекс, до которого уже выполнён перебор
  // возможных переходов из всех ранее
  // обработанных вершин.
  //
  // Это оптимизация, чтобы не повторять
  // добавление в очередь одних и тех же
  // индексов, которые уже были рассмотрены.
  //
  // farthest предотвращает повторную проверку
  // одной и той же позиции несколькими
  // родительскими индексами, что делает
  // суммарную сложность ближе к линейной,
  // а не квадратичной.
  let farthest = 0;

  // Основной цикл BFS:
  // пока есть позиции для обработки,
  // извлекаем индекс и рассматриваем все
  // допустимые прыжки из этого индекса
  //
  // Этот цикл гарантирует, что мы
  // рассматриваем позиции в порядке
  // увеличения расстояния от старта
  // (по уровням BFS).
  while (!q.isEmpty()) {

    // Извлекаем текущий индекс i из очереди
    // для обработки всех возможных прыжков
    // от него
    const i = q.dequeue();

    // Вычисляем начальный индекс start для
    // перебора целевых позиций j.
    //
    // start задаёт первый индекс, который
    // нужно проверить для прыжков из i,
    // выбирая ближайший допустимый по
    // минимальному прыжку, который ещё
    // не был проверен ранее.
    //
    // i + minJump — это минимальный индекс,
    // на который можно прыгнуть с текущей
    // позиции i по требованию задачи.
    // Проверять индексы левее этого значения
    // бесполезно, потому что прыжок меньшей
    // длины запрещён.
    //
    // Зачем нужен farthest + 1:
    // - farthest хранит максимальную правую
    //   границу, до которой мы уже прошли
    //   проверку для предыдущих вершин BFS.
    //   Если начать с i + minJump без учёта
    //   farthest, мы можем повторно
    //   обрабатывать индексы, уже добавленные
    //   в очередь.
    //
    // - farthest + 1 предотвращает
    //   дублирование и делает общий перебор
    //   амортизированно линейным по длине строки,
    //   поскольку каждый индекс обрабатывается
    //   не более одного раза.
    //
    // Почему используется Math.max(...)
    // Math.max берёт правую (большую) из двух
    // кандидатов, потому что нам нужно начать
    // с той позиции, которая одновременно:
    // 1. не ближе минимального разрешённого
    //    прыжка от i (i + minJump), и
    // 2. правее всех уже ранее проверённых
    //    позиций (farthest + 1). Использование
    //    максимума гарантирует, что мы не будем
    //    проверять позиции, которые ещё
    //    недоступны из i, и не будем повторно
    //    просматривать индексы, уже охваченные
    //    предыдущими шагами.
    //
    // start = Math.max(...) означает:
    // «начать проверку с позиции, которая
    // одновременно удовлетворяет ограничению
    // минимального прыжка и не была ранее
    // проверена» — это минимально возможное
    // новое место для проверки.
    const start = Math.max(
      i + minJump,
      farthest + 1
    );

    // Перебираем индексы j, до которых можно
    // допрыгнуть от i, начиная со start и
    // до min(i + maxJump + 1, n) не включая
    // верхнюю границу (i + maxJump + 1, n)
    //
    // i + maxJump + 1 задаёт верхнюю границу
    // как полуоткрытый конец интервала.
    // Если максимально допустимый индекс
    // прыжка равен i + maxJump, то установка
    // верхней границы как i + maxJump + 1
    // позволяет использовать условие j < end
    // и включить в перебор индекс i + maxJump
    // (поскольку j будет сравниваться строго
    // меньше). Иначе пришлось бы писать 
    // j <= i + maxJump.
    //
    // Math.min гарантирует, что верхняя
    // граница не выйдет за пределы строки.
    // Если i + maxJump >= n, цикл остановится
    // на n, то есть индекс n-1 будет
    // последним возможным для проверки.
    for (
      let j = start;
      j < Math.min(i + maxJump + 1, n);
      j++
    ) {

      // Если в позиции j стоит '1', то эта
      // клетка недоступна для приземления
      // — пропускаем.
      if (s[j] !== '0') continue;

      // Если s[j] = '0', добавляем индекс
      // j в очередь для последующей
      // обработки
      // (мы можем прыгать от j дальше)
      q.enqueue(j);

      // Если достигли последней позиции
      // строки, возвращаем true:
      // путь найден.
      if (j === n - 1) return true;
    }

    // Обновляем farthest:
    // после обработки позиции i мы
    // гарантированно проверили все индексы
    // до i + maxJump (включительно), поэтому
    // можно сдвинуть границу на i + maxJump.
    //
    // Это позволяет в дальнейших шагах
    // пропускать повторную проверку уже 
    // проверянных индексов.
    //
    // Заметьте, farthest может указывать
    // за пределы n-1, что безопасно,
    // потому что границы в цикле for
    // ограничивают j значением n.
    farthest = i + maxJump;
  }

  // Если очередь опустела и мы не вернули true,
  // значит последняя позиция недостижима
  // из стартовой позиции — возвращаем false.
  return false;
}
