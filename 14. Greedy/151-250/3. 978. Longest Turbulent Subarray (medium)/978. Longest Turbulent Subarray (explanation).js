/**
 * @param {number[]} arr
 * @return {number}
 * 
 * maxTurbulenceSize, принимает один параметр
 * arr — массив чисел, для которого вычисляет
 * длину самого длинного турбулентного
 * подмассива массива arr, в котором
 * соседние элементы чередуются по отношению
 * больше/меньше.
 * Возвращаемое значение — количество элементов
 * в этом подмассиве.
 *
 * Что такое турбулентный подмассив
 * - Турбулентный подмассив — последовательность
 *   элементов arr[l..r], где для каждого индекса
 *   k от l до r-1 сравнения между соседними
 *   элементами чередуются: arr[k] > arr[k+1],
 *   затем arr[k+1] < arr[k+2],
 *   затем снова > и т.д.,
 *   либо наоборот (<, >, <, ...).
 * - Последовательности, в которых встречаются
 *   подряд равные элементы, не считаются
 *   продолжающими турбулентность и разрывают
 *   такую последовательность.
 * 
 * Пример:
 *   Для:
 *     arr = [9,4,2,10,7,8,8,1,9]
 *   Результат:
 *     5
 *   Объяснение:
 *     arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
 */
function maxTurbulenceSize(arr) {

  // result хранит максимальную найденную длину
  // турбулентной последовательности
  let result = 0;

  // cnt — текущий счётчик подряд идущих
  // корректно чередующихся сравнений
  let cnt = 0;

  // sign хранит знак предыдущего сравнения
  // между соседними элементами:
  // '>', '<' или '='
  //
  // '=' означает отсутствие предыдущего
  // значимого сравнения
  // (старт или после равных элементов)
  let sign = '=';

  // Запуск цикла по индексам массива от 0
  // до предпоследнего индекса включительно,
  // потому что внутри цикла происходит
  // сравнение arr[i] с arr[i + 1].
  for (let i = 0; i < arr.length - 1; i++) {

    // Если текущий элемент больше следующего,
    // то мы получили знак сравнения '>'
    if (arr[i] > arr[i + 1]) {

      // Если предыдущий знак был '<', значит
      // сравнения чередуются корректно,
      // увеличиваем cnt на 1 (расширяем
      // текущую турбулентную
      // последовательность)
      //
      // Если предыдущий знак не '<'
      // (т.е. либо '>', либо '='), начинаем
      // новую последовательность сравнений
      // длиной 1
      cnt = sign === '<' ? cnt + 1 : 1;

      // Обновляем предыдущий знак на '>',
      // чтобы следующий шаг мог проверить
      // чередование
      sign = '>';

      // Иначе если текущий элемент меньше
      // следующего, то мы получили знак
      // сравнения '<'
    } else if (arr[i] < arr[i + 1]) {

      // Если предыдущий знак был '>', значит
      // сравнения чередуются корректно,
      // увеличиваем cnt на 1
      //
      // Иначе начинаем новую последовательность
      // сравнений длиной 1
      cnt = sign === '>' ? cnt + 1 : 1;

      // Обновляем предыдущий знак на '<'
      sign = '<';
    } else {

      // Если элементы равны, турбулентность
      // обрывается: нет полезного сравнения
      // для продолжения, поэтому сбрасываем
      // счётчик и знак до исходных значений
      cnt = 0;
      sign = '=';
    }

    // Обновляем result максимально возможным
    // значением между текущим result и текущим cnt.
    //
    // result хранит наибольшее обнаруженное
    // значение cnt до этого момента.
    result = Math.max(result, cnt);
  }

  // Возвращаем длину максимального турбулентного
  // подмассива.
  //
  // Что хранит result
  // result в коде хранит максимальное количество
  // подряд идущих правильных сравнений между
  // соседними элементами массива, то есть
  // максимальное число переходов типа ">" или "<"
  // внутри турбулентной последовательности.
  //
  // Почему +1
  // Количество элементов в подмассиве на единицу
  // больше, чем количество сравнений между
  // соседними элементами этого подмассива.
  // Добавление 1 переводит метрику из
  // "числа сравнений" в "число элементов",
  // которые ожидает вернуть функция.
  //
  // Простой пример
  // Если cnt (и следовательно result) равен 2,
  // это означает две подряд верных сравнений,
  // например arr[i] > arr[i+1] и arr[i+1] < arr[i+2];
  // это подмассив из трёх элементов, поэтому
  // return result + 1 вернёт 3.
  //
  // Пограничные случаи
  // При одном элементе в массиве цикл не выполняется,
  // result остаётся 0, и return result + 1
  // возвращает 1, что корректно отражает длину
  // подмассива из одного элемента.
  //
  // При пустом массиве функция также вернёт 1
  // из-за этой формулы, что обычно считается
  // некорректным и требует отдельной проверки длины
  // массива перед вычислением, если нужно, чтобы
  // пустой массив давал 0.
  return result + 1;
}
