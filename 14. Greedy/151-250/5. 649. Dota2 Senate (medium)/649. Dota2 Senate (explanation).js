/**
 * @param {string} senate
 * @return {string}
 * 
 * Функция моделирует последовательный процесс
 * голосования/блокировок между двумя партиями
 * сенаторов и определяет, какая партия победит
 * в конце.
 *
 * Принимает один параметр senate — строка,
 * в которой каждый символ обозначает сенатора:
 * 'R' для Radiant и 'D' для Dire.
 * 
 * Возвращает название партии-победителя
 * ('Radiant' или 'Dire') после завершения
 * имитации противостояния
 * 
 * Пример для:
 *   senate = "RRDDD"
 * Результат:
 *   "Radiant"
 */
function predictPartyVictory(senate) {

  // Преобразуем входную строку в массив
  // символов
  //
  // Преобразование в массив даёт возможность
  // модифицировать последовательность
  // сенаторов в процессе итерации с помощью
  // методов массива
  //
  // В алгоритме требуется добавлять новых
  // сенаторов в конец массива во время
  // прохода по нему, моделируя обработку
  // очереди сенаторов. Метод push позволяет
  // эффективно добавлять элементы к концу
  // массива
  //
  // Использование строки вместо массива
  // значительно замедляет работу функции
  // - скорость работы со строкой: 36-44 ms
  // - скорость работы с массивом: 0-8 ms
  const s = senate.split('');

  // Инициализация счетчика cnt, который
  // отражает относительное преимущество:
  // - положительное значение означает
  //   перевес Radiant (R)
  // - отрицательное — Dire (D)
  let cnt = 0;

  // Запускаем цикл по индексам массива s.
  //
  // Важно:
  // длина s может увеличиваться внутри цикла
  // из-за s.push(...). Таким образом цикл
  // моделирует обработку очереди сенаторов,
  // где новые элементы добавляются в конец.
  for (let i = 0; i < s.length; i++) {

    // Если текущий символ представляет
    // партию Radiant (R)
    if (s[i] === 'R') {

      // Если cnt < 0, это означает, что
      // Dire имели «избыточные» ходы
      // (было больше действующих 'D'),
      // способные нейтрализовать некоторую
      // часть Radiant. Поэтому текущий 'R'
      // фактически нейтрализован чьим-то
      // предыдущим правом блокировки и
      // не может реализовать немедленное
      // действие.
      //
      // В этом алгоритме это симулируется
      // добавлением в конец очереди
      // символа 'D', что означает
      // сохранённое преимущество Dire на
      // следующем круге: один его ход
      // «переносится» в конец очереди как
      // новый сенатор Dire 
      if (cnt < 0) s.push('D');

      // Увеличение счётчика на единицу
      // фиксирует факт присутствия текущего R:
      // он увеличивает относительное
      // преимущество Radiant на единицу.
      //
      // cnt отсчитывает чистое преимущество
      // Radiant над Dire, поэтому встреча R
      // всегда инкрементирует этот баланс,
      // независимо от того, была ли выполнена
      // операция s.push('D').
      cnt++;
    } else {

      // Ветка для случая, когда текущий
      // символ — 'D'
      //
      // Если счётчик cnt положительный, значит
      // у Radiant накопились непотраченные
      // «блокировки» (плюсовые права),
      // которые способны нейтрализовать
      // текущего 'D'. Вместо явного удаления
      // текущего 'D' алгоритм моделирует
      // эффект нейтрализации добавлением в
      // конец очереди символа противоположной
      // фракции 'R'. Это отражает, что Radiant
      // сохраняет своё влияние для следующего
      // раунда: один его ход «переносится»
      // в конец очереди как новый сенатор
      // Radiant.
      if (cnt > 0) s.push('R');

      // Уменьшение счётчика на единицу
      // фиксирует факт присутствия текущего D:
      // он снижает относительное преимущество
      // Radiant на единицу.
      //
      // cnt отсчитывает чистое преимущество
      // Radiant над Dire, поэтому встреча D
      // всегда декрементирует этот баланс,
      // независимо от того, была ли выполнена
      // операция push s.push('R').
      cnt--;
    }

    // Пример работы цикла:
    //
    // Исходные данные:
    // senate = "RRDDD" 
    // s = ['R','R','D','D','D']
    // cnt = 0
    //
    // Шаг 1: 
    //   i = 0;
    //   s[i] = 'R' 
    // до:
    //   s = ['R'*,'R','D','D','D'];
    //   cnt = 0 
    // действие:
    //   cnt < 0? нет; не push;
    //   cnt++ 
    // после:
    //   s = ['R'*,'R','D','D','D'];
    //   cnt = 1
    //
    // Шаг 2: 
    //   i = 1;
    //   s[i] = 'R' 
    // до:
    //   s = ['R','R'*,'D','D','D'];
    //   cnt = 1
    // действие:
    //   cnt < 0? нет; не push;
    //   cnt++
    // после:
    //   s = ['R','R'*,'D','D','D'];
    //   cnt = 2
    //
    // Шаг 3: 
    //   i = 2; 
    //   s[i] = 'D' 
    // до: 
    //   s = ['R','R','D'*,'D','D'];
    //   cnt = 2 
    // действие:
    //   cnt > 0? да → push('R');
    //   cnt-- 
    // после:
    //   s = ['R','R','D'*,'D','D','R'];
    //   cnt = 1
    //
    // Шаг 4: 
    //   i = 3;
    //   s[i] = 'D' 
    // до:
    //   s = ['R','R','D','D'*,'D','R'];
    //   cnt = 1 
    // действие:
    //   cnt > 0? да → push('R');
    //   cnt-- 
    // после:
    //   s = ['R','R','D','D'*,'D','R','R'];
    //   cnt = 0
    //
    // Шаг 5:
    //   i = 4;
    //   s[i] = 'D' 
    // до:
    //   s = ['R','R','D','D','D'*,'R','R'];
    //   cnt = 0 
    // действие:
    //   cnt > 0? нет; не push;
    //   cnt-- 
    // после:
    //   s = ['R','R','D','D','D'*,'R','R'];
    //   cnt = -1
    //
    // Шаг 6:
    //   i = 5;
    //   s[i] = 'R' (добавлен на шаге 3)
    // до:
    //   s = ['R','R','D','D','D','R'*,'R'];
    //   cnt = -1
    // действие:
    //   cnt < 0? да → push('D');
    //   cnt++ 
    // после:
    //   s = ['R','R','D','D','D','R'*,'R','D'];
    //   cnt = 0
    //
    // Шаг 7: 
    //   i = 6;
    //   s[i] = 'R' (добавлен на шаге 4)
    // до: 
    //   s = ['R','R','D','D','D','R','R'*,'D'];
    //   cnt = 0 
    // действие:
    //   cnt < 0? нет; не push;
    //   cnt++ 
    // после:
    //   s = ['R','R','D','D','D','R','R'*,'D'];
    //   cnt = 1
    //
    // Шаг 8:
    //   i = 7;
    //   s[i] = 'D' (добавлен на шаге 6)
    // до:
    //   s = ['R','R','D','D','D','R','R','D'*];
    //   cnt = 1
    // действие:
    //   cnt > 0? да → push('R');
    //   cnt--
    // после:
    //   s = ['R','R','D','D','D','R','R','D'*,'R'];
    //   cnt = 0
    //
    // Шаг 9:
    //   i = 8;
    //   s[i] = 'R' (добавлен на шаге 8)
    // до:
    //   s = ['R','R','D','D','D','R','R','D','R'*];
    //   cnt = 0
    // действие:
    //   cnt < 0? нет; не push;
    //   cnt++
    // после:
    //   s = ['R','R','D','D','D','R','R','D','R'*];
    //   cnt = 1
    //
    // Конец цикла: i = 9;
    // условие i < s.length (9) ложно
    //
    // Итог:
    //   s = ['R','R','D','D','D','R','R','D','R'*],
    //   cnt = 1 → возвращается 'Radiant'
  }

  // После окончания обхода массива возвращаем
  // победителя:
  // если cnt > 0 побеждает Radiant,
  // иначе Dire
  //
  // Пример для:
  //   senate = "RRDDD"
  // Результат:
  //   "Radiant
  return cnt > 0 ? 'Radiant' : 'Dire';
}
